
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>validatorgo: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/bube054/validatorgo/contains.go (100.0%)</option>
				
				<option value="file1">github.com/bube054/validatorgo/equals.go (100.0%)</option>
				
				<option value="file2">github.com/bube054/validatorgo/isAlpham.go (100.0%)</option>
				
				<option value="file3">github.com/bube054/validatorgo/isabarouting.go (100.0%)</option>
				
				<option value="file4">github.com/bube054/validatorgo/isafter.go (100.0%)</option>
				
				<option value="file5">github.com/bube054/validatorgo/isalphanum.go (100.0%)</option>
				
				<option value="file6">github.com/bube054/validatorgo/isascii.go (100.0%)</option>
				
				<option value="file7">github.com/bube054/validatorgo/isbase32.go (100.0%)</option>
				
				<option value="file8">github.com/bube054/validatorgo/isbase58.go (100.0%)</option>
				
				<option value="file9">github.com/bube054/validatorgo/isbase64.go (100.0%)</option>
				
				<option value="file10">github.com/bube054/validatorgo/isbefore.go (100.0%)</option>
				
				<option value="file11">github.com/bube054/validatorgo/isbic.go (100.0%)</option>
				
				<option value="file12">github.com/bube054/validatorgo/isboolean.go (100.0%)</option>
				
				<option value="file13">github.com/bube054/validatorgo/isbtcaddress.go (100.0%)</option>
				
				<option value="file14">github.com/bube054/validatorgo/isbytelength.go (100.0%)</option>
				
				<option value="file15">github.com/bube054/validatorgo/iscountrycode.go (100.0%)</option>
				
				<option value="file16">github.com/bube054/validatorgo/iscreditcard.go (100.0%)</option>
				
				<option value="file17">github.com/bube054/validatorgo/iscurrency.go (65.2%)</option>
				
				<option value="file18">github.com/bube054/validatorgo/isdatauri.go (100.0%)</option>
				
				<option value="file19">github.com/bube054/validatorgo/isdate.go (90.9%)</option>
				
				<option value="file20">github.com/bube054/validatorgo/isdecimal.go (30.6%)</option>
				
				<option value="file21">github.com/bube054/validatorgo/isdivisibleby.go (83.3%)</option>
				
				<option value="file22">github.com/bube054/validatorgo/isean.go (100.0%)</option>
				
				<option value="file23">github.com/bube054/validatorgo/isemail.go (91.1%)</option>
				
				<option value="file24">github.com/bube054/validatorgo/isempty.go (100.0%)</option>
				
				<option value="file25">github.com/bube054/validatorgo/isetheruemaddress.go (100.0%)</option>
				
				<option value="file26">github.com/bube054/validatorgo/isfloat.go (76.7%)</option>
				
				<option value="file27">github.com/bube054/validatorgo/isfqdn.go (95.2%)</option>
				
				<option value="file28">github.com/bube054/validatorgo/isfreightcontainerid.go (87.5%)</option>
				
				<option value="file29">github.com/bube054/validatorgo/isfullwidth.go (100.0%)</option>
				
				<option value="file30">github.com/bube054/validatorgo/ishalfwidth.go (100.0%)</option>
				
				<option value="file31">github.com/bube054/validatorgo/ishash.go (75.0%)</option>
				
				<option value="file32">github.com/bube054/validatorgo/ishexadecimal.go (100.0%)</option>
				
				<option value="file33">github.com/bube054/validatorgo/ishexcolor.go (100.0%)</option>
				
				<option value="file34">github.com/bube054/validatorgo/ishsl.go (15.4%)</option>
				
				<option value="file35">github.com/bube054/validatorgo/isiban.go (75.0%)</option>
				
				<option value="file36">github.com/bube054/validatorgo/isidentitycard.go (50.0%)</option>
				
				<option value="file37">github.com/bube054/validatorgo/isimei.go (100.0%)</option>
				
				<option value="file38">github.com/bube054/validatorgo/isin.go (100.0%)</option>
				
				<option value="file39">github.com/bube054/validatorgo/isint.go (95.8%)</option>
				
				<option value="file40">github.com/bube054/validatorgo/isip.go (41.7%)</option>
				
				<option value="file41">github.com/bube054/validatorgo/isiprange.go (85.4%)</option>
				
				<option value="file42">github.com/bube054/validatorgo/isisbn.go (88.2%)</option>
				
				<option value="file43">github.com/bube054/validatorgo/isisin.go (100.0%)</option>
				
				<option value="file44">github.com/bube054/validatorgo/isiso31661alpha2.go (100.0%)</option>
				
				<option value="file45">github.com/bube054/validatorgo/isiso31661alpha3.go (100.0%)</option>
				
				<option value="file46">github.com/bube054/validatorgo/isiso31661numeric.go (100.0%)</option>
				
				<option value="file47">github.com/bube054/validatorgo/isiso4217.go (100.0%)</option>
				
				<option value="file48">github.com/bube054/validatorgo/isiso6346.go (94.1%)</option>
				
				<option value="file49">github.com/bube054/validatorgo/isiso6391.go (100.0%)</option>
				
				<option value="file50">github.com/bube054/validatorgo/isiso8601.go (100.0%)</option>
				
				<option value="file51">github.com/bube054/validatorgo/isisrc.go (100.0%)</option>
				
				<option value="file52">github.com/bube054/validatorgo/isissn.go (94.3%)</option>
				
				<option value="file53">github.com/bube054/validatorgo/isjson.go (100.0%)</option>
				
				<option value="file54">github.com/bube054/validatorgo/isjwt.go (90.0%)</option>
				
				<option value="file55">github.com/bube054/validatorgo/islatlong.go (100.0%)</option>
				
				<option value="file56">github.com/bube054/validatorgo/islength.go (100.0%)</option>
				
				<option value="file57">github.com/bube054/validatorgo/islicenseplate.go (0.0%)</option>
				
				<option value="file58">github.com/bube054/validatorgo/islocale.go (100.0%)</option>
				
				<option value="file59">github.com/bube054/validatorgo/islowercase.go (100.0%)</option>
				
				<option value="file60">github.com/bube054/validatorgo/isluhnnumber.go (92.3%)</option>
				
				<option value="file61">github.com/bube054/validatorgo/ismacaddress.go (91.7%)</option>
				
				<option value="file62">github.com/bube054/validatorgo/ismagneturi.go (100.0%)</option>
				
				<option value="file63">github.com/bube054/validatorgo/ismailtouri.go (100.0%)</option>
				
				<option value="file64">github.com/bube054/validatorgo/ismd5str.go (100.0%)</option>
				
				<option value="file65">github.com/bube054/validatorgo/ismimetype.go (100.0%)</option>
				
				<option value="file66">github.com/bube054/validatorgo/ismobilephone.go (2.1%)</option>
				
				<option value="file67">github.com/bube054/validatorgo/ismongoid.go (100.0%)</option>
				
				<option value="file68">github.com/bube054/validatorgo/ismultibyte.go (100.0%)</option>
				
				<option value="file69">github.com/bube054/validatorgo/isnumeric.go (25.9%)</option>
				
				<option value="file70">github.com/bube054/validatorgo/isoctal.go (100.0%)</option>
				
				<option value="file71">github.com/bube054/validatorgo/ispassport.go (75.0%)</option>
				
				<option value="file72">github.com/bube054/validatorgo/isport.go (100.0%)</option>
				
				<option value="file73">github.com/bube054/validatorgo/ispostalcode.go (90.0%)</option>
				
				<option value="file74">github.com/bube054/validatorgo/isrfc3339.go (100.0%)</option>
				
				<option value="file75">github.com/bube054/validatorgo/isrgbcolor.go (100.0%)</option>
				
				<option value="file76">github.com/bube054/validatorgo/issemver.go (100.0%)</option>
				
				<option value="file77">github.com/bube054/validatorgo/isslug.go (100.0%)</option>
				
				<option value="file78">github.com/bube054/validatorgo/isstrongpassword.go (100.0%)</option>
				
				<option value="file79">github.com/bube054/validatorgo/issurrogatepair.go (100.0%)</option>
				
				<option value="file80">github.com/bube054/validatorgo/istaxid.go (100.0%)</option>
				
				<option value="file81">github.com/bube054/validatorgo/istime.go (90.5%)</option>
				
				<option value="file82">github.com/bube054/validatorgo/isulid.go (100.0%)</option>
				
				<option value="file83">github.com/bube054/validatorgo/isuppercase.go (100.0%)</option>
				
				<option value="file84">github.com/bube054/validatorgo/isurl.go (0.0%)</option>
				
				<option value="file85">github.com/bube054/validatorgo/isuuid.go (100.0%)</option>
				
				<option value="file86">github.com/bube054/validatorgo/isvariablewidth.go (100.0%)</option>
				
				<option value="file87">github.com/bube054/validatorgo/isvat.go (0.0%)</option>
				
				<option value="file88">github.com/bube054/validatorgo/iswhilelisted.go (92.3%)</option>
				
				<option value="file89">github.com/bube054/validatorgo/matches.go (66.7%)</option>
				
				<option value="file90">github.com/bube054/validatorgo/utils.go (81.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// A package for string validators.
package validatorgo

import "strings"

const (
        containsOptsDefaultIgnoreCase bool = false
        containsOptsDefaultMinOccurrences int  = 1
)

// ContainsOpt is used to configure Contains
type ContainsOpt struct {
        IgnoreCase     bool // ignore case when doing comparison, default false.
        MinOccurrences int  // minimum number of occurrences for the seed in the string. Defaults to 1.
}

// A validator that checks if the string contains the seed.
//
// ContainsOpt is a struct that defaults to { IgnoreCase: false, MinOccurrences: 1 }.
//
// ContainsOpt:
//
// IgnoreCase: Ignore case when doing comparison, default false.
//
// MinOccurrences: Minimum number of occurrences for the seed in the string. Defaults to 1.
//
//        ok := validatorgo.Contains("hello world", "world", &amp;ContainsOpt{})
//        fmt.Println(ok) // true
//        ok := validatorgo.Contains("hello world", "earth", &amp;ContainsOpt{})
//        fmt.Println(ok) // false
func Contains(str, seed string, opts *ContainsOpt) bool <span class="cov8" title="1">{
        if opts == nil </span><span class="cov8" title="1">{
                opts = setContainOptsToDefault()
        }</span>

        <span class="cov8" title="1">if opts.IgnoreCase </span><span class="cov8" title="1">{
                strLowerCase, seedLowerCase := strings.ToLower(str), strings.ToLower(seed)
                return strings.Contains(strLowerCase, seedLowerCase) &amp;&amp; strings.Count(strLowerCase, seedLowerCase) &gt;= opts.MinOccurrences
        }</span> else<span class="cov8" title="1"> {
                return strings.Contains(str, seed) &amp;&amp; strings.Count(str, seed) &gt;= opts.MinOccurrences
        }</span>
}

func setContainOptsToDefault() (opts *ContainsOpt) <span class="cov8" title="1">{
        opts = &amp;ContainsOpt{}
        opts.IgnoreCase = containsOptsDefaultIgnoreCase
        opts.MinOccurrences = containsOptsDefaultMinOccurrences

        return
}</pre>
		
		<pre class="file" id="file1" style="display: none">package validatorgo

// A validator that checks if the string matches the comparison.
//
//        ok := govalidator.Equals("Hello", "Hello")
//        fmt.Println(ok) // true
//        ok := govalidator.Equals("Hello", "World")
//        fmt.Println(ok) // false
func Equals(str, comparison string) bool <span class="cov8" title="1">{
        return str == comparison
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package validatorgo

import (
        "regexp"
        "strings"
)

const (
        isAlphaOptsDefaultIgnore string = ""
        isAlphaOptsDefaultLocale string = "en-US"
)

// IsAlphaOpts is used to configure IsAlpha
type IsAlphaOpts struct {
        Ignore string // string to be ignored
        Locale string // a locale
}

// regexEscapes is the set of special regex characters escaped
var regexEscapes = map[string]string{
        ".":  `\.`,
        "*":  `\*`,
        "+":  `\+`,
        "?":  `\?`,
        "^":  `\^`,
        "$":  `\$`,
        "(":  `\(`,
        ")":  `\)`,
        "[":  `\[`,
        "]":  `\]`,
        "{":  `\{`,
        "}":  `\}`,
        "|":  `\|`,
        "\\": `\\`,
        "-":  `\-`,
        "&lt;":  `\&lt;`,
        "&gt;":  `\&gt;`,
        `"`:  `\"`,
        `'`:  `\'`,
}

var (
        // writingSystemAlphaRegex is the set of common writing systems and their validating alphabetical regex
        writingSystemAlphaRegex = map[string]string{
                "arabic":          "^[\u0600-\u06FF\u0750-\u077F]+$",              // Arabic
                "latin":           "^[A-Za-z]+$",                                  // Latin
                "latin_czech":     "^[A-Za-zÁČĎÉĚÍŇÓŘŠŤÚŮÝŽáčďéěíňóřšťúůýž]+$",    // Latin with Czech-specific characters
                "latin_danish":    "^[A-Za-zÆØÅæøå]+$",                            // Latin with Danish-specific characters
                "latin_german":    "^[A-Za-zÄÖÜßäöü]+$",                           // Latin with German-specific characters
                "latin_spanish":   "^[A-Za-zÁÉÍÑÓÚÜáéíñóúü]+$",                    // Latin with Spanish-specific characters
                "latin_french":    "^[A-Za-zÀÂÇÉÈÊËÎÏÔŒÙÛÜŸàâçéèêëîïôœùûüÿ]+$",    // Latin with French-specific characters
                "latin_esperanto": "^[A-Za-zĈĜĤĴŜŬĉĝĥĵŝŭ]+$",                      // Latin with Esperanto-specific characters
                "cyrillic":        "^[А-Яа-яЁё]+$",                                // Cyrillic
                "greek":           "^[Α-Ωα-ω]+$",                                  // Greek
                "armenian":        "^[\u0530-\u058F]+$",                           // Armenian
                "bengali":         "^[\u0980-\u09FF]+$",                           // Bengali
                "tibetan":         "^[\u0F00-\u0FFF]+$",                           // Tibetan
                "myanmar":         "^[\u1000-\u109F]+$",                           // Myanmar
                "chinese":         "^[\u4E00-\u9FFF]+$",                           // Chinese
                "hebrew":          "^[\u0590-\u05FF]+$",                           // Hebrew
                "devanagari":      "^[\u0900-\u097F]+$",                           // Devanagari
                "hangul":          "^[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F]+$", // Hangul
                "japanese":        "^[\u4E00-\u9FFF\u3040-\u309F\u30A0-\u30FF]+$", // Kanji, Hiragana, Katakana
                "thai":            "^[\u0E00-\u0E7F]+$",                           // Thai
                "ukrainian":       "^[А-Яа-яЁёІЇЄҐіїєґ]+$",                        // Cyrillic with Ukrainian-specific characters
        }

        // localeWritingSystems is the set of locales and their writing systems
        localeWritingSystems = map[string]string{
                "ar":          "arabic",
                "ar-AE":       "arabic",
                "ar-BH":       "arabic",
                "ar-DZ":       "arabic",
                "ar-EG":       "arabic",
                "ar-IQ":       "arabic",
                "ar-JO":       "arabic",
                "ar-KW":       "arabic",
                "ar-LB":       "arabic",
                "ar-LY":       "arabic",
                "ar-MA":       "arabic",
                "ar-QA":       "arabic",
                "ar-QM":       "arabic",
                "ar-SA":       "arabic",
                "ar-SD":       "arabic",
                "ar-SY":       "arabic",
                "ar-TN":       "arabic",
                "ar-YE":       "arabic",
                "bg-BG":       "cyrillic",
                "bn":          "bengali",
                "cs-CZ":       "latin_czech",
                "da-DK":       "latin_danish",
                "de-DE":       "latin_german",
                "el-GR":       "greek",
                "en-AU":       "latin",
                "en-GB":       "latin",
                "en-HK":       "latin",
                "en-IN":       "latin",
                "en-NZ":       "latin",
                "en-US":       "latin",
                "en-ZA":       "latin",
                "en-ZM":       "latin",
                "eo":          "latin_esperanto",
                "es-ES":       "latin_spanish",
                "fa-IR":       "arabic",
                "fi-FI":       "latin_finnish",
                "fr-CA":       "latin_french",
                "fr-FR":       "latin_french",
                "he":          "hebrew",
                "hi-IN":       "devanagari",
                "hu-HU":       "latin_hungarian",
                "it-IT":       "latin_italian",
                "kk-KZ":       "cyrillic",
                "ko-KR":       "hangul",
                "ja-JP":       "japanese",
                "ku-IQ":       "arabic",
                "nb-NO":       "latin_norwegian",
                "nl-NL":       "latin_dutch",
                "nn-NO":       "latin_norwegian",
                "pl-PL":       "latin_polish",
                "pt-BR":       "latin_portuguese",
                "pt-PT":       "latin_portuguese",
                "ru-RU":       "cyrillic",
                "si-LK":       "sinhala",
                "sl-SI":       "latin_slovenian",
                "sk-SK":       "latin_slovak",
                "sr-RS":       "cyrillic",
                "sr-RS@latin": "latin_serbian",
                "sv-SE":       "latin_swedish",
                "th-TH":       "thai",
                "tr-TR":       "latin_turkish",
                "uk-UA":       "ukrainian",
        }
)

// escapeRegexChars returns escaped regex special characters
func escapeRegexChars(str string) string <span class="cov8" title="1">{
        var escIgnChars strings.Builder

        for _, char := range str </span><span class="cov8" title="1">{
                charStr := string(char)
                escChar, ok := regexEscapes[charStr]

                if ok </span><span class="cov8" title="1">{
                        escIgnChars.WriteString(escChar)
                }</span> else<span class="cov8" title="1"> {
                        escIgnChars.WriteString(charStr)
                }</span>
        }

        <span class="cov8" title="1">return escIgnChars.String()</span>
}

// A validator that checks if the string contains only letters (a-zA-Z).
//
// IsAlphaOpts is an optional struct that can be supplied with the following key(s):
//
// Ignore: is the string to be ignored e.g. " -" will ignore spaces and -'s.
//
// Locale: one of ('ar', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', 'ar-JO', 'ar-KW', 'ar-LB', 'ar-LY', 'ar-MA', 'ar-QA', 'ar-QM', 'ar-SA', 'ar-SD', 'ar-SY', 'ar-TN', 'ar-YE', 'bg-BG', 'bn', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-AU', 'en-GB', 'en-HK', 'en-IN', 'en-NZ', 'en-US', 'en-ZA', 'en-ZM', 'eo', 'es-ES', 'fa-IR', 'fi-FI', 'fr-CA', 'fr-FR', 'he', 'hi-IN', 'hu-HU', 'it-IT', 'kk-KZ', 'ko-KR', 'ja-JP', 'ku-IQ', 'nb-NO', 'nl-NL', 'nn-NO', 'pl-PL', 'pt-BR', 'pt-PT', 'ru-RU', 'si-LK', 'sl-SI', 'sk-SK', 'sr-RS', 'sr-RS@latin', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA') and defaults to en-US if none is provided.
//
//        isAlpha := govalidator.IsAlpha("hello", &amp;govalidator.IsAlphaOpts{})
//        fmt.Println(isAlpha) // true
//        isAlpha := govalidator.IsAlpha("hello123", &amp;govalidator.IsAlphaOpts{})
//        fmt.Println(isAlpha) // false
func IsAlpha(str string, opts *IsAlphaOpts) bool <span class="cov8" title="1">{
        if opts == nil </span><span class="cov8" title="1">{
                opts = setIsAlphaOptsToDefault()
        }</span>

        <span class="cov8" title="1">var (
                re                *regexp.Regexp
                lenClsCharFromEnd = 3
        )

        if opts.Ignore == "" &amp;&amp; opts.Locale == "" </span><span class="cov8" title="1">{
                re = regexp.MustCompile(`^[a-zA-z]+$`)
        }</span>

        <span class="cov8" title="1">if opts.Ignore == "" &amp;&amp; opts.Locale != "" </span><span class="cov8" title="1">{
                wrtSys, ok := localeWritingSystems[opts.Locale]
                if !ok </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">re = regexp.MustCompile(writingSystemAlphaRegex[wrtSys])</span>
        }

        <span class="cov8" title="1">if opts.Ignore != "" &amp;&amp; opts.Locale == "" </span><span class="cov8" title="1">{
                charsToIgn := escapeRegexChars(opts.Ignore)
                rec := regexp.MustCompile(`^[a-zA-z` + charsToIgn + `]+$`)
                re = rec
        }</span>

        <span class="cov8" title="1">if opts.Ignore != "" &amp;&amp; opts.Locale != "" </span><span class="cov8" title="1">{
                charsToIgn := escapeRegexChars(opts.Ignore)
                wrtSys := localeWritingSystems[opts.Locale]
                wrtSysRe := writingSystemAlphaRegex[wrtSys]
                divLen := len(wrtSysRe) - lenClsCharFromEnd
                fstPrtRe, secPrtRe := wrtSysRe[:divLen], wrtSysRe[divLen:]
                rec := regexp.MustCompile(fstPrtRe + charsToIgn + secPrtRe)
                re = rec
        }</span>

        <span class="cov8" title="1">return re.MatchString(str)</span>
}

func setIsAlphaOptsToDefault() (opts *IsAlphaOpts) <span class="cov8" title="1">{
        opts = &amp;IsAlphaOpts{}
        opts.Ignore = isAlphaOptsDefaultIgnore
        opts.Locale = isAlphaOptsDefaultLocale

        return
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package validatorgo

import (
        "strconv"
        "unicode/utf8"
)

// A validator that checks if the string is an ABA routing number for US bank account / cheque.
//
//        ok := govalidator.IsAbaRouting("123456789")
//        fmt.Println(ok) // false
//        ok := govalidator.IsAbaRouting("021000021")
//        fmt.Println(ok) // true
func IsAbaRouting(str string) bool <span class="cov8" title="1">{
        strWithoutDashes := stripDashesAndSpaces(str)

        if utf8.RuneCountInString(strWithoutDashes) != 9 || !IsNumeric(strWithoutDashes, IsNumericOpts{NoSymbols: true}) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">digits := make([]int, 9)

        for i, char := range strWithoutDashes </span><span class="cov8" title="1">{
                digit, _ := strconv.Atoi(string(char))
                // err is ignore because we are assured IsNumericAbove to block all non numbers
                // if err != nil {
                //         return false
                // }
                digits[i] = digit
        }</span>

        <span class="cov8" title="1">checksum := 3*(digits[0]+digits[3]+digits[6]) + 7*(digits[1]+digits[4]+digits[7]) + 1*(digits[2]+digits[5]+digits[8])

        return checksum%10 == 0</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package validatorgo

import (
        "time"

        "github.com/bube054/validatorgo/sanitizer"
)

const (
        isAfterOptsDefaultComparisonDate string = ""
)

// IsAfterOpts is used to configure IsAfter
type IsAfterOpts struct {
        ComparisonDate string // date to be compared to. Valid layouts are from the time package e.g Layout, ANSIC, UnixDate, RubyDate, RFC822, RFC822Z, RFC850, RFC1123, RFC1123Z, Kitchen, Stamp, StampMilli, StampMicro, StampNano, DateTime, DateOnly, TimeOnly
}

// A validator that checks if the string is a date that is after the specified date.
//
// IsAfterOpts is a struct that defaults to { ComparisonDate: "" }.
//
// IsAfterOpts:
//
// ComparisonDate: defaults to the current time.
//
// string layouts for str and ComparisonDate can be different layout.
//
// these are the only valid layouts from the time package 
// e.g Layout, ANSIC, UnixDate, RubyDate, RFC822, RFC822Z, RFC850, RFC1123, RFC1123Z, Kitchen, Stamp, StampMilli, StampMicro, StampNano, DateTime, DateOnly, TimeOnly.
//
//        ok := validatorgo.IsAfter("2023-09-15", &amp;validatorgo.IsAfterOpts{ComparisonDate: "2023-01-01"})
//        fmt.Println(ok) // true
//        ok = validatorgo.IsAfter("2023-01-01", &amp;validatorgo.IsAfterOpts{ComparisonDate: "2023-09-15"})
//        fmt.Println(ok) // false
func IsAfter(str string, opts *IsAfterOpts) bool <span class="cov8" title="1">{
        if opts == nil </span><span class="cov8" title="1">{
                opts = setIsAfterOptsToDefault()
        }</span>

        <span class="cov8" title="1">date1 := sanitizer.ToDate(str)

        var date2 *time.Time
        if opts.ComparisonDate == "" </span><span class="cov8" title="1">{
                now := time.Now()
                date2 = &amp;now
        }</span> else<span class="cov8" title="1"> {
                date2 = sanitizer.ToDate(opts.ComparisonDate)
        }</span>

        <span class="cov8" title="1">if date1 == nil || date2 == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return date1.After(*date2)</span>
}

func setIsAfterOptsToDefault() (opts *IsAfterOpts) <span class="cov8" title="1">{
        opts = &amp;IsAfterOpts{}
        opts.ComparisonDate = isAfterOptsDefaultComparisonDate

        return
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package validatorgo

import (
        "fmt"
        "regexp"
)

const (
        isAlphanumericOptsDefaultIgnore string = ""
        isAlphanumericOptsDefaultLocale string = "en-US"
)

// IsAlphanumericOpts is used to configure IsAlphanumeric
type IsAlphanumericOpts struct {
        Ignore string // string to be ignored
        Locale string // a locale
}

// writingSystemAlphaNumRegex is the set of common writing systems and their validating alphanumeric regex
var writingSystemAlphaNumRegex = map[string]string{
        "arabic":          "^[A-Za-z0-9\u0600-\u06FF\u0750-\u077F]+$",              // Alphanumeric + Arabic
        "latin":           "^[A-Za-z0-9]+$",                                        // Alphanumeric (Latin)
        "latin_czech":     "^[A-Za-z0-9ÁČĎÉĚÍŇÓŘŠŤÚŮÝŽáčďéěíňóřšťúůýž]+$",          // Alphanumeric + Latin with Czech-specific characters
        "latin_danish":    "^[A-Za-z0-9ÆØÅæøå]+$",                                  // Alphanumeric + Latin with Danish-specific characters
        "latin_german":    "^[A-Za-z0-9ÄÖÜßäöü]+$",                                 // Alphanumeric + Latin with German-specific characters
        "latin_spanish":   "^[A-Za-z0-9ÁÉÍÑÓÚÜáéíñóúü]+$",                          // Alphanumeric + Latin with Spanish-specific characters
        "latin_french":    "^[A-Za-z0-9ÀÂÇÉÈÊËÎÏÔŒÙÛÜŸàâçéèêëîïôœùûüÿ]+$",          // Alphanumeric + Latin with French-specific characters
        "latin_esperanto": "^[A-Za-z0-9ĈĜĤĴŜŬĉĝĥĵŝŭ]+$",                            // Alphanumeric + Latin with Esperanto-specific characters
        "cyrillic":        "^[A-Za-z0-9А-Яа-яЁё]+$",                                // Alphanumeric + Cyrillic
        "greek":           "^[A-Za-z0-9Α-Ωα-ω]+$",                                  // Alphanumeric + Greek
        "armenian":        "^[A-Za-z0-9\u0530-\u058F]+$",                           // Alphanumeric + Armenian
        "bengali":         "^[A-Za-z0-9\u0980-\u09FF]+$",                           // Alphanumeric + Bengali
        "tibetan":         "^[A-Za-z0-9\u0F00-\u0FFF]+$",                           // Alphanumeric + Tibetan
        "myanmar":         "^[A-Za-z0-9\u1000-\u109F]+$",                           // Alphanumeric + Myanmar
        "chinese":         "^[A-Za-z0-9\u4E00-\u9FFF]+$",                           // Alphanumeric + Chinese
        "hebrew":          "^[A-Za-z0-9\u0590-\u05FF]+$",                           // Alphanumeric + Hebrew
        "devanagari":      "^[A-Za-z0-9\u0900-\u097F]+$",                           // Alphanumeric + Devanagari
        "hangul":          "^[A-Za-z0-9\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F]+$", // Alphanumeric + Hangul
        "japanese":        "^[A-Za-z0-9\u4E00-\u9FFF\u3040-\u309F\u30A0-\u30FF]+$", // Alphanumeric + Kanji, Hiragana, Katakana
        "thai":            "^[A-Za-z0-9\u0E00-\u0E7F]+$",                           // Alphanumeric + Thai
        "ukrainian":       "^[A-Za-z0-9А-Яа-яЁёІЇЄҐіїєґ]+$",                        // Alphanumeric + Cyrillic with Ukrainian-specific characters
}

// A validator that checks if the string contains only letters and numbers (a-zA-Z0-9).
//
// IsAlphaOpts is an optional struct that can be supplied with the following key(s):
//
// Ignore: is the string to be ignored e.g. " -" will ignore spaces and -'s.
//
// locale is one of ('ar', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', 'ar-JO', 'ar-KW', 'ar-LB', 'ar-LY', 'ar-MA', 'ar-QA', 'ar-QM', 'ar-SA', 'ar-SD', 'ar-SY', 'ar-TN', 'ar-YE', 'bn', 'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-AU', 'en-GB', 'en-HK', 'en-IN', 'en-NZ', 'en-US', 'en-ZA', 'en-ZM', 'eo', 'es-ES', 'fa-IR', 'fi-FI', 'fr-CA', 'fr-FR', 'he', 'hi-IN', 'hu-HU', 'it-IT', 'kk-KZ', 'ko-KR', 'ja-JP','ku-IQ', 'nb-NO', 'nl-NL', 'nn-NO', 'pl-PL', 'pt-BR', 'pt-PT', 'ru-RU', 'si-LK', 'sl-SI', 'sk-SK', 'sr-RS', 'sr-RS@latin', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA') and defaults to en-US.
//
//        isAlpha := validatorgo.IsAlphanumeric("hello123", &amp;validatorgo.IsAlphanumericOpts{})
//        fmt.Println(isAlpha) // true
//        isAlpha := validatorgo.IsAlphanumeric("hello!", &amp;validatorgo.IsAlphanumericOpts{})
//        fmt.Println(isAlpha) // false
func IsAlphanumeric(str string, opts *IsAlphanumericOpts) bool <span class="cov8" title="1">{
        if opts == nil </span><span class="cov8" title="1">{
                opts = setIsAlphanumericOptsToDefault()
        }</span>

        <span class="cov8" title="1">var (
                re                *regexp.Regexp
                lenClsCharFromEnd = 3
        )

        if opts.Ignore == "" &amp;&amp; opts.Locale == "" </span><span class="cov8" title="1">{
                re = regexp.MustCompile(`^[a-zA-z0-9]+$`)
        }</span>

        <span class="cov8" title="1">if opts.Ignore == "" &amp;&amp; opts.Locale != "" </span><span class="cov8" title="1">{
                wrtSys, ok := localeWritingSystems[opts.Locale]
                if !ok </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">re = regexp.MustCompile(writingSystemAlphaNumRegex[wrtSys])</span>
        }

        <span class="cov8" title="1">if opts.Ignore != "" &amp;&amp; opts.Locale == "" </span><span class="cov8" title="1">{
                charsToIgn := escapeRegexChars(opts.Ignore)
                rec := regexp.MustCompile(`^[a-zA-z0-9` + charsToIgn + `]+$`)
                re = rec
        }</span>

        <span class="cov8" title="1">if opts.Ignore != "" &amp;&amp; opts.Locale != "" </span><span class="cov8" title="1">{
                charsToIgn := escapeRegexChars(opts.Ignore)
                wrtSys := localeWritingSystems[opts.Locale]
                wrtSysRe := writingSystemAlphaNumRegex[wrtSys]
                divLen := len(wrtSysRe) - lenClsCharFromEnd
                fstPrtRe, secPrtRe := wrtSysRe[:divLen], wrtSysRe[divLen:]
                rec := regexp.MustCompile(fstPrtRe + charsToIgn + secPrtRe)
                fmt.Println(rec.String())
                re = rec
        }</span>

        <span class="cov8" title="1">return re.MatchString(str)</span>
}

func setIsAlphanumericOptsToDefault() (opts *IsAlphanumericOpts) <span class="cov8" title="1">{
        opts = &amp;IsAlphanumericOpts{}
        opts.Ignore = isAlphanumericOptsDefaultIgnore
        opts.Locale = isAlphanumericOptsDefaultLocale

        return
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package validatorgo

// A validator that checks if the string contains ASCII chars only.
//
//        ok := validatorgo.IsAscii("Hello")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsAscii("こんにちは")
//        fmt.Println(ok) // false
func IsAscii(str string) bool <span class="cov8" title="1">{
        for _, char := range str </span><span class="cov8" title="1">{
                if !(char &gt;= 0 &amp;&amp; char &lt;= 127) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package validatorgo

import (
        "regexp"
        "strings"
)

const (
        isBase32OptsDefaultCrockford bool = false
)

// IsBase32Opts is used to configure IsBase32
type IsBase32Opts struct {
        Crockford bool // whether to use crockfords base32 alternative encoding scheme

        // ZBase bool // whether to use crockfords base32 alternative encoding scheme
}

// A validator that checks if the string is base32 encoded.
//
// IsBase32Opts defaults to { Crockford: false }.
// When Crockford is true it tests the given base32 encoded string using [crockford's] base32 alternative.
//
//        isAlpha := validatorgo.IsBase32("JBSWY3DPEBLW64TMMQ", &amp;validatorgo.IsBase32Opts{})
//        fmt.Println(isAlpha) // true
//        isAlpha := validatorgo.IsBase32("jbswy3dpeblw64tmmq======", &amp;validatorgo.IsBase32Opts{})
//        fmt.Println(isAlpha) // false
//
// [crockford's]: http://www.crockford.com/base32.html
func IsBase32(str string, opts *IsBase32Opts) bool <span class="cov8" title="1">{
        if opts == nil </span><span class="cov8" title="1">{
                opts = setIsBase32OptsToDefault()
        }</span>

        <span class="cov8" title="1">strWithoutEq := strings.TrimRight(str, "=")
        strWithoutHyp := stripHyphens(strWithoutEq)

        if len(strWithoutHyp) &lt; 2 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if opts.Crockford </span><span class="cov8" title="1">{
                return regexp.MustCompile(`^[A-HJ-KM-NP-TV-Z0-9]+$`).MatchString(strings.ToUpper(strWithoutHyp))
        }</span> else<span class="cov8" title="1"> {
                return regexp.MustCompile(`^[A-Z2-7]+$`).MatchString(strWithoutHyp)
        }</span>
}

func setIsBase32OptsToDefault() (opts *IsBase32Opts) <span class="cov8" title="1">{
        opts = &amp;IsBase32Opts{}
        opts.Crockford = isBase32OptsDefaultCrockford

        return
}</pre>
		
		<pre class="file" id="file8" style="display: none">package validatorgo

import (
        "regexp"
)

// A validator that checks if the string is base58 encoded.
func IsBase58(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile("^[A-HJ-NP-Za-km-z1-9]+$").MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package validatorgo

import (
        "regexp"
        "unicode/utf8"
)

const (
        isBase64OptsDefaultUrlSafe bool = false
)

// IsBase64Opts is used to configure IsBase64
type IsBase64Opts struct {
        UrlSafe bool // checks whether string is url safe.
}

// A validator that checks if the string is base64 encoded.
//
// IsBase64Opts is an optional struct which defaults to { UrlSafe: false }.
// When UrlSafe is true it tests the given base64 encoded string is [url safe].
//
//        ok := validatorgo.IsBase64("SGVsbG8gd29ybGQ", &amp;validatorgo.IsBase64Opts{})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsBase64("SGVsbG8g@d29ybGQ=", &amp;validatorgo.IsBase64Opts{})
//        fmt.Println(ok) // false
//
// [url safe]: https://base64.guru/standards/base64url
func IsBase64(str string, opts *IsBase64Opts) bool <span class="cov8" title="1">{
        if opts == nil </span><span class="cov8" title="1">{
                opts = setIsBase64OptsToDefault()
        }</span>

        <span class="cov8" title="1">if utf8.RuneCountInString(str) &lt; 2 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if opts.UrlSafe </span><span class="cov8" title="1">{
                return regexp.MustCompile(`^(?:[A-Za-z0-9_-]{4})*(?:[A-Za-z0-9_-]{2}(?:==)?|[A-Za-z0-9_-]{3}=?)?$`).MatchString(str)
        }</span> else<span class="cov8" title="1"> {
                return regexp.MustCompile(`^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`).MatchString(str)
        }</span>
}

func setIsBase64OptsToDefault() (opts *IsBase64Opts) <span class="cov8" title="1">{
        opts = &amp;IsBase64Opts{}
        opts.UrlSafe = isBase64OptsDefaultUrlSafe

        return
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package validatorgo

import (
        "time"

        "github.com/bube054/validatorgo/sanitizer"
)

const (
        isBeforeOptsDefaultComparisonDate string = ""
)

// IsBeforeOpts is used to configure IsBefore
type IsBeforeOpts struct {
        ComparisonDate string // date to be compared to. Valid layouts are from the time package e.g Layout, ANSIC, UnixDate, RubyDate, RFC822, RFC822Z, RFC850, RFC1123, RFC1123Z, Kitchen, Stamp, StampMilli, StampMicro, StampNano, DateTime, DateOnly, TimeOnly
}

// A validator that checks if the string is a date that is before the specified date.
//
// IsBeforeOpts is a struct that defaults to { ComparisonDate: "" }.
//
// IsBeforeOpts:
//
// ComparisonDate: defaults to the current time.
// string layouts for str and ComparisonDate can be different layout.
// these are the only valid layouts from the time package e.g Layout, ANSIC, UnixDate, RubyDate, RFC822, RFC822Z, RFC850, RFC1123, RFC1123Z, Kitchen, Stamp, StampMilli, StampMicro, StampNano, DateTime, DateOnly, TimeOnly.
//
//        ok := validatorgo.IsBefore("2023-01-01", &amp;IsBeforeOpts{ComparisonDate: "2023-09-15"})
//        fmt.Println(ok) // true
//        ok = validatorgo.IsBefore("2024-01-01", &amp;IsBeforeOpts{ComparisonDate: "2023-01-01"})
//        fmt.Println(ok) // false
func IsBefore(str string, opts *IsBeforeOpts) bool <span class="cov8" title="1">{
        if opts == nil </span><span class="cov8" title="1">{
                opts = setIsBeforeOptsToDefault()
        }</span>

        <span class="cov8" title="1">date1 := sanitizer.ToDate(str)

        var date2 *time.Time
        if opts.ComparisonDate == "" </span><span class="cov8" title="1">{
                now := time.Now()
                date2 = &amp;now
        }</span> else<span class="cov8" title="1"> {
                date2 = sanitizer.ToDate(opts.ComparisonDate)
        }</span>

        <span class="cov8" title="1">if date1 == nil || date2 == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return date1.Before(*date2)</span>
}

func setIsBeforeOptsToDefault() (opts *IsBeforeOpts) <span class="cov8" title="1">{
        opts = &amp;IsBeforeOpts{}
        opts.ComparisonDate = isBeforeOptsDefaultComparisonDate

        return
}</pre>
		
		<pre class="file" id="file11" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string is a BIC (Bank Identification Code) or SWIFT code.
//
//        ok := validatorgo.IsBic("DEUTDEFF")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsBic("ABCDUS12XXXX")
//        fmt.Println(ok) // false
func IsBic(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile(`^[A-Za-z]{4}(AF|af|AX|ax|AL|al|DZ|dz|AS|as|AD|ad|AO|ao|AI|ai|AQ|aq|AG|ag|AR|ar|AM|am|AW|aw|AU|au|AT|at|AZ|az|BS|bs|BH|bh|BD|bd|BB|bb|BY|by|BE|be|BZ|bz|BJ|bj|BM|bm|BT|bt|BO|bo|BQ|bq|BA|ba|BW|bw|BV|bv|BR|br|IO|io|BN|bn|BG|bg|BF|bf|BI|bi|CV|cv|KH|kh|CM|cm|CA|ca|KY|ky|CF|cf|TD|td|CL|cl|CN|cn|CX|cx|CC|cc|CO|co|KM|km|CG|cg|CD|cd|CK|ck|CR|cr|CI|ci|HR|hr|CU|cu|CW|cw|CY|cy|CZ|cz|DK|dk|DJ|dj|DM|dm|DO|do|EC|ec|EG|eg|SV|sv|GQ|gq|ER|er|EE|ee|SZ|sz|ET|et|FK|fk|FO|fo|FJ|fj|FI|fi|FR|fr|GF|gf|PF|pf|TF|tf|GA|ga|GM|gm|GE|ge|DE|de|GH|gh|GI|gi|GR|gr|GL|gl|GD|gd|GP|gp|GU|gu|GT|gt|GG|gg|GN|gn|GW|gw|GY|gy|HT|ht|HM|hm|VA|va|HN|hn|HK|hk|HU|hu|IS|is|IN|in|ID|id|IR|ir|IQ|iq|IE|ie|IM|im|IL|il|IT|it|JM|jm|JP|jp|JE|je|JO|jo|KZ|kz|KE|ke|KI|ki|KP|kp|KR|kr|KW|kw|KG|kg|LA|la|LV|lv|LB|lb|LS|ls|LR|lr|LY|ly|LI|li|LT|lt|LU|lu|MO|mo|MG|mg|MW|mw|MY|my|MV|mv|ML|ml|MT|mt|MH|mh|MQ|mq|MR|mr|MU|mu|YT|yt|MX|mx|FM|fm|MD|md|MC|mc|MN|mn|ME|me|MS|ms|MA|ma|MZ|mz|MM|mm|NA|na|NR|nr|NP|np|NL|nl|NC|nc|NZ|nz|NI|ni|NE|ne|NG|ng|NU|nu|NF|nf|MK|mk|MP|mp|NO|no|OM|om|PK|pk|PW|pw|PS|ps|PA|pa|PG|pg|PY|py|PE|pe|PH|ph|PN|pn|PL|pl|PT|pt|PR|pr|QA|qa|RE|re|RO|ro|RU|ru|RW|rw|BL|bl|SH|sh|KN|kn|LC|lc|MF|mf|PM|pm|VC|vc|WS|ws|SM|sm|ST|st|SA|sa|SN|sn|RS|rs|SC|sc|SL|sl|SG|sg|SX|sx|SK|sk|SI|si|SB|sb|SO|so|ZA|za|GS|gs|SS|ss|ES|es|LK|lk|SD|sd|SR|sr|SJ|sj|SE|se|CH|ch|SY|sy|TW|tw|TJ|tj|TZ|tz|TH|th|TL|tl|TG|tg|TK|tk|TO|to|TT|tt|TN|tn|TR|tr|TM|tm|TC|tc|TV|tv|UG|ug|UA|ua|AE|ae|GB|gb|US|us|UM|um|UY|uy|UZ|uz|VU|vu|VE|ve|VN|vn|VG|vg|VI|vi|WF|wf|EH|eh|YE|ye|ZM|zm|ZW|zw)[0-9A-Za-z]{2}([A-Za-z0-9]{3})?$`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package validatorgo

import "regexp"

const (
        isBooleanOptsDefaultLoose bool = false
)

// IsBooleanOpts is used to configure IsBoolean
type IsBooleanOpts struct {
        Loose bool // strictness of the equality
}

// A validator that check if the string is a boolean.
//
// IsBooleanOpts is a struct which defaults to { Loose: false } and that can be supplied with the following key(s):
//
// Loose: If Loose is set to false, the validator will strictly match ['true', 'false', '0', '1'].
// If Loose is set to true, the validator will also match 'yes', 'no', and will match a valid boolean string of any case. (e.g.: ['true', 'True', 'TRUE', "false", "False", "FALSE"]).
//
//        ok := validatorgo.IsBoolean("true", &amp;validatorgo.IsBooleanOpts{Loose: false})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsBoolean("bool", &amp;validatorgo.IsBooleanOpts{Loose: false})
//        fmt.Println(ok) // false
func IsBoolean(str string, opts *IsBooleanOpts) bool <span class="cov8" title="1">{
        if opts == nil </span><span class="cov8" title="1">{
                opts = setIsBooleanOptsToDefault()
        }</span>

        <span class="cov8" title="1">if opts.Loose </span><span class="cov8" title="1">{
                return regexp.MustCompile("^(true|True|TRUE|false|False|FALSE|yes|no|0|1)$").MatchString(str)
        }</span> else<span class="cov8" title="1"> {
                return regexp.MustCompile("^(true|false|0|1)$").MatchString(str)
        }</span>
}

func setIsBooleanOptsToDefault() (opts *IsBooleanOpts) <span class="cov8" title="1">{
        opts = &amp;IsBooleanOpts{}
        opts.Loose = isBooleanOptsDefaultLoose

        return
}</pre>
		
		<pre class="file" id="file13" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string is a valid BTC address.
//
//        ok := validatorgo.IsBTCAddress("1RAHUEYstWetqabcFn5Au4m4GFg7xJaNVN2")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsBTCAddress("0J98t1RHT73CNmQwertyyWrnqRhWNLy")
//        fmt.Println(ok) // false
func IsBTCAddress(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile("^(bc1|[13])[a-km-zA-HJ-NP-Z1-9]{25,34}$").MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package validatorgo

const (
        isIsByteLengthOptsDefaultMin uint = 0
)

var(
        isIsByteLengthOptsDefaultMax *uint = nil
)

// IsByteLengthOpts is used to configure IsByteLength
type IsByteLengthOpts struct {
        Min uint  // minimum byte length
        Max *uint // maximum byte length
}

// A validator that checks if the string's length (in UTF-8 bytes) falls in a range.
//
// IsByteLengthOpts is a struct which defaults to { Min: 0, Max: nil }.
//
//        ok := validatorgo.IsByteLength("We♥Go", &amp;IsByteLengthOpts{Min: 5})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsByteLength("We♥Go", &amp;IsByteLengthOpts{Min: 8})
//        fmt.Println(ok) // false
func IsByteLength(str string, opts *IsByteLengthOpts) bool <span class="cov8" title="1">{
        if opts == nil </span><span class="cov8" title="1">{
                opts = setIsByteLengthOptsToDefault()
        }</span>

        <span class="cov8" title="1">lenInBytes := len(str)
        if opts.Max == nil </span><span class="cov8" title="1">{
                return lenInBytes &gt;= int(opts.Min)
        }</span> else<span class="cov8" title="1"> {
                return lenInBytes &gt;= int(opts.Min) &amp;&amp; lenInBytes &lt;= int(*opts.Max)
        }</span>
}

func setIsByteLengthOptsToDefault() (opts *IsByteLengthOpts) <span class="cov8" title="1">{
        opts = &amp;IsByteLengthOpts{}
        opts.Min = isIsByteLengthOptsDefaultMin
        opts.Max = isIsByteLengthOptsDefaultMax

        return
}</pre>
		
		<pre class="file" id="file15" style="display: none">package validatorgo

var AllCountryCodes = [...]string{"AF", "AL", "DZ", "AS", "AD", "AO", "AI", "AQ", "AG", "AR", "AM", "AW", "AU", "AT", "AZ", "BS", "BH", "BD", "BB", "BY", "BE", "BZ", "BJ", "BM", "BT", "BO", "BA", "BW", "BV", "BR", "IO", "BN", "BG", "BF", "BI", "KH", "CM", "CA", "CV", "KY", "CF", "TD", "CL", "CN", "CX", "CC", "CO", "KM", "CG", "CD", "CK", "CR", "CI", "HR", "CU", "CY", "CZ", "DK", "DJ", "DM", "DO", "EC", "EG", "SV", "GQ", "ER", "EE", "ET", "FK", "FO", "FJ", "FI", "FR", "GF", "PF", "TF", "GA", "GM", "GE", "DE", "GH", "GI", "GR", "GL", "GD", "GP", "GU", "GT", "GN", "GW", "GY", "HT", "HM", "HN", "HK", "HU", "IS", "IN", "ID", "IR", "IQ", "IE", "IL", "IT", "JM", "JP", "JO", "KZ", "KE", "KI", "KP", "KR", "KW", "KG", "LA", "LV", "LB", "LS", "LR", "LY", "LI", "LT", "LU", "MO", "MG", "MW", "MY", "MV", "ML", "MT", "MH", "MQ", "MR", "MU", "YT", "MX", "FM", "MD", "MC", "MN", "MS", "MA", "MZ", "MM", "NA", "NR", "NP", "NL", "AN", "NC", "NZ", "NI", "NE", "NG", "NU", "NF", "MP", "NO", "OM", "PK", "PW", "PA", "PG", "PY", "PE", "PH", "PN", "PL", "PT", "PR", "QA", "RE", "RO", "RU", "RW", "SH", "KN", "LC", "PM", "VC", "WS", "SM", "ST", "SA", "SN", "CS", "SC", "SL", "SG", "SK", "SI", "SB", "SO", "ZA", "GS", "ES", "LK", "SD", "SR", "SJ", "SZ", "SE", "CH", "SY", "TW", "TJ", "TZ", "TH", "TL", "TG", "TK", "TO", "TT", "TN", "TR", "TM", "TC", "TV", "UG", "UA", "AE", "GB", "US", "UM", "UY", "UZ", "VU", "VA", "VE", "VN", "VG", "VI", "WF", "EH", "YE", "ZM", "ZW"}

// A validator that checks if the string is a country code.
func IsCountryCode(str string) bool <span class="cov8" title="1">{
        return IsIn(str, AllCountryCodes[:])

}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package validatorgo

import "regexp"

const (
        isCreditCardOptsDefaultProvider string = ""
)

// IsCreditCardOpts is used to configure IsCreditCard
type IsCreditCardOpts struct {
        Provider string // credit card issuer
}

var creditCardProviderRegex = map[string]string{
        "amex":           "^3[47][0-9]{13}$",
        "bcglobal":       "^(6541|6556)[0-9]{12}$",
        "carteblanche":   "^389[0-9]{11}$",
        "dinersclub":     "^3(?:0[0-5]|[68][0-9])[0-9]{11}$",
        "discover":       "^65[4-9][0-9]{13}|64[4-9][0-9]{13}|6011[0-9]{12}|(622(?:12[6-9]|1[3-9][0-9]|[2-8][0-9][0-9]|9[01][0-9]|92[0-5])[0-9]{10})$",
        "instapayment":   "^63[7-9][0-9]{13}$",
        "jcb":            "^(?:2131|1800|35\\d{3})\\d{11}$",
        "koreanlocal":    "^9[0-9]{15}$",
        "laser":          "^(6304|6706|6709|6771)[0-9]{12,15}$",
        "maestro":        "^(5018|5020|5038|6304|6759|6761|6763)[0-9]{8,15}$",
        "mastercard":     "^(5[1-5][0-9]{14}|2(22[1-9][0-9]{12}|2[3-9][0-9]{13}|[3-6][0-9]{14}|7[0-1][0-9]{13}|720[0-9]{12}))$",
        "solo":           "^(6334|6767)[0-9]{12}|(6334|6767)[0-9]{14}|(6334|6767)[0-9]{15}$",
        "switch":         "^(4903|4905|4911|4936|6333|6759)[0-9]{12}|(4903|4905|4911|4936|6333|6759)[0-9]{14}|(4903|4905|4911|4936|6333|6759)[0-9]{15}|564182[0-9]{10}|564182[0-9]{12}|564182[0-9]{13}|633110[0-9]{10}|633110[0-9]{12}|633110[0-9]{13}$",
        "unionpay":       "^(62[0-9]{14,17})$",
        "visa":           "^4[0-9]{12}(?:[0-9]{3})?$",
        "visamastercard": "^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14})$",
}

// A validator that checks if the string is a credit card number.
// 
// IsCreditCardOpts is an struct that can be supplied with the following key(s): 
//
// Provider: is a key whose value should be a string, and defines the company issuing the credit card.
// Valid values include amex, bcglobal, carteblanche, dinersclub, discover, instapayment, jcb, koreanlocal, laser, maestro, mastercard, solo, switch, unionpay, visa, visamastercard or blank will check for any provider.
//
//        ok := validatorgo.IsCreditCard("378282246310005", &amp;validatorgo.IsCreditCardOpts{Provider: "amex"})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsCreditCard("37828224631000", &amp;validatorgo.IsCreditCardOpts{Provider: "amex"})
//        fmt.Println(ok) // false
func IsCreditCard(str string, opts *IsCreditCardOpts) bool <span class="cov8" title="1">{
        if opts == nil </span><span class="cov8" title="1">{
                opts =  setIsCreditCardOptsToDefault()
        }</span>

        <span class="cov8" title="1">reStr, ok := creditCardProviderRegex[opts.Provider]

        if !ok </span><span class="cov8" title="1">{
                if opts.Provider != "" </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">for _, val := range creditCardProviderRegex </span><span class="cov8" title="1">{
                        if isVal := regexp.MustCompile(val).MatchString(str); isVal </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                return regexp.MustCompile(reStr).MatchString(str)
        }</span>

        <span class="cov8" title="1">return false</span>
}

func setIsCreditCardOptsToDefault() (opts *IsCreditCardOpts) <span class="cov8" title="1">{
        opts = &amp;IsCreditCardOpts{}
        opts.Provider = isCreditCardOptsDefaultProvider

        return
}</pre>
		
		<pre class="file" id="file17" style="display: none">package validatorgo

import (
        "fmt"
        "regexp"
        "strconv"
)

type IsCurrencyOpts struct {
        // deals with the options for currency
        Symbol                string // '$10.50'
        RequireSymbol         bool   // $10.50
        AllowSpaceAfterSymbol bool   // $ 10.50
        SymbolAfterDigits     bool   // 10.50$

        // deals with the numeric signs
        AllowNegatives               bool // -$10.50
        ParensForNegatives           bool // ($10.50)
        NegativeSignBeforeDigits     bool // $-10.50
        NegativeSignAfterDigits      bool // $10.50-
        AllowNegativeSignPlaceholder bool // $ 10.50

        // deals with the decimals/separator
        ThousandSeparator     string // 10,000.50
        DecimalSeparator      string // 10.50
        AllowDecimal          bool   // $10.00
        RequireDecimal        bool   // $10.00
        DigitsAfterDecimal    []int  // $10.50 []
        AllowSpaceAfterDigits bool   // '$ 10.50
}

func getMaxDigits(digits []int) string <span class="cov0" title="0">{
        if len(digits) == 0 </span><span class="cov0" title="0">{
                return "2"
        }</span>
        <span class="cov0" title="0">return strconv.Itoa(digits[len(digits)-1])</span>
}

func getMinDigits(digits []int) string <span class="cov0" title="0">{
        if len(digits) == 0 </span><span class="cov0" title="0">{
                return "0"
        }</span>
        <span class="cov0" title="0">return strconv.Itoa(digits[0])</span>
}

// A validator that checks if the string is a valid currency amount.
//
// IsCurrencyOpts is a struct which defaults to { Symbol: '$', RequireSymbol: false, AllowSpaceAfterSymbol: false, SymbolAfterDigits: false, AllowNegatives: true, ParensForNegatives: false, NegativeSignBeforeDigits: false, NegativeSignAfterDigits: false, AllowNegativeSignPlaceholder: false, ThousandsSeparator: ',', DecimalSeparator: '.', AllowDecimal: true, RequireDecimal: false, DigitsAfterDecimal: [2], AllowSpaceAfterDigits: false }.
// Note: The slice DigitsAfterDecimal is filled with the exact number of digits allowed not a range, for example a range 1 to 3 will be given as [1, 2, 3].
//
//        ok := validatorgo.IsCurrency("£10.50", validatorgo.IsCurrencyOpts{Symbol: "£"})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsCurrency("£10.50", validatorgo.IsCurrencyOpts{Symbol: "$"})
//        fmt.Println(ok) // false
func IsCurrency(str string, opts IsCurrencyOpts) bool <span class="cov8" title="1">{
        escOpsSym := regexp.QuoteMeta(opts.Symbol)

        var reqSymReStr = "?"

        if opts.RequireSymbol </span><span class="cov8" title="1">{
                reqSymReStr = ""
        }</span>

        <span class="cov8" title="1">alwSpcAftSymStr := ""

        if opts.AllowSpaceAfterSymbol </span><span class="cov8" title="1">{
                alwSpcAftSymStr = " ?"
        }</span>

        <span class="cov8" title="1">re, err := regexp.Compile(fmt.Sprintf(`^(\(?)([+-]?(%s%s)%s[\d\,\.]*)(\)?)$`, escOpsSym, reqSymReStr, alwSpcAftSymStr))

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("re did not compile for reSym", err)
                return false
        }</span>

        <span class="cov8" title="1">capGrp := re.FindStringSubmatch(str)

        if len(capGrp) == 0 </span><span class="cov8" title="1">{
                fmt.Println("re did not match for reSym", re.String())
                return false
        }</span>

        // // check whether bracket match
        // lb, rb := capGrp[1], capGrp[4]
        // if lb != "" || rb != "" {
        //         corBra := lb == "(" &amp;&amp; rb == ")"
                
        //         if !corBra {
        //                 fmt.Println("improper bracket format")
        //                 return false
        //         }
        // }

        // // check whether symbols match
        // strSym := capGrp[3]
        // if strSym != opts.Symbol {
        //         fmt.Println("symbols do not match")
        //         return false
        // }

        // fmt.Println(1, capGrp[0])
        // fmt.Println(2, capGrp[1])
        // fmt.Println(3, capGrp[2])
        // fmt.Println(4, capGrp[3])
        // fmt.Println(5, capGrp[4])
        // fmt.Println(reSymCap, len(reSymCap))

        // if !reSym.MatchString(str) {
        //         fmt.Println("re did not match for reSym", reSym.String())
        //         return false
        // }

        <span class="cov8" title="1">fmt.Println(re.String())
        // fmt.Println(reSym.Find)
        return true</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package validatorgo

import (
        "regexp"
)

// A validator that checks if the string is a data uri format.
//
//        ok := validatorgo.IsDataURI("data:,Hello%2C%20World%21")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsDataURI("text/plain;base64,SGVsbG8sIFdvcmxkIQ==")
//        fmt.Println(ok) // false
func IsDataURI(str string) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(`^data:([-\w]+\/[-+\w.]+)?((?:;?[\w]+=[-\w]+)*)(;base64)?,(.*)$`)

        capGrp := re.FindStringSubmatch(str)

        if len(capGrp) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">mimeTyp := capGrp[1]
        basePrt := capGrp[4]

        return IsBase64(basePrt, &amp;IsBase64Opts{UrlSafe: true}) &amp;&amp; IsMimeType(mimeTyp)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package validatorgo

import (
        "regexp"
)

// IsDateOpts is used to configure IsDate
type IsDateOpts struct {
        Format     string
        StrictMode bool
}

// IsDate formats
const (
        ISO8601       = "2006-01-02"              // YYYY-MM-DD
        USFormat      = "01/02/2006"              // MM/DD/YYYY
        EUFormat      = "02/01/2006"              // DD/MM/YYYY
        JapanFormat   = "2006年01月02日"             // YYYY年MM月DD日
        LongForm      = "January 02, 2006"        // Month DD, YYYY
        ShortForm     = "02-Jan-2006"             // DD-MMM-YYYY
        NoDelim       = "20060102"                // YYYYMMDD
        WeekDay       = "Monday, 02 January 2006" // Day, DD Month YYYY
        YearMonth     = "2006-01"                 // YYYY-MM
        UnixTimestamp = "2006-01-02 15:04:05"     // Full date and time
)

// dateFormatRegex is the set of date formats and their validating regex
var dateFormatRegex = map[string]*regexp.Regexp{
        ISO8601:       regexp.MustCompile(`^\d{4}-\d{2}-\d{2}$`),                   // YYYY-MM-DD
        USFormat:      regexp.MustCompile(`^\d{2}/\d{2}/\d{4}$`),                   // MM/DD/YYYY
        EUFormat:      regexp.MustCompile(`^\d{2}/\d{2}/\d{4}$`),                   // DD/MM/YYYY
        JapanFormat:   regexp.MustCompile(`^\d{4}年\d{2}月\d{2}日$`),                  // YYYY年MM月DD日
        LongForm:      regexp.MustCompile(`^[A-Za-z]+ \d{2}, \d{4}$`),              // Month DD, YYYY
        ShortForm:     regexp.MustCompile(`^\d{2}-[A-Za-z]{3}-\d{4}$`),             // DD-MMM-YYYY
        NoDelim:       regexp.MustCompile(`^\d{8}$`),                               // YYYYMMDD
        WeekDay:       regexp.MustCompile(`^[A-Za-z]+, \d{2} [A-Za-z]+ \d{4}$`),    // Day, DD Month YYYY
        YearMonth:     regexp.MustCompile(`^\d{4}-\d{2}$`),                         // YYYY-MM
        UnixTimestamp: regexp.MustCompile(`^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$`), // Full date and time
}

func dateMatchesAnyFormat(str string) bool <span class="cov8" title="1">{
        for _, format := range dateFormatRegex </span><span class="cov8" title="1">{
                matches := format.MatchString(str)
                if matches </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// A Validator that checks if the string is a valid date. e.g. 2002-07-15.
//
// IsDateOpts is a struct which can contain the keys Format, StrictMode.
//
// Format: is a string and defaults to validatorgo.ISO8601 if "any" or no value is provided.
//
// StrictMode: is a boolean and defaults to false. If StrictMode is set to true, the validator will reject strings different from Format.
//
//        ok := validatorgo.IsDate("2006-01-02", validatorgo.IsDateOpts{})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsDate("01/023/2006", validatorgo.IsDateOpts{})
//        fmt.Println(ok) // false
func IsDate(str string, opts IsDateOpts) bool <span class="cov8" title="1">{
        switch opts.Format </span>{
        case ISO8601, USFormat, EUFormat, JapanFormat, LongForm, ShortForm, NoDelim, WeekDay, YearMonth, UnixTimestamp:<span class="cov8" title="1"></span>
        case "", "any":<span class="cov8" title="1">
                opts.Format = ISO8601</span>
        default:<span class="cov0" title="0">
                return false</span>
        }

        <span class="cov8" title="1">if opts.StrictMode </span><span class="cov8" title="1">{
                return dateFormatRegex[opts.Format].MatchString(str)
        }</span> else<span class="cov8" title="1"> {
                return dateMatchesAnyFormat(str)
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package validatorgo

import (
        "fmt"
        "regexp"
        "strconv"
)

// DecimalDigits is used to configure IsDecimalOpts
type DecimalDigits struct {
        Min uint  // minimum allowed decimal range
        Max *uint // maximum allowed decimal range
}

// IsDecimalOpts is used to configure IsDecimal
type IsDecimalOpts struct {
        DecimalDigits

        ForceDecimal bool   // decimal/radix point must be present
        Locale       string // locale used
}

// decimalFormats is the set of decimal formats and their validating functions
var decimalFormats = map[string]func(IsDecimalOpts) (*regexp.Regexp, error){
        "dot_decimal_comma_thousands": func(ido IsDecimalOpts) (*regexp.Regexp, error) <span class="cov8" title="1">{ // 1,234.56
                var q = "?"
                if ido.ForceDecimal </span><span class="cov8" title="1">{
                        q = ""
                }</span>
                <span class="cov8" title="1">var maxStr string
                if ido.DecimalDigits.Max == nil </span><span class="cov8" title="1">{
                        maxStr = ""
                }</span> else<span class="cov8" title="1"> {
                        maxStr = strconv.Itoa(int(*ido.DecimalDigits.Max))
                }</span>
                <span class="cov8" title="1">return regexp.Compile(fmt.Sprintf(`^[+-]?(\d{1,3}(,\d{3})*)(\.\d{%d,%s})%s$`, ido.DecimalDigits.Min, maxStr, q))</span>
        },
        "comma_decimal_dot_thousands": func(ido IsDecimalOpts) (*regexp.Regexp, error) <span class="cov8" title="1">{ // 1.234,56
                var q = "?"
                if ido.ForceDecimal </span><span class="cov8" title="1">{
                        q = ""
                }</span>
                <span class="cov8" title="1">var maxStr string
                if ido.DecimalDigits.Max == nil </span><span class="cov8" title="1">{
                        maxStr = ""
                }</span> else<span class="cov0" title="0"> {
                        maxStr = strconv.Itoa(int(*ido.DecimalDigits.Max))
                }</span>
                <span class="cov8" title="1">return regexp.Compile(fmt.Sprintf(`^[+-]?(\d{1,3}(\.\d{3})*)(\,\d{%d,%s})%s$`, ido.DecimalDigits.Min, maxStr, q))</span>
        },
        "comma_decimal_space_thousands": func(ido IsDecimalOpts) (*regexp.Regexp, error) <span class="cov8" title="1">{ // 1 234,56
                var q = "?"
                if ido.ForceDecimal </span><span class="cov8" title="1">{
                        q = ""
                }</span>
                <span class="cov8" title="1">var maxStr string
                if ido.DecimalDigits.Max == nil </span><span class="cov8" title="1">{
                        maxStr = ""
                }</span> else<span class="cov0" title="0"> {
                        maxStr = strconv.Itoa(int(*ido.DecimalDigits.Max))
                }</span>
                <span class="cov8" title="1">return regexp.Compile(fmt.Sprintf(`^[+-]?(\d{1,3}( \d{3})*)(\,\d{%d,%s})%s$`, ido.DecimalDigits.Min, maxStr, q))</span>
        },
        "dot_decimal_space_thousands": func(ido IsDecimalOpts) (*regexp.Regexp, error) <span class="cov0" title="0">{ // 1 234.56
                var q = "?"
                if ido.ForceDecimal </span><span class="cov0" title="0">{
                        q = ""
                }</span>
                <span class="cov0" title="0">var maxStr string
                if ido.DecimalDigits.Max == nil </span><span class="cov0" title="0">{
                        maxStr = ""
                }</span> else<span class="cov0" title="0"> {
                        maxStr = strconv.Itoa(int(*ido.DecimalDigits.Max))
                }</span>
                <span class="cov0" title="0">return regexp.Compile(fmt.Sprintf(`^[+-]?(\d{1,3}( \d{3})*)(\.\d{%d,%s})%s$`, ido.DecimalDigits.Min, maxStr, q))</span>
        },
        "dot_decimal_apostrophe_thousands": func(ido IsDecimalOpts) (*regexp.Regexp, error) <span class="cov0" title="0">{ // 1'234.56
                var q = "?"
                if ido.ForceDecimal </span><span class="cov0" title="0">{
                        q = ""
                }</span>
                <span class="cov0" title="0">var maxStr string
                if ido.DecimalDigits.Max == nil </span><span class="cov0" title="0">{
                        maxStr = ""
                }</span> else<span class="cov0" title="0"> {
                        maxStr = strconv.Itoa(int(*ido.DecimalDigits.Max))
                }</span>
                <span class="cov0" title="0">return regexp.Compile(fmt.Sprintf(`^[+-]?(\d{1,3}('\d{3})*)(\.\d{%d,%s})%s$`, ido.DecimalDigits.Min, maxStr, q))</span>
        },
        "comma_decimal_apostrophe_thousands": func(ido IsDecimalOpts) (*regexp.Regexp, error) <span class="cov0" title="0">{ // 1'234,56
                var q = "?"
                if ido.ForceDecimal </span><span class="cov0" title="0">{
                        q = ""
                }</span>
                <span class="cov0" title="0">var maxStr string
                if ido.DecimalDigits.Max == nil </span><span class="cov0" title="0">{
                        maxStr = ""
                }</span> else<span class="cov0" title="0"> {
                        maxStr = strconv.Itoa(int(*ido.DecimalDigits.Max))
                }</span>
                <span class="cov0" title="0">return regexp.Compile(fmt.Sprintf(`^[+-]?(\d{1,3}('\d{3})*)(\,\d{%d,%s})%s$`, ido.DecimalDigits.Min, maxStr, q))</span>
        },
        "dot_decimal_no_thousands": func(ido IsDecimalOpts) (*regexp.Regexp, error) <span class="cov0" title="0">{ // 123456.78
                var q = "?"
                if ido.ForceDecimal </span><span class="cov0" title="0">{
                        q = ""
                }</span>
                <span class="cov0" title="0">var maxStr string
                if ido.DecimalDigits.Max == nil </span><span class="cov0" title="0">{
                        maxStr = ""
                }</span> else<span class="cov0" title="0"> {
                        maxStr = strconv.Itoa(int(*ido.DecimalDigits.Max))
                }</span>
                <span class="cov0" title="0">return regexp.Compile(fmt.Sprintf(`^[+-]?(\d+)?(\.\d{%d,%s})%s$`, ido.DecimalDigits.Min, maxStr, q))</span>
        },
        "comma_decimal_no_thousands": func(ido IsDecimalOpts) (*regexp.Regexp, error) <span class="cov0" title="0">{ // 123456,78
                var q = "?"
                if ido.ForceDecimal </span><span class="cov0" title="0">{
                        q = ""
                }</span>
                <span class="cov0" title="0">var maxStr string
                if ido.DecimalDigits.Max == nil </span><span class="cov0" title="0">{
                        maxStr = ""
                }</span> else<span class="cov0" title="0"> {
                        maxStr = strconv.Itoa(int(*ido.DecimalDigits.Max))
                }</span>
                <span class="cov0" title="0">return regexp.Compile(fmt.Sprintf(`^[+-]?(\d+)?(\,\d{%d,%s})%s$`, ido.DecimalDigits.Min, maxStr, q))</span>
        },
        "indian_numbering_system": func(ido IsDecimalOpts) (*regexp.Regexp, error) <span class="cov0" title="0">{ // 1,23,456.78
                var q = "?"
                if ido.ForceDecimal </span><span class="cov0" title="0">{
                        q = ""
                }</span>
                <span class="cov0" title="0">var maxStr string
                if ido.DecimalDigits.Max == nil </span><span class="cov0" title="0">{
                        maxStr = ""
                }</span> else<span class="cov0" title="0"> {
                        maxStr = strconv.Itoa(int(*ido.DecimalDigits.Max))
                }</span>
                <span class="cov0" title="0">return regexp.Compile(fmt.Sprintf(`^[+-]?(\d{1,2}(,\d{2})*(,\d{3}))?(\.\d{%d,%s})%s$`, ido.DecimalDigits.Min, maxStr, q))</span>
        },
        "arabic_numerals_dot_decimal": func(ido IsDecimalOpts) (*regexp.Regexp, error) <span class="cov0" title="0">{ // ١٫٢٣٤,٥٦
                var q = "?"
                if ido.ForceDecimal </span><span class="cov0" title="0">{
                        q = ""
                }</span>
                <span class="cov0" title="0">var maxStr string
                if ido.DecimalDigits.Max == nil </span><span class="cov0" title="0">{
                        maxStr = ""
                }</span> else<span class="cov0" title="0"> {
                        maxStr = strconv.Itoa(int(*ido.DecimalDigits.Max))
                }</span>
                <span class="cov0" title="0">return regexp.Compile(fmt.Sprintf(`^[+-]?[٠١٢٣٤٥٦٧٨٩]+(\٫[٠١٢٣٤٥٦٧٨٩]{%d,%s})%s$`, ido.DecimalDigits.Min, maxStr, q))</span>
        },
        "arabic_numerals_comma_decimal": func(ido IsDecimalOpts) (*regexp.Regexp, error) <span class="cov0" title="0">{ // ١٬٢٣٤٫٥٦
                var q = "?"
                if ido.ForceDecimal </span><span class="cov0" title="0">{
                        q = ""
                }</span>
                <span class="cov0" title="0">var maxStr string
                if ido.DecimalDigits.Max == nil </span><span class="cov0" title="0">{
                        maxStr = ""
                }</span> else<span class="cov0" title="0"> {
                        maxStr = strconv.Itoa(int(*ido.DecimalDigits.Max))
                }</span>
                <span class="cov0" title="0">return regexp.Compile(fmt.Sprintf(`^[+-]?[٠١٢٣٤٥٦٧٨٩]+(\٬[٠١٢٣٤٥٦٧٨٩]{%d,%s})%s$`, ido.DecimalDigits.Min, maxStr, q))</span>
        },
}

// localeDecimalFormats is the set of Locales and their decimal formats
var localeDecimalFormats = map[string]string{
        "ar":          "arabic_numerals_dot_decimal",
        "ar-AE":       "arabic_numerals_dot_decimal",
        "ar-BH":       "arabic_numerals_dot_decimal",
        "ar-DZ":       "arabic_numerals_dot_decimal",
        "ar-EG":       "arabic_numerals_dot_decimal",
        "ar-IQ":       "arabic_numerals_dot_decimal",
        "ar-JO":       "arabic_numerals_dot_decimal",
        "ar-KW":       "arabic_numerals_dot_decimal",
        "ar-LB":       "arabic_numerals_dot_decimal",
        "ar-LY":       "arabic_numerals_dot_decimal",
        "ar-MA":       "arabic_numerals_dot_decimal",
        "ar-QA":       "arabic_numerals_dot_decimal",
        "ar-QM":       "arabic_numerals_dot_decimal",
        "ar-SA":       "arabic_numerals_dot_decimal",
        "ar-SD":       "arabic_numerals_dot_decimal",
        "ar-SY":       "arabic_numerals_dot_decimal",
        "ar-TN":       "arabic_numerals_dot_decimal",
        "ar-YE":       "arabic_numerals_dot_decimal",
        "bg-BG":       "comma_decimal_space_thousands",
        "cs-CZ":       "comma_decimal_dot_thousands",
        "da-DK":       "comma_decimal_dot_thousands",
        "de-DE":       "comma_decimal_dot_thousands",
        "el-GR":       "comma_decimal_dot_thousands",
        "en-AU":       "dot_decimal_comma_thousands",
        "en-GB":       "dot_decimal_comma_thousands",
        "en-HK":       "dot_decimal_comma_thousands",
        "en-IN":       "indian_numbering_system",
        "en-NZ":       "dot_decimal_comma_thousands",
        "en-US":       "dot_decimal_comma_thousands",
        "en-ZA":       "dot_decimal_comma_thousands",
        "en-ZM":       "dot_decimal_comma_thousands",
        "eo":          "dot_decimal_no_thousands",
        "es-ES":       "comma_decimal_dot_thousands",
        "fa":          "arabic_numerals_comma_decimal",
        "fa-AF":       "arabic_numerals_comma_decimal",
        "fa-IR":       "arabic_numerals_comma_decimal",
        "fr-FR":       "comma_decimal_space_thousands",
        "fr-CA":       "dot_decimal_comma_thousands",
        "hu-HU":       "comma_decimal_space_thousands",
        "id-ID":       "dot_decimal_no_thousands",
        "it-IT":       "comma_decimal_dot_thousands",
        "ku-IQ":       "arabic_numerals_dot_decimal",
        "nb-NO":       "comma_decimal_space_thousands",
        "nl-NL":       "comma_decimal_dot_thousands",
        "nn-NO":       "comma_decimal_space_thousands",
        "pl-PL":       "comma_decimal_space_thousands",
        "pl-Pl":       "comma_decimal_space_thousands",
        "pt-BR":       "comma_decimal_dot_thousands",
        "pt-PT":       "comma_decimal_dot_thousands",
        "ru-RU":       "comma_decimal_space_thousands",
        "sl-SI":       "comma_decimal_dot_thousands",
        "sr-RS":       "comma_decimal_dot_thousands",
        "sr-RS@latin": "comma_decimal_dot_thousands",
        "sv-SE":       "comma_decimal_space_thousands",
        "tr-TR":       "comma_decimal_dot_thousands",
        "uk-UA":       "comma_decimal_space_thousands",
        "vi-VN":       "dot_decimal_no_thousands",

        "zh-CN": "dot_decimal_comma_thousands",
        "zh-TW": "dot_decimal_comma_thousands",
        "ja-JP": "dot_decimal_no_thousands",
        "ko-KR": "dot_decimal_no_thousands",
        "th-TH": "dot_decimal_no_thousands",
}

// A validator that check if the string represents a decimal number, such as 0.1, .3, 1.1, 1.00003, 4.0, etc.
//
// IsDecimalOpts is a struct which defaults to {ForceDecimal: false, DecimalDigits: {Min: 0, Max: nil}, locale: 'en-US'}.
//
// locale: determines the decimal separator and is one of ('ar', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', 'ar-JO', 'ar-KW', 'ar-LB', 'ar-LY', 'ar-MA', 'ar-QA', 'ar-QM', 'ar-SA', 'ar-SD', 'ar-SY', 'ar-TN', 'ar-YE', 'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-AU', 'en-GB', 'en-HK', 'en-IN', 'en-NZ', 'en-US', 'en-ZA', 'en-ZM', 'eo', 'es-ES', 'fa', 'fa-AF', 'fa-IR', 'fr-FR', 'fr-CA', 'hu-HU', 'id-ID', 'it-IT', 'ku-IQ', 'nb-NO', 'nl-NL', 'nn-NO', 'pl-PL', 'pl-Pl', 'pt-BR', 'pt-PT', 'ru-RU', 'sl-SI', 'sr-RS', 'sr-RS@latin', 'sv-SE', 'tr-TR', 'uk-UA', 'vi-VN'). Locale defaults to "en-US"
//
// ForceDecimal: simply means a decimal must be present "123" will not pass but "123.45" will pass
//
// DecimalDigits: is the allowed decimal range e.g {Min: 3, Max: nil} 123.456
//
//        ok := validatorgo.IsDecimal("123", validatorgo.IsDecimalOpts{})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsDecimal("abc", validatorgo.IsDecimalOpts{})
//        fmt.Println(ok) // false
func IsDecimal(str string, opts IsDecimalOpts) bool <span class="cov8" title="1">{
        if opts.Locale == "" </span><span class="cov8" title="1">{
                opts.Locale = "en-US"
        }</span>

        <span class="cov8" title="1">format, ok := localeDecimalFormats[opts.Locale]

        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">validReFunc := decimalFormats[format]
        re, err := validReFunc(opts)

        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return re.MatchString(str)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package validatorgo

import (
        "math"
        "strconv"
)

// A validator thats checks if the string is a number(integer not a floating point) that is divisible by another(integer not a floating point).
//
//        ok := validatorgo.IsDivisibleBy("10", 2)
//        fmt.Println(ok) // true
//        ok := validatorgo.IsDivisibleBy("10", 3)
//        fmt.Println(ok) // false
func IsDivisibleBy(str string, num int) bool <span class="cov8" title="1">{
        if num == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">strInt, err := strconv.Atoi(str)

        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return math.Abs(float64(strInt%num)) == float64(0)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package validatorgo

import (
        "strconv"
)

// IsEAN checks if the string is a valid [EAN] (European Article Number).
//
//        ok := validatorgo.IsDecimal("4006381333931")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsDecimal("123456789012")
//        fmt.Println(ok) // false
//
// [EAN]: https://en.wikipedia.org/wiki/International_Article_Number
func IsEAN(str string) bool <span class="cov8" title="1">{
        length := len(str)
        if length != 8 &amp;&amp; length != 13 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check if all characters are digits
        <span class="cov8" title="1">for _, r := range str </span><span class="cov8" title="1">{
                if r &lt; '0' || r &gt; '9' </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        // Calculate checksum
        <span class="cov8" title="1">var sum int
        for i, r := range str[:length-1] </span><span class="cov8" title="1">{
                digit, _ := strconv.Atoi(string(r))
                if (length == 8 &amp;&amp; i%2 == 0) || (length == 13 &amp;&amp; i%2 != 0) </span><span class="cov8" title="1">{
                        sum += digit * 3
                }</span> else<span class="cov8" title="1"> {
                        sum += digit
                }</span>
        }

        // The checksum digit is the last digit of the EAN
        <span class="cov8" title="1">checksum := (10 - (sum % 10)) % 10
        lastDigit, _ := strconv.Atoi(string(str[length-1]))

        return checksum == lastDigit</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package validatorgo

import (
        "fmt"
        "net"
        "regexp"
        "strings"
)

// IsEmailOpts is used to configure IsEmail
type IsEmailOpts struct {
        AllowDisplayName         bool
        RequireDisplayName       bool
        AllowUTF8LocalPart       bool
        RequireTld               bool
        IgnoreMaxLength          bool
        AllowIpDomain            bool
        DomainSpecificValidation bool
        BlacklistedChars         string
        HostBlacklist            []string
        HostWhitelist            []string
}

// A validator that checks if the string is an email.
//
// IsEmailOpts is a struct which defaults to { AllowDisplayName: false, RequireDisplayName: false, AllowUTF8LocalPart: true, RequireTld: true, AllowIpDomain: false, allow_underscores: false, DomainSpecificValidation: false, BlacklistedChars: ”, HostBlacklist: [] }.
//
// AllowDisplayName: if set to true, the validator will also match Display Name &lt;email-address&gt;.
// RequireDisplayName: if set to true, the validator will reject strings without the format Display Name &lt;email-address&gt;.
// AllowUTF8LocalPart: if set to false, the validator will not allow any non-English UTF8 character in email address' local part.
// RequireTld: if set to false, email addresses without a TLD in their domain will also be matched.
// IgnoreMaxLength: if set to true, the validator will not check for the standard max length of an email.
// AllowIpDomain: if set to true, the validator will allow IP addresses in the host part.
// DomainSpecificValidation: is true, some additional validation will be enabled, e.g. disallowing certain syntactically valid email addresses that are rejected by Gmail.
// BlacklistedChars: receives a string, then the validator will reject emails that include any of the characters in the string, in the name part.
// HostBlacklist: if set to an array of strings and the part of the email after the @ symbol matches one of the strings defined in it, the validation fails.
// HostWhitelist: if set to an array of strings and the part of the email after the @ symbol matches none of the strings defined in it, the validation fails.
//
//        ok := validatorgo.IsEmail("test@example.com", validatorgo.IsEmailOpts{})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsEmail("user.example.com", validatorgo.IsEmailOpts{})
//        fmt.Println(ok) // false
func IsEmail(str string, opts IsEmailOpts) bool <span class="cov8" title="1">{
        // Basic email regex, allowing for UTF-8 if specified
        var emailRegex *regexp.Regexp
        if opts.AllowUTF8LocalPart </span><span class="cov8" title="1">{
                emailRegex = regexp.MustCompile(`^[\p{L}0-9.!#$%&amp;'*+/=?^_` + "`" + `{|}~-]+@([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}|(\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])$`)
        }</span> else<span class="cov8" title="1"> {
                emailRegex = regexp.MustCompile(`^[a-zA-Z0-9.!#$%&amp;'*+/=?^_` + "`" + `{|}~-]+@([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}|(\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])$`)
        }</span>

        // Handle display name if required
        <span class="cov8" title="1">if opts.RequireDisplayName || opts.AllowDisplayName </span><span class="cov8" title="1">{
                displayNameRegex := regexp.MustCompile(`^.+\s&lt;(.+)&gt;$`)
                matches := displayNameRegex.FindStringSubmatch(str)
                if len(matches) == 2 </span><span class="cov8" title="1">{
                        str = matches[1]
                }</span> else<span class="cov8" title="1"> if opts.RequireDisplayName </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        // Basic email validation
        <span class="cov8" title="1">if !emailRegex.MatchString(str) </span><span class="cov8" title="1">{
                fmt.Println(emailRegex.String())
                fmt.Println("Basic email validation")
                return false
        }</span>

        // Extract the domain part
        <span class="cov8" title="1">parts := strings.Split(str, "@")
        domain := parts[1]

        // Handle IP domain if allowed
        if opts.AllowIpDomain &amp;&amp; strings.HasPrefix(domain, "[") &amp;&amp; strings.HasSuffix(domain, "]") </span><span class="cov8" title="1">{
                ip := domain[1 : len(domain)-1]
                if net.ParseIP(ip) != nil </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>
        }

        // Handle TLD requirement
        <span class="cov8" title="1">if opts.RequireTld &amp;&amp; !strings.Contains(domain, ".") </span><span class="cov0" title="0">{
                return false
        }</span>

        // Domain-specific validation
        <span class="cov8" title="1">if opts.DomainSpecificValidation &amp;&amp; domain == "gmail.com" </span><span class="cov8" title="1">{
                local := parts[0]
                if strings.Contains(local, "+") </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        // Blacklisted characters
        <span class="cov8" title="1">if opts.BlacklistedChars != "" </span><span class="cov8" title="1">{
                for _, char := range opts.BlacklistedChars </span><span class="cov8" title="1">{
                        if strings.ContainsRune(str, char) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }

        // Host blacklist/whitelist
        <span class="cov8" title="1">if len(opts.HostBlacklist) &gt; 0 </span><span class="cov8" title="1">{
                for _, blacklisted := range opts.HostBlacklist </span><span class="cov8" title="1">{
                        if strings.HasSuffix(domain, blacklisted) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(opts.HostWhitelist) &gt; 0 </span><span class="cov8" title="1">{
                allowed := false
                for _, whitelisted := range opts.HostWhitelist </span><span class="cov8" title="1">{
                        if strings.HasSuffix(domain, whitelisted) </span><span class="cov0" title="0">{
                                allowed = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !allowed </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package validatorgo

import "regexp"

// IsEmptyOpts is used to configure IsEmpty
type IsEmptyOpts struct {
        IgnoreWhitespace bool
}

// A validator check if the string has a length of zero.
//
// IsEmptyOpts is a struct which defaults to { IgnoreWhitespace: false }.
//
//        ok := validatorgo.IsEmpty("", validatorgo.IsEmpty{})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsEmpty("abc", validatorgo.IsEmpty{})
//        fmt.Println(ok) // false
func IsEmpty(str string, opts IsEmptyOpts) bool <span class="cov8" title="1">{
        if opts.IgnoreWhitespace </span><span class="cov8" title="1">{
                return regexp.MustCompile(`^(\s+)?$`).MatchString(str)
        }</span> else<span class="cov8" title="1"> {
                return regexp.MustCompile(`^$`).MatchString(str)
        }</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package validatorgo

import "regexp"

// A validator checks if the string is an [Ethereum address]. Does not validate address checksums.
//
//        ok := validatorgo.IsDivisibleBy("0xeA0B9657892321121287128712BC78A89F989AAA")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsDivisibleBy("0xiuahbsndakjsd")
//        fmt.Println(ok) // false
//
// [Ethereum address]: https://ethereum.org/
func IsEthereumAddress(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile(`^0x[a-fA-F0-9]{40}$`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package validatorgo

import (
        "regexp"
        "strconv"
        "strings"
)

type IsFloatOpts struct {
        Min    *float64
        Max    *float64
        Gt     *float64
        Lt     *float64
        Locale string
}

// Define the map with the format as the key and a function as the value
var formatFloat = map[string]func(string) string{
        "dot_decimal_comma_thousands": func(s string) string <span class="cov8" title="1">{
                // Remove the thousands separator and replace the comma with a dot
                s = strings.Replace(s, ",", "", -1)
                return strings.Replace(s, ".", ".", 1)
        }</span>,
        "comma_decimal_dot_thousands": func(s string) string <span class="cov8" title="1">{
                // Remove the thousands separator and replace the comma with a dot
                s = strings.Replace(s, ".", "", -1)
                return strings.Replace(s, ",", ".", 1)
        }</span>,
        "arabic_numerals_dot_decimal": func(s string) string <span class="cov0" title="0">{
                // This is an example for converting Arabic numerals (assuming input is already in Arabic format)
                return s // Assuming Arabic numerals are correctly formatted
        }</span>,
        "comma_decimal_space_thousands": func(s string) string <span class="cov0" title="0">{
                // Remove the thousands separator (space) and replace the comma with a dot
                s = strings.Replace(s, " ", "", -1)
                return strings.Replace(s, ",", ".", 1)
        }</span>,
        "dot_decimal_no_thousands": func(s string) string <span class="cov0" title="0">{
                // No thousands separator, just replace the comma with a dot
                return strings.Replace(s, ",", ".", 1)
        }</span>,
        "arabic_numerals_comma_decimal": func(s string) string <span class="cov0" title="0">{
                // Assuming input is already in Arabic numerals with comma
                return strings.Replace(s, ",", ".", 1)
        }</span>,
        "indian_numbering_system": func(s string) string <span class="cov0" title="0">{
                // Remove the Indian grouping comma and replace it with the standard format
                s = strings.Replace(s, ",", "", -1)
                return strings.Replace(s, ".", ".", 1)
        }</span>,
}

// floatFormats is the set of decimal formats and their validating regular expressions
var floatFormats = map[string]*regexp.Regexp{
        "dot_decimal_comma_thousands":        regexp.MustCompile(`^[+-]?(\d{1,3}(,\d{3})*\.\d+|\d+\.\d+)$`),          // Matches 1,234.56 and 1234567.56
        "comma_decimal_dot_thousands":        regexp.MustCompile(`^[+-]?(\d{1,3}(\.\d{3})*,\d+|\d+,\d+)$`),           // Matches 1.234,56 and 1234567,56
        "comma_decimal_space_thousands":      regexp.MustCompile(`^[+-]?(\d{1,3}( \d{3})*,\d+|\d+,\d+)$`),            // Matches 1 234,56 and 1234567,56
        "dot_decimal_space_thousands":        regexp.MustCompile(`^[+-]?(\d{1,3}( \d{3})*\.\d+|\d+\.\d+)$`),          // Matches 1 234.56 and 1234567.56
        "dot_decimal_apostrophe_thousands":   regexp.MustCompile(`^[+-]?(\d{1,3}('\d{3})*\.\d+|\d+\.\d+)$`),          // Matches 1'234.56 and 1234567.56
        "comma_decimal_apostrophe_thousands": regexp.MustCompile(`^[+-]?(\d{1,3}('\d{3})*,\d+|\d+,\d+)$`),            // Matches 1'234,56 and 1234567,56
        "dot_decimal_no_thousands":           regexp.MustCompile(`^[+-]?\d*\.\d+$`),                                  // Matches 1234567.78
        "comma_decimal_no_thousands":         regexp.MustCompile(`^[+-]?\d*,\d+$`),                                   // Matches 1234567,78
        "indian_numbering_system":            regexp.MustCompile(`^[+-]?(\d{1,2}(,\d{2})*(,\d{3})*\.\d+|\d+\.\d+)$`), // Matches 1,23,456.78 and 1234567.78
        "arabic_numerals_dot_decimal":        regexp.MustCompile(`^[+-]?[٠١٢٣٤٥٦٧٨٩]*(\.\d+|\d+\.\d+)$`),             // Matches ١٢٣٤٥٦٧٫٥٦
        "arabic_numerals_comma_decimal":      regexp.MustCompile(`^[+-]?[٠١٢٣٤٥٦٧٨٩]*(\,\d+|\d+\,\d+)$`),             // Matches ١٢٣٤٥٦٧،٥٦
}

// floatDecimalFormats is the set of Locales and their decimal formats
var floatDecimalFormats = map[string]string{
        "ar":          "arabic_numerals_dot_decimal",
        "ar-AE":       "arabic_numerals_dot_decimal",
        "ar-BH":       "arabic_numerals_dot_decimal",
        "ar-DZ":       "arabic_numerals_dot_decimal",
        "ar-EG":       "arabic_numerals_dot_decimal",
        "ar-IQ":       "arabic_numerals_dot_decimal",
        "ar-JO":       "arabic_numerals_dot_decimal",
        "ar-KW":       "arabic_numerals_dot_decimal",
        "ar-LB":       "arabic_numerals_dot_decimal",
        "ar-LY":       "arabic_numerals_dot_decimal",
        "ar-MA":       "arabic_numerals_dot_decimal",
        "ar-QA":       "arabic_numerals_dot_decimal",
        "ar-QM":       "arabic_numerals_dot_decimal",
        "ar-SA":       "arabic_numerals_dot_decimal",
        "ar-SD":       "arabic_numerals_dot_decimal",
        "ar-SY":       "arabic_numerals_dot_decimal",
        "ar-TN":       "arabic_numerals_dot_decimal",
        "ar-YE":       "arabic_numerals_dot_decimal",
        "bg-BG":       "comma_decimal_space_thousands",
        "cs-CZ":       "comma_decimal_dot_thousands",
        "da-DK":       "comma_decimal_dot_thousands",
        "de-DE":       "comma_decimal_dot_thousands",
        "el-GR":       "comma_decimal_dot_thousands",
        "en-AU":       "dot_decimal_comma_thousands",
        "en-GB":       "dot_decimal_comma_thousands",
        "en-HK":       "dot_decimal_comma_thousands",
        "en-IN":       "indian_numbering_system",
        "en-NZ":       "dot_decimal_comma_thousands",
        "en-US":       "dot_decimal_comma_thousands",
        "en-ZA":       "dot_decimal_comma_thousands",
        "en-ZM":       "dot_decimal_comma_thousands",
        "eo":          "dot_decimal_no_thousands",
        "es-ES":       "comma_decimal_dot_thousands",
        "fa":          "arabic_numerals_comma_decimal",
        "fa-AF":       "arabic_numerals_comma_decimal",
        "fa-IR":       "arabic_numerals_comma_decimal",
        "fr-FR":       "comma_decimal_space_thousands",
        "fr-CA":       "dot_decimal_comma_thousands",
        "hu-HU":       "comma_decimal_space_thousands",
        "id-ID":       "dot_decimal_no_thousands",
        "it-IT":       "comma_decimal_dot_thousands",
        "ku-IQ":       "arabic_numerals_dot_decimal",
        "nb-NO":       "comma_decimal_space_thousands",
        "nl-NL":       "comma_decimal_dot_thousands",
        "nn-NO":       "comma_decimal_space_thousands",
        "pl-PL":       "comma_decimal_space_thousands",
        "pl-Pl":       "comma_decimal_space_thousands",
        "pt-BR":       "comma_decimal_dot_thousands",
        "pt-PT":       "comma_decimal_dot_thousands",
        "ru-RU":       "comma_decimal_space_thousands",
        "sl-SI":       "comma_decimal_dot_thousands",
        "sr-RS":       "comma_decimal_dot_thousands",
        "sr-RS@latin": "comma_decimal_dot_thousands",
        "sv-SE":       "comma_decimal_space_thousands",
        "tr-TR":       "comma_decimal_dot_thousands",
        "uk-UA":       "comma_decimal_space_thousands",
        "vi-VN":       "dot_decimal_no_thousands",

        "zh-CN": "dot_decimal_comma_thousands",
        "zh-TW": "dot_decimal_comma_thousands",
        "ja-JP": "dot_decimal_no_thousands",
        "ko-KR": "dot_decimal_no_thousands",
        "th-TH": "dot_decimal_no_thousands",
}

const defaultIsFloatFormat = "dot_decimal_comma_thousands"

// A validator that checks if the string is a float.
//
// IsFloatOpts is a struct which can contain the fields Min, Max, Gt, and/or Lt to validate the float is within boundaries it also has Locale as an option.
//
// Min and Max: are equivalent to 'greater or equal' and 'less or equal'.
//
// Gt and Lt: are their strict counterparts.
//
// Locale determines the decimal separator and is one of ('ar', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', 'ar-JO', 'ar-KW', 'ar-LB', 'ar-LY', 'ar-MA', 'ar-QA', 'ar-QM', 'ar-SA', 'ar-SD', 'ar-SY', 'ar-TN', 'ar-YE', 'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'en-AU', 'en-GB', 'en-HK', 'en-IN', 'en-NZ', 'en-US', 'en-ZA', 'en-ZM', 'eo', 'es-ES', 'fr-CA', 'fr-FR', 'hu-HU', 'it-IT', 'nb-NO', 'nl-NL', 'nn-NO', 'pl-PL', 'pt-BR', 'pt-PT', 'ru-RU', 'sl-SI', 'sr-RS', 'sr-RS@latin', 'sv-SE', 'tr-TR', 'uk-UA').
//
//        ok := validatorgo.IsFloat("123.45",  validatorgo.IsFloatOpts{})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsFloat("123", validatorgo.IsFloatOpts{})
//        fmt.Println(ok) // false
func IsFloat(str string, opts IsFloatOpts) bool <span class="cov8" title="1">{
        format, ok := floatDecimalFormats[opts.Locale]

        if !ok </span><span class="cov8" title="1">{
                format = defaultIsFloatFormat
        }</span>

        <span class="cov8" title="1">parsableFltFunc := formatFloat[format]
        parsableFlt := parsableFltFunc(str)

        flt, err := strconv.ParseFloat(parsableFlt, 64)

        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">re := floatFormats[format]

        inRange := true

        if opts.Min != nil </span><span class="cov8" title="1">{
                inRange = flt &gt;= *opts.Min &amp;&amp; inRange
        }</span>

        <span class="cov8" title="1">if opts.Max != nil </span><span class="cov8" title="1">{
                inRange = flt &lt;= *opts.Max &amp;&amp; inRange
        }</span>

        <span class="cov8" title="1">if opts.Lt != nil </span><span class="cov8" title="1">{
                inRange = flt &lt; *opts.Lt &amp;&amp; inRange
        }</span>

        <span class="cov8" title="1">if opts.Gt != nil </span><span class="cov8" title="1">{
                inRange = flt &gt; *opts.Gt &amp;&amp; inRange
        }</span>

        <span class="cov8" title="1">return re.MatchString(str) &amp;&amp; inRange</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package validatorgo

import (
        "fmt"
        "regexp"
        "unicode/utf8"
)

const defaultMaxFQDNLength = 253

// IsFQDNoptsOpts is used to configure IsFQDNopts
type IsFQDNopts struct {
        RequireTld       bool
        AllowUnderscores bool
        AllowTrailingDot bool
        AllowNumericTld  bool
        IgnoreMaxLength  bool
}

// A validator that checks if the string is a fully qualified domain name (e.g. domain.com).
//
// IsFQDNopts is a struct which defaults to { RequireTld: false, AllowUnderscores: false, AllowTrailingDot: false, AllowNumericTld: false, allow_wildcard: false, IgnoreMaxLength: false }.
//        ok := validatorgo.IsFQDN("localhost",  validatorgo.IsFQDNOpts{})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsFQDN("example..com", validatorgo.IsFQDNOpts{})
//        fmt.Println(ok) // false
func IsFQDN(str string, opts IsFQDNopts) bool <span class="cov8" title="1">{
        ignMaxLength := true
        len := utf8.RuneCountInString(str)

        if !opts.IgnoreMaxLength &amp;&amp; len &gt; defaultMaxFQDNLength </span><span class="cov8" title="1">{
                ignMaxLength = false
        }</span>

        <span class="cov8" title="1">allowUnderScoreRe := `a-zA-Z0-9`
        if opts.AllowUnderscores </span><span class="cov8" title="1">{
                allowUnderScoreRe = `\w`
        }</span>
        <span class="cov8" title="1">requireTldRe := "?"
        if opts.RequireTld </span><span class="cov0" title="0">{
                requireTldRe = ""
        }</span>
        <span class="cov8" title="1">allowTrailingDotRe := ``
        if opts.AllowTrailingDot </span><span class="cov8" title="1">{
                allowTrailingDotRe = `\.?`
        }</span>
        <span class="cov8" title="1">allowNumTldRe := `[a-zA-Z_]`
        if opts.AllowNumericTld </span><span class="cov8" title="1">{
                allowNumTldRe = `\w`
        }</span>

        <span class="cov8" title="1">reStr := fmt.Sprintf(`^([%s])+(\.[%s]+)?\.%s%s+%s$`, allowUnderScoreRe, allowUnderScoreRe, requireTldRe, allowNumTldRe, allowTrailingDotRe)
        // fmt.Println(reStr)
        re := regexp.MustCompile(reStr)
        isValid := re.MatchString(str)
        fmt.Printf("length is, %d while defleng is %d and isvalid is %t\n", len, defaultMaxFQDNLength, isValid)
        return isValid &amp;&amp; ignMaxLength</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package validatorgo

import (
        "fmt"
        "math"
        "regexp"
        "strconv"
        "unicode/utf8"
)

var alphaFreightNumVal = map[string]int{
        "A": 10,
        "B": 12,
        "C": 13,
        "D": 14,
        "E": 15,
        "F": 16,
        "G": 17,
        "H": 18,
        "I": 19,
        "J": 20,
        "K": 21,
        "L": 23,
        "M": 24,
        "N": 25,
        "O": 26,
        "P": 27,
        "Q": 28,
        "R": 29,
        "S": 30,
        "T": 31,
        "U": 32,
        "V": 34,
        "W": 35,
        "X": 36,
        "Y": 37,
        "Z": 38,
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9,
}

// A validator that checks alias for IsISO6346, check if the string is a valid [ISO 6346] shipping container identification.
//
//        ok := validatorgo.IsFreightContainerID("ABCU1234567")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsFreightContainerID("AB123456789")
//        fmt.Println(ok) // false
//
// [ISO 6346]: https://en.wikipedia.org/wiki/ISO_6346
func IsFreightContainerID(str string) bool <span class="cov8" title="1">{
        // Check if length is 11
        if utf8.RuneCountInString(str) != 11 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">re := regexp.MustCompile(`^([A-Z]{3})([UJZ])([0-9]{6})([0-9])$`)
        match := re.MatchString(str)
        if !match </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">sum := 0
        for ind, char := range str[:10] </span><span class="cov8" title="1">{
                wgh := int(math.Pow(2.0, float64(9-ind)))
                charStr := string(char)
                num, ok := alphaFreightNumVal[charStr]

                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">fmt.Printf("Char: %v, Weight: %v, Num: %v\n", charStr, wgh, num)
                sum += wgh * num</span>
        }

        <span class="cov8" title="1">grps := re.FindStringSubmatch(str)
        checkDigit := grps[4] // Extract the check digit
        rem := sum % 11

        if rem == 10 &amp;&amp; checkDigit == "0" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">checkDigitInt, err := strconv.Atoi(checkDigit)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return checkDigitInt == rem</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package validatorgo

// A validator that checks if the string contains any full-width chars.
//
//        ok := validatorgo.IsFullWidth("テスト")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsFullWidth("abc123")
//        fmt.Println(ok) // false
func IsFullWidth(str string) bool <span class="cov8" title="1">{
        for _, char := range str </span><span class="cov8" title="1">{
                if (char &gt;= '\uFF00' &amp;&amp; char &lt;= '\uFFEF') ||
                        (char &gt;= '\u4E00' &amp;&amp; char &lt;= '\u9FFF') ||
                        (char &gt;= '\u3040' &amp;&amp; char &lt;= '\u309F') ||
                        (char &gt;= '\u30A0' &amp;&amp; char &lt;= '\u30FF') </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package validatorgo

// A validator that checks if the string contains any half-width chars.
//
//        ok := validatorgo.IsHalfWidth("abc123")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsHalfWidth("漢字テスト")
//        fmt.Println(ok) // false
func IsHalfWidth(str string) bool <span class="cov8" title="1">{
        for _, char := range str </span><span class="cov8" title="1">{
                if char &gt;= '\u0020' &amp;&amp; char &lt;= '\u007E' </span><span class="cov8" title="1">{ // ASCII (half-width characters)
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package validatorgo

import "regexp"

// hashAlgoRegex is the set of regex's for hashing algo
var hashAlgoRegex = map[string]*regexp.Regexp{
        "crc32":     regexp.MustCompile(`^[a-fA-F0-9]{8}$`),   // 8 hex characters
        "crc32b":    regexp.MustCompile(`^[a-fA-F0-9]{8}$`),   // 8 hex characters
        "md4":       regexp.MustCompile(`^[a-fA-F0-9]{32}$`),  // 32 hex characters
        "md5":       regexp.MustCompile(`^[a-fA-F0-9]{32}$`),  // 32 hex characters
        "ripemd128": regexp.MustCompile(`^[a-fA-F0-9]{32}$`),  // 32 hex characters
        "ripemd160": regexp.MustCompile(`^[a-fA-F0-9]{40}$`),  // 40 hex characters
        "sha1":      regexp.MustCompile(`^[a-fA-F0-9]{40}$`),  // 40 hex characters
        "sha256":    regexp.MustCompile(`^[a-fA-F0-9]{64}$`),  // 64 hex characters
        "sha384":    regexp.MustCompile(`^[a-fA-F0-9]{96}$`),  // 96 hex characters
        "sha512":    regexp.MustCompile(`^[a-fA-F0-9]{128}$`), // 128 hex characters
        "tiger128":  regexp.MustCompile(`^[a-fA-F0-9]{32}$`),  // 32 hex characters
        "tiger160":  regexp.MustCompile(`^[a-fA-F0-9]{40}$`),  // 40 hex characters
        "tiger192":  regexp.MustCompile(`^[a-fA-F0-9]{48}$`),  // 48 hex characters
}

// A validator that checks if the string is a hash of type algorithm.
//
// Algorithm is one of ('crc32', 'crc32b', 'md4', 'md5', 'ripemd128', 'ripemd160', 'sha1', 'sha256', 'sha384', 'sha512', 'tiger128', 'tiger160', 'tiger192'), No checksum are calculated.
//
//        ok := validatorgo.IsHash("d202ef8d", "crc32")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsHash("d202ef8", "crc32")
//        fmt.Println(ok) // false
func IsHash(str, algorithm string) bool <span class="cov8" title="1">{
        re, exist := hashAlgoRegex[algorithm]

        if !exist </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return re.MatchString(str)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string is a hexadecimal number.
//
//        ok := validatorgo.IsHexadecimal("1234567890abcdef")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsHexadecimal("abcdefg")
//        fmt.Println(ok) // false
func IsHexadecimal(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile(`^[a-fA-F0-9]+$`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string is a hexadecimal color.
//
//        ok := validatorgo.IsHexColor("#abc")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsHexColor("#xyz")
//        fmt.Println(ok) // false
func IsHexColor(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile(`^#(?:[0-9a-fA-F]{3}){1,2}$`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package validatorgo

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"
)

// A validator that checks if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.
//
//        ok := validatorgo.IsHSL("hsl(360, 100%, 50%)")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsHSL("hsl(360, 100%)")
//        fmt.Println(ok) // false
func IsHSL(str string) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(`(?im)^hsla?\(\s*(?&lt;h&gt;[-+]?\d{1,3}(?:\.\d+)?)(deg|grad|rad|turn)?\s*,\s*(?&lt;s&gt;[-+]?\d{1,3}(?:\.\d+)?)%\s*,\s*(?&lt;l&gt;[-+]?\d{1,3}(?:\.\d+)?)%\s*(?:,\s*(?&lt;alpha&gt;[-+]?[\d.]+%?)\s*)?\)$
`)

        match := re.MatchString(str)

        if !match </span><span class="cov8" title="1">{
                return match
        }</span>

        <span class="cov0" title="0">grps := re.FindStringSubmatch(str)
        // fmt.Printf("GRPS %+v\n", grps)
        // fmt.Println("0", grps[0])
        // fmt.Println("1", grps[1])
        // fmt.Println("2", grps[2])
        // fmt.Println("3", grps[3])
        // fmt.Println("4", grps[4])
        // fmt.Println("5", grps[5])
        hue, sat, light, alpha := grps[1], grps[3], grps[4], grps[5]

        // fmt.Println("hue", hue)
        // fmt.Println("sat", sat)
        // fmt.Println("light", light)

        const bitSize = 64
        hueNum, err := strconv.ParseFloat(hue, bitSize)

        if err != nil || hueNum &lt; 0 || hueNum &gt; 360 </span><span class="cov0" title="0">{
                return false
        }</span>

        // satWthOutPer := strings.Replace(sat, "%", "", 1)
        <span class="cov0" title="0">satNum, err := strconv.ParseFloat(sat, bitSize)
        fmt.Println(sat, satNum, err)

        if err != nil || satNum &lt; 0 || satNum &gt; 100 </span><span class="cov0" title="0">{
                return false
        }</span>

        // lightWthOutPer := strings.Replace(light, "%", "", 1)
        <span class="cov0" title="0">lightNum, err := strconv.ParseFloat(light, bitSize)

        if err != nil || lightNum &lt; 0 || lightNum &gt; 100 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">var (
                alphaNum float64
                alphaErr error
        )
        if strings.HasSuffix(alpha, "%") </span><span class="cov0" title="0">{
                alphaWthOutPer := strings.Replace(alpha, "%", "", 1)
                alphaNum, alphaErr = strconv.ParseFloat(alphaWthOutPer, bitSize)
                alphaNum = alphaNum / 100
        }</span> else<span class="cov0" title="0"> {
                alphaNum, alphaErr = strconv.ParseFloat(alpha, bitSize)
        }</span>

        <span class="cov0" title="0">if alpha != "" &amp;&amp; (alphaErr != nil || alphaNum &lt; 0 || alphaNum &gt; 1) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package validatorgo

import "regexp"

// iban regex's for country codes
var ibanRegex = map[string]*regexp.Regexp{
        "AD": regexp.MustCompile(`^AD\d{2}\d{4}\d{4}\d{12}$`),               // Andorra
        "AE": regexp.MustCompile(`^AE\d{2}\d{3}\d{16}$`),                    // United Arab Emirates
        "AL": regexp.MustCompile(`^AL\d{2}\d{8}\d{16}$`),                    // Albania
        "AT": regexp.MustCompile(`^AT\d{2}\d{5}\d{11}$`),                    // Austria
        "AZ": regexp.MustCompile(`^AZ\d{2}[A-Z]{4}\d{20}$`),                 // Azerbaijan
        "BA": regexp.MustCompile(`^BA\d{2}\d{3}\d{3}\d{8}\d{2}$`),           // Bosnia and Herzegovina
        "BE": regexp.MustCompile(`^BE\d{2}\d{3}\d{7}\d{2}$`),                // Belgium
        "BG": regexp.MustCompile(`^BG\d{2}[A-Z]{4}\d{4}\d{10}$`),            // Bulgaria
        "BH": regexp.MustCompile(`^BH\d{2}[A-Z]{4}\d{14}$`),                 // Bahrain
        "BR": regexp.MustCompile(`^BR\d{2}\d{8}\d{5}\d{10}[A-Z]{1}\d{1}$`),  // Brazil
        "BY": regexp.MustCompile(`^BY\d{2}[A-Z]{4}\d{4}\d{16}$`),            // Belarus
        "CH": regexp.MustCompile(`^CH\d{2}\d{5}\d{12}$`),                    // Switzerland
        "CR": regexp.MustCompile(`^CR\d{2}\d{4}\d{14}$`),                    // Costa Rica
        "CY": regexp.MustCompile(`^CY\d{2}\d{3}\d{5}\d{16}$`),               // Cyprus
        "CZ": regexp.MustCompile(`^CZ\d{2}\d{4}\d{6}\d{10}$`),               // Czech Republic
        "DE": regexp.MustCompile(`^DE\d{2}\d{8}\d{10}$`),                    // Germany
        "DK": regexp.MustCompile(`^DK\d{2}\d{4}\d{10}$`),                    // Denmark
        "DO": regexp.MustCompile(`^DO\d{2}[A-Z]{4}\d{20}$`),                 // Dominican Republic
        "EE": regexp.MustCompile(`^EE\d{2}\d{2}\d{2}\d{11}$`),               // Estonia
        "ES": regexp.MustCompile(`^ES\d{2}\d{4}\d{4}\d{2}\d{10}$`),          // Spain
        "FI": regexp.MustCompile(`^FI\d{2}\d{6}\d{7}\d{1}$`),                // Finland
        "FO": regexp.MustCompile(`^FO\d{2}\d{4}\d{9}\d{1}$`),                // Faroe Islands
        "FR": regexp.MustCompile(`^FR\d{2}\d{5}\d{5}[A-Z0-9]{11}\d{2}$`),    // France
        "GB": regexp.MustCompile(`^GB\d{2}[A-Z]{4}\d{6}\d{8}$`),             // United Kingdom
        "GE": regexp.MustCompile(`^GE\d{2}[A-Z]{2}\d{16}$`),                 // Georgia
        "GI": regexp.MustCompile(`^GI\d{2}[A-Z]{4}\d{15}$`),                 // Gibraltar
        "GL": regexp.MustCompile(`^GL\d{2}\d{4}\d{10}$`),                    // Greenland
        "GR": regexp.MustCompile(`^GR\d{2}\d{3}\d{4}[A-Z0-9]{16}$`),         // Greece
        "GT": regexp.MustCompile(`^GT\d{2}[A-Z0-9]{4}\d{20}$`),              // Guatemala
        "HR": regexp.MustCompile(`^HR\d{2}\d{7}\d{10}$`),                    // Croatia
        "HU": regexp.MustCompile(`^HU\d{2}\d{3}\d{4}\d{1}\d{15}\d{1}$`),     // Hungary
        "IE": regexp.MustCompile(`^IE\d{2}[A-Z]{4}\d{6}\d{8}$`),             // Ireland
        "IL": regexp.MustCompile(`^IL\d{2}\d{3}\d{3}\d{13}$`),               // Israel
        "IS": regexp.MustCompile(`^IS\d{2}\d{4}\d{2}\d{6}\d{10}$`),          // Iceland
        "IT": regexp.MustCompile(`^IT\d{2}[A-Z]{1}\d{5}\d{5}[A-Z0-9]{12}$`), // Italy
        "JO": regexp.MustCompile(`^JO\d{2}[A-Z]{4}\d{4}\d{18}$`),            // Jordan
        "KW": regexp.MustCompile(`^KW\d{2}[A-Z]{4}\d{22}$`),                 // Kuwait
        "KZ": regexp.MustCompile(`^KZ\d{2}\d{3}\d{13}$`),                    // Kazakhstan
        "LB": regexp.MustCompile(`^LB\d{2}\d{4}\d{20}$`),                    // Lebanon
        "LC": regexp.MustCompile(`^LC\d{2}[A-Z]{4}[A-Z0-9]{24}$`),           // Saint Lucia
        "LI": regexp.MustCompile(`^LI\d{2}\d{5}\d{12}$`),                    // Liechtenstein
        "LT": regexp.MustCompile(`^LT\d{2}\d{5}\d{11}$`),                    // Lithuania
        "LU": regexp.MustCompile(`^LU\d{2}\d{3}\d{13}$`),                    // Luxembourg
        "LV": regexp.MustCompile(`^LV\d{2}[A-Z]{4}\d{13}$`),                 // Latvia
        "MC": regexp.MustCompile(`^MC\d{2}\d{5}\d{5}[A-Z0-9]{11}\d{2}$`),    // Monaco
        "MD": regexp.MustCompile(`^MD\d{2}[A-Z0-9]{2}\d{18}$`),              // Moldova
        "ME": regexp.MustCompile(`^ME\d{2}\d{3}\d{13}\d{2}$`),               // Montenegro
        "MK": regexp.MustCompile(`^MK\d{2}\d{3}[A-Z0-9]{10}\d{2}$`),         // North Macedonia
        "MR": regexp.MustCompile(`^MR\d{2}\d{5}\d{5}\d{11}\d{2}$`),          // Mauritania
        "MT": regexp.MustCompile(`^MT\d{2}[A-Z]{4}\d{5}\d{18}$`),            // Malta
        "MU": regexp.MustCompile(`^MU\d{2}[A-Z]{4}\d{19}[A-Z]{3}$`),         // Mauritius
        "NL": regexp.MustCompile(`^NL\d{2}[A-Z]{4}\d{10}$`),                 // Netherlands
        "NO": regexp.MustCompile(`^NO\d{2}\d{4}\d{6}\d{1}$`),                // Norway
        "PK": regexp.MustCompile(`^PK\d{2}[A-Z]{4}\d{16}$`),                 // Pakistan
        "PL": regexp.MustCompile(`^PL\d{2}\d{8}\d{16}$`),                    // Poland
        "PS": regexp.MustCompile(`^PS\d{2}[A-Z]{4}\d{21}$`),                 // Palestine
        "PT": regexp.MustCompile(`^PT\d{2}\d{4}\d{4}\d{11}\d{2}$`),          // Portugal
        "QA": regexp.MustCompile(`^QA\d{2}[A-Z]{4}\d{21}$`),                 // Qatar
        "RO": regexp.MustCompile(`^RO\d{2}[A-Z]{4}\d{16}$`),                 // Romania
        "RS": regexp.MustCompile(`^RS\d{2}\d{3}\d{13}\d{2}$`),               // Serbia
        "SA": regexp.MustCompile(`^SA\d{2}\d{2}\d{18}$`),                    // Saudi Arabia
        "SC": regexp.MustCompile(`^SC\d{2}[A-Z]{4}\d{20}[A-Z]{3}$`),         // Seychelles
        "SE": regexp.MustCompile(`^SE\d{2}\d{3}\d{16}\d{1}$`),               // Sweden
        "SI": regexp.MustCompile(`^SI\d{2}\d{5}\d{8}\d{2}$`),                // Slovenia
        "SK": regexp.MustCompile(`^SK\d{2}\d{4}\d{6}\d{10}$`),               // Slovakia
        "SM": regexp.MustCompile(`^SM\d{2}[A-Z]{1}\d{5}\d{5}[A-Z0-9]{12}$`), // San Marino
        "ST": regexp.MustCompile(`^ST\d{2}\d{4}\d{4}\d{11}\d{2}$`),          // Sao Tome and Principe
        "SV": regexp.MustCompile(`^SV\d{2}[A-Z]{4}\d{20}$`),                 // El Salvador
        "TL": regexp.MustCompile(`^TL\d{2}\d{3}\d{14}$`),                    // East Timor
        "TN": regexp.MustCompile(`^TN\d{2}\d{2}\d{3}\d{13}\d{2}$`),          // Tunisia
        "TR": regexp.MustCompile(`^TR\d{2}\d{5}\d{1}\d{16}$`),               // Turkey
        "UA": regexp.MustCompile(`^UA\d{2}\d{6}\d{19}$`),                    // Ukraine
        "VG": regexp.MustCompile(`^VG\d{2}[A-Z]{4}\d{16}$`),                 // British Virgin Islands
        "XK": regexp.MustCompile(`^XK\d{2}\d{4}\d{10}\d{2}$`),               // Kosovo
        "IQ": regexp.MustCompile(`^IQ\d{2}[A-Z]{4}\d{15}$`),                 // Iraq
        "MZ": regexp.MustCompile(`^MZ\d{2}[A-Z0-9]{21}$`),                   // Mozambique
        "VA": regexp.MustCompile(`^VA\d{2}[A-Z0-9]{18}$`),                   // Vatican City
}

// A validator that checks if the string is an IBAN (International Bank Account Number).
//
// these are the allowed country codes ('AD','AE','AL','AT','AZ','BA','BE','BG','BH','BR','BY','CH','CR','CY','CZ','DE','DK','DO','EE','EG','ES','FI','FO','FR','GB','GE','GI','GL','GR','GT','HR','HU','IE','IL','IQ','IR','IS','IT','JO','KW','KZ','LB','LC','LI','LT','LU','LV','MC','MD','ME','MK','MR','MT','MU','MZ','NL','NO','PK','PL','PS','PT','QA','RO','RS','SA','SC','SE','SI','SK','SM','SV','TL','TN','TR','UA','VA','VG','XK'). No checksum are calculated.
//
//        ok := validatorgo.IsIBAN("DE75512108001245126199", "DE")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsIBAN("DE75512108001245126100", "DE")
//        fmt.Println(ok) // false
func IsIBAN(str, countryCode string) bool <span class="cov8" title="1">{
        re, exist := ibanRegex[countryCode]

        if !exist </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return re.MatchString(str)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package validatorgo

import (
        "regexp"
)

var identityCardLocaleRegex = map[string]*regexp.Regexp{
        "LK":    regexp.MustCompile(`^\d{9}[VXvx]$`),              // Sri Lanka
        "PL":    regexp.MustCompile(`^[A-Z]{3}\d{6}$`),            // Poland
        "ES":    regexp.MustCompile(`^\d{8}[A-Z]$`),               // Spain
        "FI":    regexp.MustCompile(`^\d{6}[+\-A]\d{3}[A-Z0-9]$`), // Finland
        "IN":    regexp.MustCompile(`^\d{12}$`),                   // India
        "IT":    regexp.MustCompile(`^[A-Z0-9]{9}$`),              // Italy
        "IR":    regexp.MustCompile(`^\d{10}$`),                   // Iran
        "MZ":    regexp.MustCompile(`^\d{13}$`),                   // Mozambique
        "NO":    regexp.MustCompile(`^\d{11}$`),                   // Norway
        "TH":    regexp.MustCompile(`^\d{13}$`),                   // Thailand
        "zh-TW": regexp.MustCompile(`^[A-Z][12]\d{8}$`),           // Taiwan
        "he-IL": regexp.MustCompile(`^\d{9}$`),                    // Israel
        "ar-LY": regexp.MustCompile(`^\d{12}$`),                   // Libya
        "ar-TN": regexp.MustCompile(`^\d{8}$`),                    // Tunisia
        "zh-CN": regexp.MustCompile(`^\d{17}[\dX]$`),              // China
        "zh-HK": regexp.MustCompile(`^[A-Z]\d{6}[\dA]$`),          // Hong Kong
        "PK":    regexp.MustCompile(`^\d{13}$`),                   // Pakistan
}

// A validator that checks if the string is a valid identity card code.
//
// locale is one of ['LK', 'PL', 'ES', 'FI', 'IN', 'IT', 'IR', 'MZ', 'NO', 'TH', 'zh-TW', 'he-IL', 'ar-LY', 'ar-TN', 'zh-CN', 'zh-HK', 'PK'] OR "any". If "any" is used, function will check if any of the locales match. Defaults to "any" if locale not present. No checksums calculated.
//
//        ok := validatorgo.IsIdentityCard("123456789V", "LK")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsIdentityCard("12345678X", "LK")
//        fmt.Println(ok) // false
func IsIdentityCard(str, locale string) bool <span class="cov8" title="1">{
        if locale == "" </span><span class="cov0" title="0">{
                locale = "any"
        }</span>

        <span class="cov8" title="1">re, ok := identityCardLocaleRegex[locale]

        if ok </span><span class="cov8" title="1">{
                return re.MatchString(str)
        }</span> else<span class="cov8" title="1"> {
                if locale != "any" </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov0" title="0">for _, reg := range identityCardLocaleRegex </span><span class="cov0" title="0">{
                        matches := reg.MatchString(str)
                        if matches </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package validatorgo

import (
        "fmt"
        "regexp"
        "strconv"
)

// IsIMEIOpts is used to configure IsIMEI
type IsIMEIOpts struct {
        AllowHyphens bool
}

// A validator that checks if the string is a valid [IMEI number]. IMEI should be of format ############### or ##-######-######-#.
//
// IsIMEIOpts is a struct which can contain the keys AllowHyphens. Defaults to first format.
//
// If AllowHyphens is set to true, the validator will validate the second format.
//
//        ok := validatorgo.IsIMEI("490154203237518", IsIMEIOpts{})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsIMEI("359043377500085", IsIMEIOpts{})
//        fmt.Println(ok) // false
//
// [IMEI number]: https://en.wikipedia.org/wiki/International_Mobile_Equipment_Identity
func IsIMEI(str string, opts IsIMEIOpts) bool <span class="cov8" title="1">{
        var re *regexp.Regexp

        if opts.AllowHyphens </span><span class="cov8" title="1">{
                re = regexp.MustCompile(`^\d{2}-?\d{6}-?\d{6}-?\d$`)
        }</span> else<span class="cov8" title="1"> {
                re = regexp.MustCompile(`^\d{15}$`)
        }</span>

        <span class="cov8" title="1">if !re.MatchString(str) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">strWithoutHyphens := stripHyphens(str)

        fmt.Println(strWithoutHyphens)

        strLen := len(strWithoutHyphens)
        isSecond := false
        // checkDigit := 0
        sum := 0

        for i := strLen - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                dig, _ := strconv.Atoi(string(strWithoutHyphens[i]))

                // if i == strLen-1 {
                //         checkDigit = dig
                // }

                if isSecond </span><span class="cov8" title="1">{
                        dbDig := dig * 2

                        if dbDig &gt; 9 </span><span class="cov8" title="1">{
                                dbDig = digitSum(dbDig)
                        }</span>

                        <span class="cov8" title="1">sum += dbDig</span>
                } else<span class="cov8" title="1"> {
                        sum += dig
                }</span>

                <span class="cov8" title="1">isSecond = !isSecond</span>
        }

        <span class="cov8" title="1">return sum%10 == 0</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package validatorgo

// A validator that checks if the string is in a slice of allowed values.
//
//        ok := validatorgo.IsIn("apple", []string{"apple", "banana", "grape"})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsIn("orange", []string{"apple", "banana", "grape"})
//        fmt.Println(ok) // false
func IsIn(str string, values []string) bool <span class="cov8" title="1">{
        for _, val := range values </span><span class="cov8" title="1">{
                if str == val </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package validatorgo

import (
        "fmt"
        "regexp"
        "strconv"
)

type IsIntOpts struct {
        Min *int // minimum integer
        Max *int // maximum integer

        Gt *int // integer to exceeds
        Lt *int // integer to subceed

        AllowLeadingZeroes bool
}

// A validator that checks if the string is an integer.
//
// IsIntOpts is a struct which can contain the keys Min and/or Max to check the integer is within boundaries (e.g. { Min: nil, Max: nil }). 
//
// IsIntOpts can also contain the key AllowLeadingZeroes, which when set to false will disallow integer values with leading zeroes (e.g. { AllowLeadingZeroes: false }). 
//
// Finally, IsIntOpts can contain the keys Gt and/or Lt which will enforce integers being greater than or less than, respectively, the value provided (e.g. {Gt: ptr(1), Lt: ptr(4)} for a number between 1 and 4).
//
//        ok := validatorgo.IsInt("123", IsIntOpts{})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsInt("123.45", IsIntOpts{})
//        fmt.Println(ok) // false
func IsInt(str string, opts IsIntOpts) bool <span class="cov8" title="1">{
        var matches bool

        if opts.AllowLeadingZeroes </span><span class="cov8" title="1">{
                matches = regexp.MustCompile(`^([+-]?0*\d+)(\.0+)?$`).MatchString(str)
        }</span> else<span class="cov8" title="1"> {
                matches = regexp.MustCompile(`^([+-]?)((0|[1-9]\d*)(\.0*)?|0)$`).MatchString(str)
        }</span>

        <span class="cov8" title="1">if !matches </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">strInt, err := strconv.Atoi(str)

        if err != nil </span><span class="cov0" title="0">{
                // fmt.Println("failed parsing")
                return false
        }</span>

        // fmt.Println("Passes regex and conversion")

        <span class="cov8" title="1">withinLimits := true

        if opts.Min != nil </span><span class="cov8" title="1">{
                // fmt.Println("within min")
                isMin := *(opts.Min) &lt;= strInt
                withinLimits = withinLimits &amp;&amp; isMin
        }</span>

        <span class="cov8" title="1">if opts.Max != nil </span><span class="cov8" title="1">{
                // fmt.Println("within max")
                isMax := *(opts.Max) &gt;= strInt
                withinLimits = withinLimits &amp;&amp; isMax
        }</span>

        <span class="cov8" title="1">fmt.Println(strInt, withinLimits)

        if opts.Lt != nil </span><span class="cov8" title="1">{
                isMin := strInt &lt; *(opts.Lt)
                withinLimits = withinLimits &amp;&amp; isMin
                // fmt.Println("within lt", withinLimits)
        }</span>

        <span class="cov8" title="1">if opts.Gt != nil </span><span class="cov8" title="1">{
                isMax := strInt &gt; *(opts.Gt)
                withinLimits = withinLimits &amp;&amp; isMax
                // fmt.Println("within gt", withinLimits)
        }</span>

        <span class="cov8" title="1">return withinLimits</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package validatorgo

import (
        "regexp"
)

// ipVersionRegex is the set of versions and their validating regex
var ipVersionRegex = map[string]*regexp.Regexp{
        "4": regexp.MustCompile(`^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$`),
        "6": regexp.MustCompile(`^([[:xdigit:]]{1,4}(?::[[:xdigit:]]{1,4}){7}|::|:(?::[[:xdigit:]]{1,4}){1,6}|[[:xdigit:]]{1,4}:(?::[[:xdigit:]]{1,4}){1,5}|(?:[[:xdigit:]]{1,4}:){2}(?::[[:xdigit:]]{1,4}){1,4}|(?:[[:xdigit:]]{1,4}:){3}(?::[[:xdigit:]]{1,4}){1,3}|(?:[[:xdigit:]]{1,4}:){4}(?::[[:xdigit:]]{1,4}){1,2}|(?:[[:xdigit:]]{1,4}:){5}:[[:xdigit:]]{1,4}|(?:[[:xdigit:]]{1,4}:){1,6}:)$`),
}

// A validator that checks if the string is an IP (version 4 or 6). If version is not provide, both versions "4" and "6" will be checked.
//
//        ok := validatorgo.IsIP("192.168.0.1", "4")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsIP("256.256.256.256", "4")
//        fmt.Println(ok) // false
func IsIP(str, version string) bool <span class="cov8" title="1">{
        if version == "" </span><span class="cov0" title="0">{
                version = "any"
        }</span>

        <span class="cov8" title="1">if version != "4" &amp;&amp; version != "6" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if version == "any" </span><span class="cov0" title="0">{
                for _, re := range ipVersionRegex </span><span class="cov0" title="0">{
                        matches := re.MatchString(str)
                        if matches </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        } else<span class="cov8" title="1"> {
                re := ipVersionRegex[version]
                return re.MatchString(str)
        }</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package validatorgo

import (
        "net"
        "strings"
)

// A validator that checks if the string is an IP Range (version 4 or 6). If version is not provide, both versions "4" and "6" will be checked.
//
//        ok := validatorgo.IsIP("192.168.0.0/24", "4")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsIP("192.168.0.0/33", "4")
//        fmt.Println(ok) // false
func IsIPRange(str, version string) bool <span class="cov8" title="1">{
        switch version </span>{
        case "4":<span class="cov8" title="1">
                return isValidIPv4Range(str)</span>
        case "6":<span class="cov8" title="1">
                return isValidIPv6Range(str)</span>
        case "":<span class="cov0" title="0">
                return isValidIPv4Range(str) || isValidIPv6Range(str)</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func isValidIPv4Range(str string) bool <span class="cov8" title="1">{
        if strings.Contains(str, "/") </span><span class="cov8" title="1">{
                return isValidCIDR(str, 32)
        }</span> else<span class="cov8" title="1"> if strings.Contains(str, "-") </span><span class="cov8" title="1">{
                return isValidDashSeparatedRange(str, "4")
        }</span>
        <span class="cov0" title="0">return false</span>
}

func isValidIPv6Range(str string) bool <span class="cov8" title="1">{
        if strings.Contains(str, "/") </span><span class="cov8" title="1">{
                return isValidCIDR(str, 128)
        }</span> else<span class="cov8" title="1"> if strings.Contains(str, "-") </span><span class="cov8" title="1">{
                return isValidDashSeparatedRange(str, "6")
        }</span>
        <span class="cov8" title="1">return false</span>
}

func isValidCIDR(str string, maxPrefixLength int) bool <span class="cov8" title="1">{
        _, ipNet, err := net.ParseCIDR(str)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">ones, bits := ipNet.Mask.Size()
        return bits == maxPrefixLength &amp;&amp; ones &gt;= 0 &amp;&amp; ones &lt;= maxPrefixLength</span>
}

func isValidDashSeparatedRange(str string, version string) bool <span class="cov8" title="1">{
        parts := strings.Split(str, "-")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">startIP := strings.TrimSpace(parts[0])
        endIP := strings.TrimSpace(parts[1])

        // Parse the start and end IPs
        start := net.ParseIP(startIP)
        end := net.ParseIP(endIP)

        // Ensure both IPs are valid and of the same version
        if start == nil || end == nil || !isSameIPVersion(start, end, version) </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check that start IP is less than or equal to end IP
        <span class="cov8" title="1">return isIPLessThanOrEqual(start, end)</span>
}

func isSameIPVersion(ip1, ip2 net.IP, version string) bool <span class="cov8" title="1">{
        if version == "4" </span><span class="cov8" title="1">{
                return ip1.To4() != nil &amp;&amp; ip2.To4() != nil
        }</span> else<span class="cov8" title="1"> if version == "6" </span><span class="cov8" title="1">{
                return ip1.To16() != nil &amp;&amp; ip2.To16() != nil &amp;&amp; ip1.To4() == nil &amp;&amp; ip2.To4() == nil
        }</span>
        <span class="cov0" title="0">return false</span>
}

func isIPLessThanOrEqual(start, end net.IP) bool <span class="cov8" title="1">{
        for i := range start </span><span class="cov8" title="1">{
                if start[i] &lt; end[i] </span><span class="cov8" title="1">{
                        return true
                }</span> else<span class="cov8" title="1"> if start[i] &gt; end[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package validatorgo

import (
        // "fmt"
        "strconv"
)

// A validator that checks if the string is an [ISBN].
//
// version: ISBN version to compare to. Accepted values are "10" and "13". If none provided, both will be tested.
//
//        ok := validatorgo.IsISBN("0-7167-0344-0", "10")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsISBN("0-7168-0344-0", "10")
//        fmt.Println(ok) // false
//
// [ISBN]: https://en.wikipedia.org/wiki/ISBN
func IsISBN(str, version string) bool <span class="cov8" title="1">{
        strNum := stripDashesAndSpaces(str)

        if version != "10" &amp;&amp; version != "13" &amp;&amp; version != "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if version == "10" </span><span class="cov8" title="1">{
                return valIsISBNv10(strNum)
        }</span> else<span class="cov8" title="1"> if version == "13" </span><span class="cov8" title="1">{
                return valIsISBNv13(strNum)
        }</span> else<span class="cov8" title="1"> {
                return valIsISBNv10(strNum) || valIsISBNv13(strNum)
        }</span>
}

func valIsISBNv10(str string) bool <span class="cov8" title="1">{
        len := len(str)
        sum := 0

        if len != 10 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for i, char := range str </span><span class="cov8" title="1">{
                pos := len - i
                num, err := strconv.Atoi(string(char))

                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">sum += pos * num</span>
        }

        <span class="cov8" title="1">rem := sum % 11

        return rem == 0</span>
}

func valIsISBNv13(str string) bool <span class="cov8" title="1">{
        len := len(str)
        sum := 0

        if len != 13 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for i, char := range str </span><span class="cov8" title="1">{
                pos := len - i
                num, err := strconv.Atoi(string(char))

                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">if pos%2 == 0 </span><span class="cov8" title="1">{
                        sum += 3 * num
                        // fmt.Printf("3 * %d\n", num)
                }</span> else<span class="cov8" title="1"> {
                        sum += 1 * num
                        // fmt.Printf("1 * %d\n", num)
                }</span>
        }

        // fmt.Println("Sum is", sum)

        <span class="cov8" title="1">rem := sum % 10

        return rem == 0</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package validatorgo

import "regexp"

var r = regexp.MustCompile(`^[A-Z]{2}[A-Z0-9]{9}\d$`)

var inc = [2][10]int{
        {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
        {0, 2, 4, 6, 8, 1, 3, 5, 7, 9},
}

// A validator that checks if the string is an [ISIN] (stock/security identifier).
//
//        ok := validatorgo.IsISIN("US0378331005")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsISIN("US0373831005")
//        fmt.Println(ok) // false
//
// [ISIN]: https://en.wikipedia.org/wiki/International_Securities_Identification_Number
func IsISIN(str string) bool <span class="cov8" title="1">{
        if !r.MatchString(str) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">var sum, p int
        for i := 10; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                p = 1 - p
                if d := str[i]; d &lt; 'A' </span><span class="cov8" title="1">{
                        sum += inc[p][d-'0']
                }</span> else<span class="cov8" title="1"> {
                        d -= 'A'
                        sum += inc[p][d%10]
                        p = 1 - p
                        sum += inc[p][d/10+1]
                }</span>
        }
        <span class="cov8" title="1">sum += int(str[11] - '0')
        return sum%10 == 0</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package validatorgo

var AllISO31661Alpha2 = [...]string{"AA", "AB", "AC", "AD", "AE", "AF", "AG", "AH", "AI", "AJ", "AK", "AL", "AM", "AN", "AO", "AP", "AQ", "AR", "AS", "AT",
        "AU", "AV", "AW", "AX", "AY", "AZ",
        "BA", "BB", "BC", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BK", "BL", "BM", "BN", "BO", "BP", "BQ", "BR", "BS", "BT", "BU", "BV", "BW", "BX", "BY", "BZ",
        "CA", "CB", "CC", "CD", "CE", "CF", "CG", "CH", "CI", "CJ", "CK", "CL", "CM", "CN", "CO", "CP", "CQ", "CR", "CS", "CT", "CU", "CV", "CW", "CX", "CY", "CZ",
        "DA", "DB", "DC", "DD", "DE", "DF", "DG", "DH", "DI", "DJ", "DK", "DL", "DM", "DN", "DO", "DP", "DQ", "DR", "DS", "DT", "DU", "DV", "DW", "DX", "DY", "DZ",
        "EA", "EB", "EC", "ED", "EE", "EF", "EG", "EH", "EI", "EJ", "EK", "EL", "EM", "EN", "EO", "EP", "EQ", "ER", "ES", "ET", "EU", "EV", "EW", "EX", "EY", "EZ",
        "FA", "FB", "FC", "FD", "FE", "FF", "FG", "FH", "FI", "FJ", "FK", "FL", "FM", "FN", "FO", "FP", "FQ", "FR", "FS", "FT", "FU", "FV", "FW", "FX", "FY", "FZ",
        "GA", "GB", "GC", "GD", "GE", "GF", "GG", "GH", "GI", "GJ", "GK", "GL", "GM", "GN", "GO", "GP", "GQ", "GR", "GS", "GT", "GU", "GV", "GW", "GX", "GY", "GZ",
        "HA", "HB", "HC", "HD", "HE", "HF", "HG", "HH", "HI", "HJ", "HK", "HL", "HM", "HN", "HO", "HP", "HQ", "HR", "HS", "HT", "HU", "HV", "HW", "HX", "HY", "HZ",
        "IA", "IB", "IC", "ID", "IE", "IF", "IG", "IH", "II", "IJ", "IK", "IL", "IM", "IN", "IO", "IP", "IQ", "IR", "IS", "IT", "IU", "IV", "IW", "IX", "IY", "IZ",
        "JA", "JB", "JC", "JD", "JE", "JF", "JG", "JH", "JI", "JJ", "JK", "JL", "JM", "JN", "JO", "JP", "JQ", "JR", "JS", "JT", "JU", "JV", "JW", "JX", "JY", "JZ",
        "KA", "KB", "KC", "KD", "KE", "KF", "KG", "KH", "KI", "KJ", "KK", "KL", "KM", "KN", "KO", "KP", "KQ", "KR", "KS", "KT", "KU", "KV", "KW", "KX", "KY", "KZ",
        "LA", "LB", "LC", "LD", "LE", "LF", "LG", "LH", "LI", "LJ", "LK", "LL", "LM", "LN", "LO", "LP", "LQ", "LR", "LS", "LT", "LU", "LV", "LW", "LX", "LY", "LZ",
        "MA", "MB", "MC", "MD", "ME", "MF", "MG", "MH", "MI", "MJ", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ",
        "NA", "NB", "NC", "ND", "NE", "NF", "NG", "NH", "NI", "NJ", "NK", "NL", "NM", "NN", "NO", "NP", "NQ", "NR", "NS", "NT", "NU", "NV", "NW", "NX", "NY", "NZ",
        "OA", "OB", "OC", "OD", "OE", "OF", "OG", "OH", "OI", "OJ", "OK", "OL", "OM", "ON", "OO", "OP", "OQ", "OR", "OS", "OT", "OU", "OV", "OW", "OX", "OY", "OZ",
        "PA", "PB", "PC", "PD", "PE", "PF", "PG", "PH", "PI", "PJ", "PK", "PL", "PM", "PN", "PO", "PP", "PQ", "PR", "PS", "PT", "PU", "PV", "PW", "PX", "PY", "PZ",
        "QA", "QB", "QC", "QD", "QE", "QF", "QG", "QH", "QI", "QJ", "QK", "QL", "QM", "QN", "QO", "QP", "QQ", "QR", "QS", "QT", "QU", "QV", "QW", "QX", "QY", "QZ",
        "RA", "RB", "RC", "RD", "RE", "RF", "RG", "RH", "RI", "RJ", "RK", "RL", "RM", "RN", "RO", "RP", "RQ", "RR", "RS", "RT", "RU", "RV", "RW", "RX", "RY", "RZ",
        "SA", "SB", "SC", "SD", "SE", "SF", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SP", "SQ", "SR", "SS", "ST", "SU", "SV", "SW", "SX", "SY", "SZ",
        "TA", "TB", "TC", "TD", "TE", "TF", "TG", "TH", "TI", "TJ", "TK", "TL", "TM", "TN", "TO", "TP", "TQ", "TR", "TS", "TT", "TU", "TV", "TW", "TX", "TY", "TZ",
        "UA", "UB", "UC", "UD", "UE", "UF", "UG", "UH", "UI", "UJ", "UK", "UL", "UM", "UN", "UO", "UP", "UQ", "UR", "US", "UT", "UU", "UV", "UW", "UX", "UY", "UZ",
        "VA", "VB", "VC", "VD", "VE", "VF", "VG", "VH", "VI", "VJ", "VK", "VL", "VM", "VN", "VO", "VP", "VQ", "VR", "VS", "VT", "VU", "VV", "VW", "VX", "VY", "VZ",
        "WA", "WB", "WC", "WD", "WE", "WF", "WG", "WH", "WI", "WJ", "WK", "WL", "WM", "WN", "WO", "WP", "WQ", "WR", "WS", "WT", "WU", "WV", "WW", "WX", "WY", "WZ",
        "XA", "XB", "XC", "XD", "XE", "XF", "XG", "XH", "XI", "XJ", "XK", "XL", "XM", "XN", "XO", "XP", "XQ", "XR", "XS", "XT", "XU", "XV", "XW", "XX", "XY", "XZ",
        "YA", "YB", "YC", "YD", "YE", "YF", "YG", "YH", "YI", "YJ", "YK", "YL", "YM", "YN", "YO", "YP", "YQ", "YR", "YS", "YT", "YU", "YV", "YW", "YX", "YY", "YZ",
        "ZA", "ZB", "ZC", "ZD", "ZE", "ZF", "ZG", "ZH", "ZI", "ZJ", "ZK", "ZL", "ZM", "ZN", "ZO", "ZP", "ZQ", "ZR", "ZS", "ZT", "ZU", "ZV", "ZW", "ZX", "ZY", "ZZ",
}

// A validator that checks if the string is a valid [ISO 3166-1 alpha-2] officially assigned country code.
//
//        ok := validatorgo.IsISO31661Alpha2("EN")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsISO31661Alpha2("eng")
//        fmt.Println(ok) // false
//
// [ISO 3166-1 alpha-2]: https://en.wikipedia.org/wiki/ISO_4217
func IsISO31661Alpha2(str string) bool <span class="cov8" title="1">{
        return IsIn(str, AllISO31661Alpha2[:])
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package validatorgo

var AllISO31661Alpha3 = [...]string{"AFG", "ALB", "DZA", "ASM", "AND", "AGO", "AIA", "ATA", "ATG", "ARG", "ARM", "ABW", "AUS", "AUT", "AZE",
        "BHS", "BHR", "BGD", "BRB", "BLR", "BEL", "BLZ", "BEN", "BMU", "BTN", "BOL", "BIH", "BWA", "BVT", "BRA",
        "IOT", "BRN", "BGR", "BFA", "BDI", "CPV", "KHM", "CMR", "CAN", "CYM", "CAF", "TCD", "CHL", "CHN", "CXR",
        "CCK", "COL", "COM", "COG", "COD", "COK", "CRI", "CIV", "HRV", "CUB", "CUW", "CYP", "CZE", "DNK", "DJI",
        "DMA", "DOM", "ECU", "EGY", "SLV", "GNQ", "ERI", "EST", "SWZ", "ETH", "FLK", "FRO", "FJI", "FIN", "FRA",
        "GUF", "PYF", "ATF", "GAB", "GMB", "GEO", "DEU", "GHA", "GIB", "GRC", "GRL", "GRD", "GLP", "GUM", "GTM",
        "GGY", "GIN", "GNB", "GUY", "HTI", "HMD", "VAT", "HND", "HKG", "HUN", "ISL", "IND", "IDN", "IRN", "IRQ",
        "IRL", "IMN", "ISR", "ITA", "JAM", "JPN", "JEY", "JOR", "KAZ", "KEN", "KIR", "PRK", "KOR", "KWT", "KGZ",
        "LAO", "LVA", "LBN", "LSO", "LBR", "LBY", "LIE", "LTU", "LUX", "MAC", "MDG", "MWI", "MYS", "MDV", "MLI",
        "MLT", "MHL", "MTQ", "MRT", "MUS", "MYT", "MEX", "FSM", "MDA", "MCO", "MNG", "MNE", "MSR", "MAR", "MOZ",
        "MMR", "NAM", "NRU", "NPL", "NLD", "NCL", "NZL", "NIC", "NER", "NGA", "NIU", "NFK", "MKD", "MNP", "NOR",
        "OMN", "PAK", "PLW", "PAN", "PNG", "PRY", "PER", "PHL", "PCN", "POL", "PRT", "PRI", "QAT", "MKD", "ROU",
        "RUS", "RWA", "REU", "BLM", "SHN", "KNA", "LCA", "MAF", "SPM", "VCT", "WSM", "SMR", "STP", "SAU", "SEN",
        "SRB", "SYC", "SLE", "SGP", "SXM", "SVK", "SVN", "SLB", "SOM", "ZAF", "SGS", "SSD", "ESP", "LKA", "SDN",
        "SUR", "SWE", "CHE", "SYR", "TWN", "TJK", "TZA", "THA", "TLS", "TGO", "TKL", "TON", "TTO", "TUN", "TUR",
        "TKM", "TCA", "TUV", "UGA", "UKR", "ARE", "GBR", "USA", "URY", "UZB", "VUT", "VEN", "VNM", "WLF", "ESH",
        "YEM", "ZMB", "ZWE",
}

// A validator that checks if the string is a valid ISO 3166-1 alpha-3 officially assigned country code.
//
//        ok := validatorgo.IsISO31661Alpha3("ABW")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsISO31661Alpha3("ES")
//        fmt.Println(ok) // false
//
// [ISO 3166-1 alpha-3]: https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3
func IsISO31661Alpha3(str string) bool <span class="cov8" title="1">{
        return IsIn(str, AllISO31661Alpha3[:])
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package validatorgo

var AllISO31661Numeric = [...]string{"004", "008", "010", "012", "016", "020", "024", "028", "031", "032", "036", "040", "044", "048", "050", "051", "052", "056", "060", "064", "068", "070", "072", "074", "076", "084", "086", "090", "092", "096", "100", "104", "108", "112", "116", "120", "124", "132", "136", "140", "144", "148", "150", "154", "156", "158", "162", "166", "170", "174", "175", "178", "180", "184", "188", "192", "196", "200", "204", "208", "212", "214", "218", "222", "226", "231", "232", "233", "234", "236", "240", "244", "248", "250", "254", "258", "260", "262", "266", "268", "270", "275", "276", "288", "292", "296", "300", "304", "308", "312", "316", "320", "324", "328", "332", "334", "336", "340", "344", "348", "352", "356", "360", "364", "368", "372", "376", "380", "384", "388", "392", "398", "400", "404", "408", "410", "414", "417", "418", "422", "426", "428", "430", "434", "438", "440", "442", "446", "450", "454", "458", "462", "466", "470", "474", "478", "480", "484", "492", "496", "498", "499", "500", "504", "508", "512", "516", "520", "524", "528", "531", "533", "534", "536", "540", "548", "552", "556", "562", "566", "570", "574", "578", "580", "581", "583", "584", "585", "586", "591", "598", "600", "604", "608", "612", "616", "620", "624", "626", "630", "634", "638", "642", "643", "646", "652", "654", "659", "660", "662", "663", "666", "670", "674", "678", "682", "686", "688", "690", "694", "702", "703", "704", "705", "706", "710", "716", "724", "728", "729", "732", "740", "744", "748", "750", "754", "758", "760", "762", "764", "768", "772", "776", "780", "784", "788", "792", "795", "796", "798", "800", "804", "808", "812", "816", "818", "826", "831", "832", "833", "834", "840", "850", "854", "858", "860", "862", "876", "882", "887", "894"}

// A validator that checks check if the string is a valid [ISO 3166-1] numeric officially assigned country code.
//
//        ok := validatorgo.IsISO31661Numeric("032")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsISO31661Numeric("56")
//        fmt.Println(ok) // false
//
// [ISO 3166-1]: https://en.wikipedia.org/wiki/ISO_3166-1_numeric
func IsISO31661Numeric(str string) bool <span class="cov8" title="1">{
        return IsIn(str, AllISO31661Numeric[:])
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package validatorgo

var AllISO4217Codes = [...]string{
        "AED", "AFN", "ALL", "AMD", "ANG", "AOA", "ARS", "AUD", "AWG", "AZN",
        "BAM", "BBD", "BDT", "BGN", "BHD", "BIF", "BMD", "BND", "BOB", "BOV",
        "BRL", "BSD", "BTN", "BWP", "BYN", "BZD", "CAD", "CDF", "CHE", "CHF",
        "CHW", "CLF", "CLP", "CNY", "COP", "COU", "CRC", "CUC", "CUP", "CVE",
        "CZK", "DJF", "DKK", "DOP", "DZD", "EGP", "ERN", "ETB", "EUR", "FJD",
        "FKP", "FOK", "GBP", "GEL", "GGP", "GHS", "GIP", "GMD", "GNF", "GTQ",
        "GYD", "HKD", "HNL", "HRK", "HTG", "HUF", "IDR", "ILS", "IMP", "INR",
        "IQD", "IRR", "ISK", "JMD", "JOD", "JPY", "KES", "KGS", "KHR", "KID",
        "KMF", "KPW", "KRW", "KWD", "KYD", "KZT", "LAK", "LBP", "LKR", "LRD",
        "LSL", "LYD", "MAD", "MDL", "MGA", "MKD", "MMK", "MNT", "MOP", "MRU",
        "MUR", "MVR", "MWK", "MXN", "MXV", "MYR", "MZN", "NAD", "NGN", "NIO",
        "NOK", "NPR", "NZD", "OMR", "PAB", "PEN", "PGK", "PHP", "PKR", "PLN",
        "PYG", "QAR", "RON", "RSD", "RUB", "RWF", "SAR", "SBD", "SCR", "SDG",
        "SEK", "SGD", "SHP", "SLL", "SOS", "SRD", "SSP", "STN", "SVC", "SYP",
        "SZL", "THB", "TJS", "TMT", "TND", "TOP", "TRY", "TTD", "TVD", "TWD",
        "TZS", "UAH", "UGX", "USD", "USN", "UYI", "UYU", "UYW", "UZS", "VED",
        "VES", "VND", "VUV", "WST", "XAF", "XAG", "XAU", "XBA", "XBB", "XBC",
        "XBD", "XCD", "XDR", "XOF", "XPD", "XPF", "XPT", "XSU", "XTS", "XUA",
        "YER", "ZAR", "ZMW", "ZWL",
}

// A validator that checks if the string is a valid [ISO 4217] officially assigned currency code.
//
//        ok := validatorgo.IsIso4217("AED")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsIso4217("AE")
//        fmt.Println(ok) // false
//
// [ISO 4217]: https://en.wikipedia.org/wiki/ISO_4217
func IsIso4217(str string) bool <span class="cov8" title="1">{
        return IsIn(str, AllISO4217Codes[:])
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package validatorgo

import (
        "math"
        "regexp"
        "strconv"
)

// iso6346numValues is the set of alphabets and their iso6346 numerical values
var iso6346numValues = map[string]int{
        "A": 10, "B": 12, "C": 13, "D": 14, "E": 15, "F": 16, "G": 17, "H": 18, "I": 19, "J": 20, "K": 21, "L": 23, "M": 24,
        "N": 25, "O": 26, "P": 27, "Q": 28, "R": 29, "S": 30, "T": 31, "U": 32, "V": 34, "W": 35, "X": 36, "Y": 37, "Z": 38,
        "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9,
}

// A validator that checks if the string is a valid ISO 6346 shipping container identification.
//
//        ok := validatorgo.IsISO6346("CSQU3054383")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsISO6346("CSQX3054383")
//        fmt.Println(ok) // false
//
// [ISO 6346]: https://en.wikipedia.org/wiki/ISO_6346
func IsISO6346(str string) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(`^([A-Z]{3})([UJZR])(\d{6})(\d)$`)
        capGrps := re.FindStringSubmatch(str)
        if capGrps == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">checkDig := capGrps[4]
        len := len(str)
        sum := 0
        for ind, char := range str </span><span class="cov8" title="1">{
                if len-1 == ind </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">numVal, ok := iso6346numValues[string(char)]

                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">sum += int(float64(numVal) * math.Pow(2.00, float64(ind)))</span>
        }

        <span class="cov8" title="1">rem := sum % 11
        remStr := strconv.Itoa(rem)

        return remStr == checkDig</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package validatorgo

var AllISO6391Codes = [...]string{"aa", "ab", "af", "ak", "am", "an", "ar", "as", "av", "ay", "az", "ba", "be", "bg", "bh", "bi", "bm", "bn", "bo", "br", "bs", "ca", "ce", "ch", "co", "cr", "cs", "cv", "cy", "da", "de", "dv", "dz", "ee", "el", "en", "es", "et", "eu", "fa", "ff", "fi", "fj", "fo", "fr", "fy", "ga", "gd", "gl", "gn", "gu", "gv", "ha", "he", "hi", "ho", "hr", "ht", "hu", "hy", "hz", "id", "ig", "ii", "ik", "io", "is", "it", "iu", "ja", "jv", "ka", "kg", "ki", "kj", "kk", "kl", "km", "kn", "ko", "kr", "ks", "ku", "kv", "kw", "ky", "lb", "lg", "li", "ln", "lo", "lt", "lu", "lv", "mg", "mh", "mi", "mk", "ml", "mn", "mr", "ms", "mt", "my", "na", "nb", "nd", "ne", "ng", "nl", "nn", "no", "nr", "nv", "ny", "oc", "oj", "om", "or", "os", "pa", "pl", "ps", "pt", "qu", "rm", "rn", "ro", "ru", "rw", "sa", "sc", "sd", "se", "sg", "si", "sk", "sl", "sm", "sn", "so", "sq", "sr", "ss", "st", "su", "sv", "sw", "ta", "te", "tg", "th", "ti", "tk", "tl", "tn", "to", "tr", "ts", "tt", "tw", "ty", "ug", "uk", "ur", "uz", "ve", "vi", "wa", "wo", "xh", "yi", "yo", "za", "zh", "zu"}

// A validator that checks if the string is a valid [ISO 639-1] language code.
//
//        ok := validatorgo.IsISO6391("en")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsISO6391("eng")
//        fmt.Println(ok) // false
//
// [ISO 639-1]: https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
func IsISO6391(str string) bool <span class="cov8" title="1">{
        return IsIn(str, AllISO6391Codes[:])
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package validatorgo

import (
        "regexp"
)

// IsISO8601Opts is used to configure IsISO8601
type IsISO8601Opts struct {
        Strict          bool // must be a date that has actually happened, is happening or will happen.
        StrictSeparator bool // must be delimited by T
}

// A validator that checks if the string is a valid [ISO 8601] date.
//
// IsISO8601Opts is a struct which defaults to { Strict: false, StrictSeparator: false }.
//
// If Strict is true, date strings with invalid dates like 2009-02-29 will be invalid.
//
// If StrictSeparator is true, date strings with date and time separated by anything other than a T will be invalid.
//
//        ok := validatorgo.IsISO8601("2023-09-05", validatorgo.IsISO8601Opts{})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsISO8601("2023-13-05T14:30:00", validatorgo.IsISO8601Opts{})
//        fmt.Println(ok) // false
//
// [ISO 8601]: https://en.wikipedia.org/wiki/ISO_8601
func IsISO8601(str string, opts IsISO8601Opts) bool <span class="cov8" title="1">{
        var re *regexp.Regexp

        if opts.StrictSeparator </span><span class="cov8" title="1">{
                re = regexp.MustCompile(`^(\d{4})(-(0[1-9]|1[0-2])(-([12]\d|0[1-9]|3[01]))([T\s]((([01]\d|2[0-3])((:)[0-5]\d))([\:]\d+)?)?(:[0-5]\d([\.]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)$`)
        }</span> else<span class="cov8" title="1"> {
                re = regexp.MustCompile(`^(\d{4})([-\/\. ](0[1-9]|1[0-2])([-\/\. ]([12]\d|0[1-9]|3[01]))([T\s]((([01]\d|2[0-3])([: \.])[0-5]\d)(([: \.])\d+)?([: \.][0-5]\d([\.]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3])[: \.]?([0-5]\d)?)?)?)?)$`)
        }</span>

        <span class="cov8" title="1">capGrps := re.FindStringSubmatch(str)

        if capGrps == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if opts.Strict </span><span class="cov8" title="1">{
                year, month, day := capGrps[1], capGrps[3], capGrps[5]

                return validYearMonthDay(year, month, day)
        }</span>

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package validatorgo

import (
        "fmt"
        "regexp"
)

// A validator that checks if the string is an [ISRC].
//
// allowHyphens will allow codes with dashes present CC-XXX-YY-NNNNN
//
//        ok := validatorgo.IsISRC("AASKG1912345", false)
//        fmt.Println(ok) // true
//        ok := validatorgo.IsISRC("AA-SKG-19-12345", false)
//        fmt.Println(ok) // false
//
// [ISRC]: https://en.wikipedia.org/wiki/International_Standard_Recording_Code
func IsISRC(str string, allowHyphens bool) bool <span class="cov8" title="1">{
        var char string

        if allowHyphens </span><span class="cov8" title="1">{
                char = "-?"
        }</span>

        <span class="cov8" title="1">re := regexp.MustCompile(fmt.Sprintf(`^([A-Z]{2})%s([A-Z]{3})%s(\d{2})%s(\d{5})$`, char, char, char))
        capGrp := re.FindStringSubmatch(str)

        if capGrp == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">cntryCode := capGrp[1]

        return IsISO31661Alpha2(cntryCode)</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package validatorgo

import (
        "fmt"
        "regexp"
        "strconv"
)

// IsISSNOpts is used to configure IsISSN
type IsISSNOpts struct {
        RequireHyphen bool // requires a hyphen
        CaseSensitive bool // must be exact case
}

// A validator that checks if the string is an [ISSN].
//
// IsISSNOpts is a struct which defaults to { CaseSensitive: false, RequireHyphen: false }.
//
// If CaseSensitive is true, ISSNs with a lowercase "x" as the check digit are rejected.
//
//        ok := validatorgo.IsISSN("0378-5955", validatorgo.IsISSNOpts{})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsISSN("1234567", validatorgo.IsISSNOpts{})
//        fmt.Println(ok) // false
//
// [ISSN]: https://en.wikipedia.org/wiki/International_Standard_Serial_Number
func IsISSN(str string, opts IsISSNOpts) bool <span class="cov8" title="1">{
        var reqHypStr string
        if !opts.RequireHyphen </span><span class="cov8" title="1">{
                reqHypStr = "?"
        }</span>

        <span class="cov8" title="1">var reqCasSenStr string
        if !opts.CaseSensitive </span><span class="cov8" title="1">{
                reqCasSenStr = "x"
        }</span>

        <span class="cov8" title="1">re := regexp.MustCompile(fmt.Sprintf(`^[0-9]{4}-%s[0-9]{3}[0-9X%s]$`, reqHypStr, reqCasSenStr))
        capGrp := re.FindStringSubmatch(str)

        if capGrp == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">strWithoutDashes := stripDashesAndSpaces(str)
        len := len(strWithoutDashes)

        sum := 0
        checkVal := ""
        for ind, char := range strWithoutDashes </span><span class="cov8" title="1">{
                charVal := string(char)

                if len-1 == ind </span><span class="cov8" title="1">{
                        checkVal = charVal
                        break</span>
                }

                <span class="cov8" title="1">pos := len - ind
                charInt, err := strconv.Atoi(charVal)

                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                // fmt.Printf("%d x %d\n", charInt, pos)
                <span class="cov8" title="1">sum += pos * charInt</span>
        }

        // fmt.Printf("Sum: %d\n", sum)

        <span class="cov8" title="1">checkValIsNotX := checkVal != "X" &amp;&amp; checkVal != "x"
        checkDig, err := strconv.Atoi(checkVal)

        if checkValIsNotX &amp;&amp; err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">rem := sum % 11

        if rem == 0 </span><span class="cov8" title="1">{
                // fmt.Printf("There is no rem and check digit: %d", checkDig)
                return checkDig == 0
        }</span>

        <span class="cov8" title="1">remSub11 := 11 - rem

        if remSub11 &lt; 10 </span><span class="cov8" title="1">{
                // fmt.Printf("rem sub is less than 10 check digit: %d, remSub: %d\n", checkDig, remSub11)
                return remSub11 == checkDig
        }</span>

        // fmt.Printf("rem sub is greater than 10 check val: %s", checkVal)
        <span class="cov8" title="1">return checkVal == "X" || checkVal == "x"</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package validatorgo

import "encoding/json"

// type IsJSONOpts struct {
// AllowPrimitives bool
// }

// A validator that checks if the string is valid JSON (note: uses json.Valid()).
//
//        ok := validatorgo.IsJSON(`{"name": "John", "age": 30, "city": "New York"}`)
//        fmt.Println(ok) // true
//        ok := validatorgo.IsJSON(`{'name': 'John', 'age': 30}`)
//        fmt.Println(ok) // false
func IsJSON(str string) bool <span class="cov8" title="1">{
        return json.Valid([]byte(str))
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package validatorgo

import (
        "encoding/base64"
        "regexp"
)

// A validator that checks if the string is valid JWT token.
//
//        ok := validatorgo.IsJWT("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsJWT("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c")
//        fmt.Println(ok) // false
func IsJWT(str string) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(`^([a-zA-Z0-9_=]+)\.([a-zA-Z0-9_=]+)\.([a-zA-Z0-9_\-\+\/=]*)`)
        capGrp := re.FindStringSubmatch(str)

        if capGrp == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">payload := capGrp[2]

        rawDecodedTxt, err := base64.RawURLEncoding.DecodeString(payload)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">jsonDecodedTxt := string(rawDecodedTxt)

        return IsJSON(jsonDecodedTxt)</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package validatorgo

import (
        "regexp"
)

// IsLatLongOpts is used to configure IsLatLong
type IsLatLongOpts struct {
        CheckDMS bool // checks DMS(degrees, minutes, and seconds)
}

// A validator that checks if the string is a valid latitude-longitude coordinate in the format lat,long or lat, long.
//
// IsLatLongOpts is a struct that defaults to { CheckDMS: false }.
//
// Pass CheckDMS as true to validate DMS(degrees, minutes, and seconds) latitude-longitude format.
//
//        ok := validatorgo.IsLatLong("40.730610,-73.935242" , validatorgo.IsLatLongOpts{})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsLatLong("91,181" , validatorgo.IsLatLongOpts{})
//        fmt.Println(ok) // false
func IsLatLong(str string, opts IsLatLongOpts) bool <span class="cov8" title="1">{
        var re *regexp.Regexp
        if opts.CheckDMS </span><span class="cov8" title="1">{
                re = regexp.MustCompile(`^([+\-]?[0-8]?\d|90)[°˚º\s-]+([0-5]?\d)['′\s-]+([0-5]?\d(\.\d*)?)["¨˝\s-]*([NnSs])[\s,]+([+\-]?(0?\d?\d|1[0-7]\d|180))[°˚º\s-]+([0-5]?\d)['′\s-]+([0-5]?\d(\.\d*)?)["¨˝\s-]*([EeWw])$`)
                return re.MatchString(str)
        }</span> else<span class="cov8" title="1"> {
                re = regexp.MustCompile(`^[-+]?([1-8]?\d(\.\d+)?|90(\.0+)?),\s*[-+]?(180(\.0+)?|((1[0-7]\d)|([1-9]?\d))(\.\d+)?)$`)
                return re.MatchString(str)
        }</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package validatorgo

import (
        "unicode/utf8"
)

// IsLengthOpts is used to configure IsLength
type IsLengthOpts struct {
        Min uint // Minimum character length
        Max *uint // Maximum character length
}

// A validator that checks if the string's length falls in a range.
//
// IsLengthOpts is a struct which defaults to { Min: 0, Max: nil }.
//
// Note: this function takes into account surrogate pairs.
//
//        ok := validatorgo.IsLength("hello", validatorgo.IsLengthOpts{Min: 3})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsLength("hi", validatorgo.IsLengthOpts{Min: 3})
//        fmt.Println(ok) // false
func IsLength(str string, opts IsLengthOpts) bool <span class="cov8" title="1">{
        len := uint(utf8.RuneCountInString(str))

        withinLimits := true

        if opts.Max != nil </span><span class="cov8" title="1">{
                isMax := *(opts.Max) &gt;= len
                withinLimits = withinLimits &amp;&amp; isMax
        }</span>

        <span class="cov8" title="1">isMin := opts.Min &lt;= len
        withinLimits = withinLimits &amp;&amp; isMin

        return withinLimits</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package validatorgo

import "regexp"

var localeLicensePlateRegex = map[string]*regexp.Regexp{
        "cs-CZ": regexp.MustCompile(`/^(([ABCDEFHKIJKLMNPRSTUVXYZ]|[0-9])-?){5,8}$/g`),
}

// (NOT IMPLEMENTED, DO NOT USE) A validator that checks if the string matches the format of a country's license plate.
//
// locale is one of 'cs-CZ', 'de-DE', 'de-LI', 'en-IN', 'en-SG', 'en-PK', 'es-AR', 'hu-HU', 'pt-BR', 'pt-PT', 'sq-AL', 'sv-SE', 'any'.
func IsLicensePlate(str string, locale string) bool <span class="cov0" title="0">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package validatorgo

var AllLocales = [...]string{"ar_AE", "ar_BH", "ar_DJ", "ar_DZ", "ar_EG", "ar_EH", "ar_ER", "ar_IL", "ar_IQ", "ar_JO", "ar_KM", "ar_KW", "ar_LB", "ar_LY", "ar_MA", "ar_MR", "ar_OM", "ar_PS", "ar_QA", "ar_SA", "ar_SD", "ar_SO", "ar_SS", "ar_SY", "ar_TD", "ar_TN", "ar_YE", "as_IN", "asa_TZ", "az_Cyrl_AZ", "az_Latn_AZ", "bas_CM", "be_BY", "bem_ZM", "bez_TZ", "bg_BG", "bm_ML", "bn_BD", "bn_IN", "bo_CN", "bo_IN", "br_FR", "brx_IN", "bs_Cyrl_BA", "bs_Latn_BA", "ca_AD", "ca_ES", "ca_FR", "ca_IT", "ce_RU", "cgg_UG", "chr_US", "cs_CZ", "cy_GB", "da_DK", "dav_KE", "de_AT", "de_BE", "de_CH", "de_DE", "de_IT", "de_LI", "de_LU", "dje_NE", "dsb_DE", "dua_CM", "dyo_SN", "dz_BT", "ebu_KE", "ee_GH", "ee_TG", "el_CY", "el_GR", "en_AG", "en_AI", "en_AS", "en_AT", "en_AU", "en_BB", "en_BE", "en_BI", "en_BM", "en_BS", "en_BW", "en_BZ", "en_CA", "en_CC", "en_CH", "en_CK", "en_CM", "en_CX", "en_CY", "en_DE", "en_DG", "en_DK", "en_DM", "en_ER", "en_FI", "en_FJ", "en_FK", "en_FM", "en_GB", "en_GD", "en_GG", "en_GH", "en_GI", "en_GM", "en_GU", "en_GY", "en_HK", "en_IE", "en_IL", "en_IM", "en_IN", "en_IO", "en_JE", "en_JM", "en_KE", "en_KI", "en_KN", "en_KY", "en_LC", "en_LR", "en_LS", "en_MG", "en_MH", "en_MO", "en_MP", "en_MS", "en_MT", "en_MU", "en_MW", "en_MY", "en_NA", "en_NF", "en_NG", "en_NL", "en_NR", "en_NU", "en_NZ", "en_PG", "en_PH", "en_PK", "en_PN", "en_PR", "en_PW", "en_RW", "en_SB", "en_SC", "en_SD", "en_SE", "en_SG", "en_SH", "en_SI", "en_SL", "en_SS", "en_SX", "en_SZ", "en_TC", "en_TK", "en_TO", "en_TT", "en_TV", "en_TZ", "en_UG", "en_UM", "en_US", "en_VC", "en_VG", "en_VI", "en_VU", "en_WS", "en_ZA", "en_ZM", "en_ZW", "eo", "es_AR", "es_BO", "es_BR", "es_BZ", "es_CL", "es_CO", "es_CR", "es_CU", "es_DO", "es_EA", "es_EC", "es_ES", "es_GQ", "es_GT", "es_HN", "es_IC", "es_MX", "es_NI", "es_PA", "es_PE", "es_PR", "es_PY", "es_SV", "es_US", "es_UY", "es_VE", "et_EE", "eu_ES", "ewo_CM", "fa_AF", "fa_IR", "ff_CM", "ff_GN", "ff_MR", "ff_SN", "fi_FI", "fil_PH", "fo_DK", "fo_FO", "fr_BE", "fr_BF", "fr_BI", "fr_BJ", "fr_BL", "fr_CA", "fr_CD", "fr_CF", "fr_CG", "fr_CH", "fr_CI", "fr_CM", "fr_DJ", "fr_DZ", "fr_FR", "fr_GA", "fr_GF", "fr_GN", "fr_GP", "fr_GQ", "fr_HT", "fr_KM", "fr_LU", "fr_MA", "fr_MC", "fr_MF", "fr_MG", "fr_ML", "fr_MQ", "fr_MR", "fr_MU", "fr_NC", "fr_NE", "fr_PF", "fr_PM", "fr_RE", "fr_RW", "fr_SC", "fr_SN", "fr_SY", "fr_TD", "fr_TG", "fr_TN", "fr_VU", "fr_WF", "fr_YT", "fur_IT", "fy_NL", "ga_IE", "gd_GB", "gl_ES", "gsw_CH", "gsw_FR", "gsw_LI", "gu_IN", "guz_KE", "gv_IM", "ha_GH", "ha_NE", "ha_NG", "haw_US", "he_IL", "hi_IN", "hr_BA", "hr_HR", "hsb_DE", "hu_HU", "hy_AM", "ig_NG", "ii_CN", "is_IS", "it_CH", "it_IT", "it_SM", "iu_CA", "ja_JP", "jgo_CM", "jmc_TZ", "ka_GE", "kab_DZ", "kam_KE", "kde_TZ", "kea_CV", "khq_ML", "ki_KE", "kk_KZ", "kkj_CM", "kl_GL", "kln_KE", "km_KH", "kn_IN", "ko_KP", "ko_KR", "kok_IN", "ks_IN", "ksb_TZ", "ksf_CM", "ksh_DE", "kw_GB", "ky_KG", "lag_TZ", "lb_LU", "lg_UG", "lkt_US", "ln_AO", "ln_CD", "ln_CF", "ln_CG", "lo_LA", "lrc_IQ", "lrc_IR", "lt_LT", "lu_CD", "luo_KE", "luy_KE", "lv_LV", "mas_KE", "mas_TZ", "mer_KE", "mfe_MU", "mg_MG", "mgh_MZ", "mgo_CM", "mi_NZ", "mk_MK", "ml_IN", "mn_MN", "mr_IN", "ms_BN", "ms_MY", "ms_SG", "mt_MT", "mua_CM", "my_MM", "mzn_IR", "naq_NA", "nb_NO", "nd_ZW", "nds_DE", "nds_NL", "ne_IN", "ne_NP", "nl_AW", "nl_BE", "nl_BQ", "nl_CW", "nl_NL", "nl_SR", "nl_SX", "nmg_CM", "nn_NO", "nnh_CM", "nus_SS", "nyn_UG", "om_ET", "om_KE", "or_IN", "os_GE", "os_RU", "pa_Arab_PK", "pa_Guru_IN", "pl_PL", "ps_AF", "pt_AO", "pt_BR", "pt_CH", "pt_CV", "pt_GQ", "pt_GW", "pt_LU", "pt_MO", "pt_MZ", "pt_PT", "pt_ST", "pt_TL", "qu_BO", "qu_EC", "qu_PE", "rm_CH", "rn_BI", "ro_MD", "ro_RO", "rof_TZ", "ru_BY", "ru_KG", "ru_KZ", "ru_MD", "ru_RU", "ru_UA", "rw_RW", "rwk_TZ", "sah_RU", "saq_KE", "sbp_TZ", "se_FI", "se_NO", "se_SE", "seh_MZ", "ses_ML", "sg_CF", "shi_Latn_MA", "shi_Tfng_MA", "si_LK", "sk_SK", "sl_SI", "smn_FI", "sn_ZW", "so_DJ", "so_ET", "so_KE", "so_SO", "sq_AL", "sq_MK", "sq_XK", "sr_Cyrl_BA", "sr_Cyrl_ME", "sr_Cyrl_RS", "sr_Cyrl_XK", "sr_Latn_BA", "sr_Latn_ME", "sr_Latn_RS", "sr_Latn_XK", "sv_AX", "sv_FI", "sv_SE", "sw_CD", "sw_KE", "sw_TZ", "sw_UG", "ta_IN", "ta_LK", "ta_MY", "ta_SG", "te_IN", "teo_KE", "teo_UG", "th_TH", "ti_ER", "ti_ET", "tk_TM", "to_TO", "tr_CY", "tr_TR", "tt_RU", "twq_NE", "tzm_MA", "ug_CN", "uk_UA", "ur_IN", "ur_PK", "uz_Arab_AF", "uz_Cyrl_UZ", "uz_Latn_UZ", "vai_Latn_LR", "vai_Vaii_LR", "vi_VN", "vo_001", "vun_TZ", "wae_CH", "wo_SN", "xh_ZA", "xog_UG", "yav_CM", "yi_001", "yo_BJ", "yo_NG", "yue_Hans_CN", "yue_Hant_HK", "zgh_MA", "zh_CN", "zh_HK", "zh_MO", "zh_SG", "zh_TW", "zu_ZA"}

// A validator that checks if the string is a locale.
//
//        ok := validatorgo.IsLocale("ca_ES")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsLocale("en_XY")
//        fmt.Println(ok) // false
func IsLocale(str string) bool <span class="cov8" title="1">{
        return IsIn(str, AllLocales[:])
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package validatorgo

// import "strings"

// A validator that checks if the string is lowercase.
//
//        ok := validatorgo.IsLowerCase("hello")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsLowerCase("WORLD")
//        fmt.Println(ok) // false
func IsLowerCase(str string) bool <span class="cov8" title="1">{
        // return str == strings.ToLower(str)
        return false // need to think about special characters
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package validatorgo

import "strconv"

// A validator that checks if the string passes the [Luhn algorithm] check.
//
//        ok := validatorgo.IsLuhnNumber("4532015112830366")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsLuhnNumber("4532015112830367")
//        fmt.Println(ok) // false
//
// [Luhn algorithm]: https://en.wikipedia.org/wiki/Luhn_algorithm
func IsLuhnNumber(str string) bool <span class="cov8" title="1">{
        var (
                len      = len(str)
                sum      = 0
                isSecond = false
        )

        for i := len - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                char := str[i]
                d, err := strconv.Atoi(string(char))

                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">if isSecond </span><span class="cov8" title="1">{
                        d = d * 2
                        if d &gt; 9 </span><span class="cov8" title="1">{
                                d = digitSum(d)
                        }</span>
                }

                <span class="cov8" title="1">sum += d
                isSecond = !isSecond</span>
        }

        <span class="cov8" title="1">return sum%10 == 0</span>
}</pre>
		
		<pre class="file" id="file61" style="display: none">package validatorgo

import (
        "fmt"
        "regexp"
)

// IsMacAddressOpts is used to configure IsMacAddress
type IsMacAddressOpts struct {
        NoSeparators bool    // will not allow separators
        Type         *string // mac address type
}

var (
        EUIType48 = "48"
        EUIType64 = "64"
)

// A validator that checks if the string is a MAC address.
//
// IsMacAddressOpts is a struct which defaults to { NoSeparators: false, Type: nil }.
//
// If NoSeparators is true, the validator will allow MAC addresses without separators.
//
// Also, it allows the use of hyphens, spaces or dots e.g. "01 02 03 04 05 ab", "01-02-03-04-05-ab" or "0102.0304.05ab".
//
// The IsMacAddressOpts also allow a eui property to specify if it needs to be validated against EUI-48 or EUI-64.
//
// The accepted values of eui are: "48", "64". I have exported EUIType48 and EUIType64. Defaults to "48" if none is passed.
//
//        ok := validatorgo.IsMacAddress("00:1A:2B:3C:4D:5E",  validatorgo.IsMacAddressOpts{})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsMacAddress("00:1A:2B:3C:4D:ZZ",  validatorgo.IsMacAddressOpts{})
//        fmt.Println(ok) // false
func IsMacAddress(str string, opts IsMacAddressOpts) bool <span class="cov8" title="1">{

        noSepReStr := `[\s:.-]?`
        if opts.NoSeparators </span><span class="cov8" title="1">{
                noSepReStr = ""
        }</span>

        <span class="cov8" title="1">if opts.Type == nil </span><span class="cov8" title="1">{
                opts.Type = &amp;EUIType48
        }</span> else<span class="cov8" title="1"> {
                if *opts.Type != EUIType48 &amp;&amp; *opts.Type != EUIType64 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">typeReStr := "5"
        if *opts.Type == EUIType64 </span><span class="cov8" title="1">{
                typeReStr = "7"
        }</span>

        <span class="cov8" title="1">re := regexp.MustCompile(fmt.Sprintf(`^([[:xdigit:]]{2}%s){%s}[[:xdigit:]]{2}$`, noSepReStr, typeReStr))

        return re.MatchString(str)</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string is a [Magnet URI] format.
//
//        ok := validatorgo.IsMagnetURI("magnet:?xt=urn:btih:123456789abcdef123456789abcdef123456789a")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsMagnetURI("magnet:?dn=Example&amp;tr=http://example.com/announce")
//        fmt.Println(ok) // false
//
// [Magnet URI]: https://en.wikipedia.org/wiki/Magnet_URI_scheme
func IsMagnetURI(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile(`(?:^magnet:\?|[^?&amp;]&amp;)xt(?:\.1)?=urn:(?:(?:aich|bitprint|btih|ed2k|ed2khash|kzhash|md5|sha1|tree:tiger):[a-z0-9]{32}(?:[a-z0-9]{8})?|btmh:1220[a-z0-9]{64})(?:$|&amp;)`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package validatorgo

import (
        "regexp"
)

// IsMailToURIOpts is used to configure IsMailtoURI
type IsMailToURIOpts struct {
        IsEmailOpts
}

// A validator that checks if the string is a [Mailto URI] format.
//
// IsMailToURIOpts is a struct that directly embeds IsEmailOpts.
//
// IsMailToURIOpts validates emails inside the URI (check IsEmailOpts for details).
//
//        ok := validatorgo.IsMailtoURI("mailto:someone@example.com")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsMailtoURI("someone@example.com")
//        fmt.Println(ok) // false
//
// [Mailto URI]: https://en.wikipedia.org/wiki/Mailto
func IsMailtoURI(str string, opts IsMailToURIOpts) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(`^(mailto:)([^\?]+)(\?.*)?$`)

        capGrp := re.FindStringSubmatch(str)

        if capGrp == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">email := capGrp[2]

        return IsEmail(email, IsEmailOpts{
                AllowDisplayName:         opts.AllowDisplayName,
                RequireDisplayName:       opts.RequireDisplayName,
                AllowUTF8LocalPart:       opts.AllowUTF8LocalPart,
                RequireTld:               opts.RequireTld,
                IgnoreMaxLength:          opts.IgnoreMaxLength,
                AllowIpDomain:            opts.AllowIpDomain,
                DomainSpecificValidation: opts.DomainSpecificValidation,
                BlacklistedChars:         opts.BlacklistedChars,
                HostBlacklist:            opts.HostBlacklist,
                HostWhitelist:            opts.HostWhitelist,
        })</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package validatorgo

// A validator that        checks if the string is a MD5 hash.
//
// Please note that you can also use the isHash(str, "md5") function.
//
// Keep in mind that MD5 has some collision weaknesses compared to other algorithms (e.g., SHA).
//
//        ok := validatorgo.IsMD5("9e107d9d372bb6826bd81d3542a419d6")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsMD5("9e107d9d372bb6826bd81d3542a419d")
//        fmt.Println(ok) // false
func IsMD5(str string) bool <span class="cov8" title="1">{
        return IsHash(str, "md5")
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string matches to a valid MIME type format.
//
//        ok := validatorgo.IsMimeType("text/plain")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsMimeType("textplain")
//        fmt.Println(ok) // false
func IsMimeType(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile(`^(application|audio|font|image|message|model|multipart|text|video|x-[\w.+-]+)\/[a-zA-Z][\w.+-]*(\s*;\s*[\w.+-]+=[\w.+-]+)*$`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package validatorgo

import "regexp"

// IsMobilePhoneOpts is used to configure IsMobilePhone
type IsMobilePhoneOpts struct {
        StrictMode bool // matches format exactly
}

// mobilePhoneLocaleRegex is the set of locales and their function validating mobile phone regex
var mobilePhoneLocaleRegex = map[string]func(opts IsMobilePhoneOpts) *regexp.Regexp{
        "am-AM": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+374\d{8}$`) // Armenia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{8}$`)</span>
        },
        "ar-AE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+971\d{8,9}$`) // UAE
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{8,9}$`)</span>
        },
        "ar-BH": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+973\d{8}$`) // Bahrain
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "ar-DZ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+213\d{9}$`) // Algeria
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "ar-EG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+20\d{10}$`) // Egypt
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^01\d{9}$`)</span>
        },
        "ar-IQ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+964\d{10}$`) // Iraq
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "ar-JO": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+962\d{8,9}$`) // Jordan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{8,9}$`)</span>
        },
        "ar-KW": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+965\d{8}$`) // Kuwait
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "ar-PS": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+970\d{8,9}$`) // Palestine
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{8,9}$`)</span>
        },
        "ar-SA": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+9665\d{8}$`) // Saudi Arabia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^05\d{8}$`)</span>
        },
        "ar-SD": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+249\d{9}$`) // Sudan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "ar-SY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+9639\d{8}$`) // Syria
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^09\d{8}$`)</span>
        },
        "ar-TN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+216\d{8}$`) // Tunisia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "ar-YE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+9677\d{7}$`) // Yemen
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^07\d{7}$`)</span>
        },
        "az-AZ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+994\d{9,10}$`) // Azerbaijan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9,10}$`)</span>
        },
        "az-LB": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+961\d{7,8}$`) // Lebanon
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{7,8}$`)</span>
        },
        "az-LY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+2189\d{8}$`) // Libya
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^09\d{8}$`)</span>
        },
        // Example for 'be-BY'
        "be-BY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+375\d{9}$`) // Belarus
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "bg-BG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+359\d{9}$`) // Bulgaria
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "bn-BD": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+8801\d{9}$`) // Bangladesh
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^01\d{9}$`)</span>
        },
        "bs-BA": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+387\d{8}$`) // Bosnia and Herzegovina
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "ca-AD": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+376\d{6}$`) // Andorra
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{6}$`)</span>
        },
        "cs-CZ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+420\d{9}$`) // Czech Republic
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "da-DK": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+45\d{8}$`) // Denmark
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "de-AT": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+43\d{10}$`) // Austria
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "de-CH": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+41\d{9}$`) // Switzerland
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "de-DE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+49\d{10,11}$`) // Germany
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10,11}$`)</span>
        },
        "de-LU": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+352\d{8}$`) // Luxembourg
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "dv-MV": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+960\d{7}$`) // Maldives
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "dz-BT": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+975\d{8}$`) // Bhutan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "el-CY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+357\d{8}$`) // Cyprus
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "el-GR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+30\d{10}$`) // Greece
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "en-AG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+1268\d{7}$`) // Antigua and Barbuda
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "en-AI": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+1264\d{7}$`) // Anguilla
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "en-AU": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+61\d{9}$`) // Australia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "en-BM": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+1441\d{7}$`) // Bermuda
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "en-BS": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+1242\d{7}$`) // Bahamas
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "en-BW": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+267\d{7,8}$`) // Botswana
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7,8}$`)</span>
        },
        "en-CA": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+1\d{10}$`) // Canada
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "en-GB": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+44\d{10}$`) // United Kingdom
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "en-GG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+44\d{10}$`) // Guernsey (shares UK's country code)
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "en-GH": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+233\d{9}$`) // Ghana
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "en-GY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+592\d{7}$`) // Guyana
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "en-HK": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+852\d{8}$`) // Hong Kong
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "en-IE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+353\d{9}$`) // Ireland
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "en-IN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+91\d{10}$`) // India
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "en-JM": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+1876\d{7}$`) // Jamaica
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "en-KE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+254\d{9}$`) // Kenya
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "en-KI": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+686\d{5}$`) // Kiribati
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{5}$`)</span>
        },
        "en-KN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+1869\d{7}$`) // Saint Kitts and Nevis
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "en-LS": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+266\d{8}$`) // Lesotho
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "en-MO": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+853\d{8}$`) // Macau
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "en-MT": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+356\d{8}$`) // Malta
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "en-MU": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+230\d{7}$`) // Mauritius
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "en-MW": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+265\d{9}$`) // Malawi
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "en-NG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov8" title="1">{
                if opts.StrictMode </span><span class="cov8" title="1">{
                        return regexp.MustCompile(`^\+234\d{10}$`) // Nigeria
                }</span>
                <span class="cov8" title="1">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "en-NZ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+64\d{9}$`) // New Zealand
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "en-PG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+675\d{7}$`) // Papua New Guinea
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "en-PH": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+63\d{10}$`) // Philippines
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "en-PK": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+92\d{10}$`) // Pakistan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "en-RW": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+250\d{9}$`) // Rwanda
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "en-SG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+65\d{8}$`) // Singapore
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "en-SL": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+232\d{8}$`) // Sierra Leone
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "en-SS": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+211\d{9}$`) // South Sudan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "en-TZ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+255\d{9}$`) // Tanzania
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "en-UG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+256\d{9}$`) // Uganda
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "en-US": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+1\d{10}$`) // United States
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "en-ZA": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+27\d{9}$`) // South Africa
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "en-ZM": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+260\d{9}$`) // Zambia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "en-ZW": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+263\d{9}$`) // Zimbabwe
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "es-AR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+54\d{10}$`) // Argentina
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "es-BO": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+591\d{8}$`) // Bolivia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "es-CL": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+56\d{9}$`) // Chile
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "es-CO": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+57\d{10}$`) // Colombia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "es-CR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+506\d{8}$`) // Costa Rica
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "es-CU": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+53\d{8}$`) // Cuba
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "es-DO": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+1809\d{7}$`) // Dominican Republic
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "es-EC": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+593\d{9}$`) // Ecuador
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "es-ES": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+34\d{9}$`) // Spain
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "es-GT": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+502\d{8}$`) // Guatemala
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "es-HN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+504\d{8}$`) // Honduras
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "es-MX": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+52\d{10}$`) // Mexico
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "es-NI": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+505\d{8}$`) // Nicaragua
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "es-PA": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+507\d{8}$`) // Panama
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "es-PE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+51\d{9}$`) // Peru
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "es-PR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+1\d{10}$`) // Puerto Rico
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "es-PY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+595\d{9}$`) // Paraguay
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "es-SV": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+503\d{8}$`) // El Salvador
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "es-UY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+598\d{9}$`) // Uruguay
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "es-VE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+58\d{10}$`) // Venezuela
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "et-EE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+372\d{7,8}$`) // Estonia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7,8}$`)</span>
        },
        "fa-IR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+98\d{10}$`) // Iran
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "fi-FI": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+358\d{9}$`) // Finland
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fil-PH": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+63\d{10}$`) // Philippines
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "fr-BE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+32\d{8}$`) // Belgium
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-BF": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+226\d{8}$`) // Burkina Faso
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-BJ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+229\d{8}$`) // Benin
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-CD": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+243\d{9}$`) // Democratic Republic of the Congo
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-CF": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+236\d{8}$`) // Central African Republic
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-CG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+242\d{9}$`) // Congo
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-CH": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+41\d{9}$`) // Switzerland
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-CI": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+225\d{8}$`) // Ivory Coast
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-CM": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+237\d{8}$`) // Cameroon
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-DJ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+253\d{8}$`) // Djibouti
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-DZ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+213\d{9}$`) // Algeria
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-FR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+33\d{9}$`) // France
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-GA": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+241\d{7}$`) // Gabon
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "fr-GN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+224\d{8}$`) // Guinea
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-GQ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+240\d{9}$`) // Equatorial Guinea
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-HT": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+509\d{8}$`) // Haiti
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-LU": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+352\d{9}$`) // Luxembourg
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-MA": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+212\d{9}$`) // Morocco
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-MG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+261\d{9}$`) // Madagascar
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-ML": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+223\d{8}$`) // Mali
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-MR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+222\d{8}$`) // Mauritania
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-MU": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+230\d{7}$`) // Mauritius
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "fr-NC": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+687\d{6}$`) // New Caledonia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{6}$`)</span>
        },
        "fr-NE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+227\d{8}$`) // Niger
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-PF": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+689\d{6}$`) // French Polynesia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{6}$`)</span>
        },
        "fr-RW": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+250\d{9}$`) // Rwanda
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-SN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+221\d{9}$`) // Senegal
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-SY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+963\d{9}$`) // Syria
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-TD": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+235\d{8}$`) // Chad
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-TG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+228\d{8}$`) // Togo
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-TN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+216\d{8}$`) // Tunisia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-VU": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+678\d{7}$`) // Vanuatu
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "fr-WF": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+681\d{6}$`) // Wallis and Futuna
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{6}$`)</span>
        },
        "ga-IE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+353\d{9}$`) // Ireland
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "he-IL": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+972\d{8,9}$`) // Israel
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8,9}$`)</span>
        },
        "hi-IN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+91\d{10}$`) // India
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "hr-HR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+385\d{8,9}$`) // Croatia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8,9}$`)</span>
        },
        "hu-HU": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+36\d{9}$`) // Hungary
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "hy-AM": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+374\d{8}$`) // Armenia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "id-ID": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+62\d{9,11}$`) // Indonesia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9,11}$`)</span>
        },
        "it-IT": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+39\d{9,10}$`) // Italy
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9,10}$`)</span>
        },
        "ja-JP": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+81\d{9,10}$`) // Japan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9,10}$`)</span>
        },
        "ka-GE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+995\d{9}$`) // Georgia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "kk-KZ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+7\d{10}$`) // Kazakhstan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "km-KH": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+855\d{8,9}$`) // Cambodia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8,9}$`)</span>
        },
        "ko-KR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+82\d{9,10}$`) // South Korea
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9,10}$`)</span>
        },
        "ky-KG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+996\d{9}$`) // Kyrgyzstan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "lt-LT": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+370\d{8}$`) // Lithuania
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "lv-LV": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+371\d{8}$`) // Latvia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "mn-MN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+976\d{8}$`) // Mongolia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "ms-MY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+60\d{9,10}$`) // Malaysia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9,10}$`)</span>
        },
        "ne-NP": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+977\d{9,10}$`) // Nepal
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9,10}$`)</span>
        },
        "nl-BE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+32\d{8}$`) // Belgium (Dutch)
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "nl-NL": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+31\d{9}$`) // Netherlands
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "no-NO": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+47\d{8}$`) // Norway
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "pl-PL": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+48\d{9}$`) // Poland
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "pt-AO": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+244\d{9}$`) // Angola
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "pt-BR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+55\d{10,11}$`) // Brazil
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10,11}$`)</span>
        },
        "pt-CV": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+238\d{7}$`) // Cape Verde
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "pt-GW": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+245\d{7}$`) // Guinea-Bissau
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "pt-MZ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+258\d{9}$`) // Mozambique
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "pt-PT": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+351\d{9}$`) // Portugal
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "ro-MD": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+373\d{8}$`) // Moldova
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "ro-RO": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+40\d{9}$`) // Romania
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "ru-BY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+375\d{9}$`) // Belarus
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "ru-KG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+996\d{9}$`) // Kyrgyzstan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "ru-KZ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+7\d{10}$`) // Kazakhstan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "ru-RU": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+7\d{10}$`) // Russia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "ru-UA": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+380\d{9}$`) // Ukraine
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "si-LK": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+94\d{9}$`) // Sri Lanka
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "sk-SK": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+421\d{9}$`) // Slovakia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "sl-SI": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+386\d{8}$`) // Slovenia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "sq-AL": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+355\d{9}$`) // Albania
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "sq-MK": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+389\d{8}$`) // North Macedonia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "sr-BA": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+387\d{8}$`) // Bosnia and Herzegovina
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "sr-ME": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+382\d{8}$`) // Montenegro
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "sr-RS": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+381\d{8,9}$`) // Serbia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8,9}$`)</span>
        },
        "sv-FI": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+358\d{9}$`) // Finland (Swedish-speaking)
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "sv-SE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+46\d{7,10}$`) // Sweden
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7,10}$`)</span>
        },
        "ta-IN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+91\d{10}$`) // India (Tamil)
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "ta-LK": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+94\d{9}$`) // Sri Lanka (Tamil)
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "th-TH": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+66\d{8,9}$`) // Thailand
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8,9}$`)</span>
        },
        "tr-CY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+90\d{10}$`) // Cyprus (Turkish-speaking)
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "tr-TR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+90\d{10}$`) // Turkey
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "uk-UA": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+380\d{9}$`) // Ukraine
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "ur-PK": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+92\d{10}$`) // Pakistan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "uz-UZ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+998\d{9}$`) // Uzbekistan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "vi-VN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+84\d{9,10}$`) // Vietnam
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9,10}$`)</span>
        },
        "zh-CN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+86\d{11}$`) // China
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{11}$`)</span>
        },
        "zh-HK": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+852\d{8}$`) // Hong Kong
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "zh-MO": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+853\d{8}$`) // Macau
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "zh-SG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+65\d{8}$`) // Singapore (Mandarin-speaking)
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "zh-TW": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+886\d{9,10}$`) // Taiwan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9,10}$`)</span>
        },
}

// A validator that checks if the string is a mobile phone number.
//
// locale is either an array of locales e.g. []string{'sk-SK', 'sr-RS'} possible options are ('am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-EH', 'ar-IQ', 'ar-JO', 'ar-KW', 'ar-PS', 'ar-SA', 'ar-SD', 'ar-SY', 'ar-TN', 'ar-YE', 'az-AZ', 'az-LB', 'az-LY', 'be-BY', 'bg-BG', 'bn-BD', 'bs-BA', 'ca-AD', 'cs-CZ', 'da-DK', 'de-AT', 'de-CH', 'de-DE', 'de-LU', 'dv-MV', 'dz-BT', 'el-CY', 'el-GR', 'en-AG', 'en-AI', 'en-AU', 'en-BM', 'en-BS', 'en-BW', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-GY', 'en-HK', 'en-IE', 'en-IN', 'en-JM', 'en-KE', 'en-KI', 'en-KN', 'en-LS', 'en-MO', 'en-MT', 'en-MU', 'en-MW', 'en-NG', 'en-NZ', 'en-PG', 'en-PH', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-SS', 'en-TZ', 'en-UG', 'en-US', 'en-ZA', 'en-ZM', 'en-ZW', 'es-AR', 'es-BO', 'es-CL', 'es-CO', 'es-CR', 'es-CU', 'es-DO', 'es-EC', 'es-ES', 'es-GT','es-HN', 'es-MX', 'es-NI', 'es-PA', 'es-PE', 'es-PY', 'es-SV', 'es-UY', 'es-VE', 'et-EE', 'fa-AF', 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-BF', 'fr-BJ', 'fr-CD', 'fr-CF', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-PF', 'fr-RE', 'fr-WF', 'ga-IE', 'he-IL', 'hu-HU', 'id-ID', 'ir-IR', 'it-IT', 'it-SM', 'ja-JP', 'ka-GE', 'kk-KZ', 'kl-GL', 'ko-KR', 'ky-KG', 'lt-LT', 'mg-MG', 'mn-MN', 'ms-MY', 'my-MM', 'mz-MZ', 'nb-NO', 'ne-NP', 'nl-AW', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL', 'pt-AO', 'pt-BR', 'pt-PT', 'ro-Md', 'ro-RO', 'ru-RU', 'si-LK', 'sk-SK', 'sl-SI', 'so-SO', 'sq-AL', 'sr-RS', 'sv-SE', 'tg-TJ', 'th-TH', 'tk-TM', 'tr-TR', 'uk-UA', 'uz-UZ', 'vi-VN', 'zh-CN', 'zh-HK', 'zh-MO', 'zh-TW'). If nil is provided any of the locales will be matched. If an unidentified value is used, function will return false.
//
// IsMobilePhoneOpts is a struct that can be supplied with the following keys:
//
// StrictMode, if this is set to true, the mobile phone number must be supplied with the country code and therefore must start with +.
//
//        ok := validatorg.IsMobilePhone("08070448986", []string{"en-US"} , validatorgo.IsMobilePhoneOpts{})
//        fmt.Println(ok) // true
//        ok := validatorg.IsMobilePhone("090666666567", []string{"en-US"} , validatorgo.IsMobilePhoneOpts{})
//        fmt.Println(ok) // false
func IsMobilePhone(str string, locales []string, opts IsMobilePhoneOpts) bool <span class="cov8" title="1">{
        strWithoutSpaces := stripDashesAndSpaces(str)

        if len(locales) == 0 </span><span class="cov0" title="0">{
                for _, valFunc := range mobilePhoneLocaleRegex </span><span class="cov0" title="0">{
                        re := valFunc(opts)

                        if !re.MatchString(strWithoutSpaces) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        } else<span class="cov8" title="1"> {

                for _, loc := range locales </span><span class="cov8" title="1">{
                        valFunc, exists := mobilePhoneLocaleRegex[loc]

                        if !exists </span><span class="cov0" title="0">{
                                return false
                        }</span>

                        <span class="cov8" title="1">re := valFunc(opts)

                        if !re.MatchString(strWithoutSpaces) </span><span class="cov8" title="1">{
                                return false
                        }</span>

                }
        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package validatorgo

import "unicode/utf8"

// A validator that checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.
//
//        ok := validatorgo.IsMongoID("507f1f77bcf86cd799439011")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsMongoID("507f1f77bcf86cd79943901")
//        fmt.Println(ok) // false
func IsMongoID(str string) bool <span class="cov8" title="1">{
        return IsHexadecimal(str) &amp;&amp; utf8.RuneCountInString(str) == 24
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string contains one or more multibyte chars.
//
//        ok := validatorgo.IsMultibyte("こんにちは")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsMultibyte("hello")
//        fmt.Println(ok) // false
func IsMultibyte(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile(`[^\x00-\x7F]`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package validatorgo

import (
        "regexp"
)

// IsNumericOpts is used to configure IsNumeric
type IsNumericOpts struct {
        NoSymbols bool
        Locale    string
}

// numericFormatsRegex is the set of number validating regex for each cldr code
var numericFormatsRegex = map[int]func(opts IsNumericOpts) *regexp.Regexp{
        0: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,3})(,\d{3})*(\.\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,3})(,\d{3})*(\.\d+)?$`)</span> // With symbols
        }, // matches 1,234,567.89 (comma for thousands, dot for decimals)
        1: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d+)(\.\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d+)(\.\d+)?$`)</span> // With symbols
        }, // matches 1234567.89 (no thousands separator, dot for decimals)
        2: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,3})( \d{1,3})*(,\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,3})( \d{1,3})*(,\d+)?$`)</span> // With symbols
        }, // matches 1 234 567,89 (space for thousands, comma for decimals)
        3: func(opts IsNumericOpts) *regexp.Regexp <span class="cov8" title="1">{
                if opts.NoSymbols </span><span class="cov8" title="1">{
                        return regexp.MustCompile(`^(\d{1,3})(\.\d{3})*(,\d+)?$`) // Without symbols
                }</span>
                <span class="cov8" title="1">return regexp.MustCompile(`^[+-]?(\d{1,3})(\.\d{3})*(,\d+)?$`)</span> // With symbols
        }, // matches 1.234.567,89 (dot for thousands, comma for decimals)
        4: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,3})(,\d{3})*(·\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,3})(,\d{3})*(·\d+)?$`)</span> // With symbols
        }, // matches 1,234,567·89 (comma for thousands, interpunct for decimals)
        5: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,2},)*(\d{1,3})(\.\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,2},)*(\d{1,3})(\.\d+)?$`)</span> // With symbols
        }, // matches 12,34,567.89 (Indian system: commas for thousands, dot for decimals)
        6: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,2} )*(\d{1,3})(\.\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,2} )*(\d{1,3})(\.\d+)?$`)</span> // With symbols
        }, // matches 12 34 567.89 (Indian system: space for thousands, dot for decimals)
        7: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,3})('\d{3})*(\.\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,3})('\d{3})*(\.\d+)?$`)</span> // With symbols
        }, // matches 1'234'567.89 (apostrophe for thousands, dot for decimals)
        8: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,3})(٬\d{3})*(٫\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,3})(٬\d{3})*(٫\d+)?$`)</span> // With symbols
        }, // matches ١٬٢٣٤٬٥٦٧٫٨٩ (Arabic: comma-like for thousands, period-like for decimals)
        9: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,3})( \d{3})*(\.\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,3})( \d{3})*(\.\d+)?$`)</span> // With symbols
        }, // matches 1 234 567.89 (space for thousands, dot for decimals)
        10: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,3})(\.\d{3})*(·\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,3})(\.\d{3})*(·\d+)?$`)</span> // With symbols
        }, // matches 1234567,89 (no thousands separator, comma for decimals)
        11: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d+)('\d{3})*(٫\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d+)('\d{3})*(٫\d+)?$`)</span> // With symbols
        }, // matches 12,34,567.89 (variant of Indian system with space and comma separators)
        12: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,3})( \d{3})*(,\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,3})( \d{3})*(,\d+)?$`)</span> // With symbols
        }, // matches Arabic format without spaces for thousands separators
        13: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d+)(٬\d{3})*(\.\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d+)(٬\d{3})*(\.\d+)?$`)</span> // With symbols
        }, // matches numbers without thousand separators, e.g., in East Asia (e.g., 1234.56)
        14: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,3})(,\d{3})*(\.\d{2})?$`) // Without symbols, 2 decimals
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,3})(,\d{3})*(\.\d{2})?$`)</span> // With symbols, 2 decimals
        }, // matches 1 2345.67 (thousands separator every four digits, dot for decimals, variant)
}

// codeNumericFormats is the set of locales pointing to numericFormatsRegex
var codeNumericFormats = map[string]int{
        "ar":          8, // Arabic numeral system (1٬234٬567٫89)
        "ar-AE":       8,
        "ar-BH":       8,
        "ar-DZ":       8,
        "ar-EG":       8,
        "ar-IQ":       8,
        "ar-JO":       8,
        "ar-KW":       8,
        "ar-LB":       8,
        "ar-LY":       8,
        "ar-MA":       8,
        "ar-QA":       8,
        "ar-QM":       8,
        "ar-SA":       8,
        "ar-SD":       8,
        "ar-SY":       8,
        "ar-TN":       8,
        "ar-YE":       8,
        "bg-BG":       3, // Bulgarian (1.234.567,89)
        "cs-CZ":       3, // Czech (1.234.567,89)
        "da-DK":       3, // Danish (1.234.567,89)
        "de-DE":       3, // German (1.234.567,89)
        "en-AU":       0, // Australian English (1,234,567.89)
        "en-GB":       0, // British English (1,234,567.89)
        "en-HK":       0, // Hong Kong English (1,234,567.89)
        "en-IN":       5, // Indian English (12,34,567.89)
        "en-NZ":       0, // New Zealand English (1,234,567.89)
        "en-US":       0, // American English (1,234,567.89)
        "en-ZA":       0, // South African English (1,234,567.89)
        "en-ZM":       0, // Zambian English (1,234,567.89)
        "eo":          1, // Esperanto (1234567.89)
        "es-ES":       3, // Spanish (1.234.567,89)
        "fr-FR":       3, // French (1.234.567,89)
        "fr-CA":       0, // Canadian French (1,234,567.89)
        "hu-HU":       3, // Hungarian (1.234.567,89)
        "it-IT":       3, // Italian (1.234.567,89)
        "nb-NO":       3, // Norwegian Bokmål (1.234.567,89)
        "nl-NL":       3, // Dutch (1.234.567,89)
        "nn-NO":       3, // Norwegian Nynorsk (1.234.567,89)
        "pl-PL":       3, // Polish (1.234.567,89)
        "pt-BR":       3, // Brazilian Portuguese (1.234.567,89)
        "pt-PT":       3, // Portuguese (1.234.567,89)
        "ru-RU":       3, // Russian (1.234.567,89)
        "sl-SI":       3, // Slovenian (1.234.567,89)
        "sr-RS":       3, // Serbian (1.234.567,89)
        "sr-RS@latin": 3, // Serbian Latin (1.234.567,89)
        "sv-SE":       3, // Swedish (1.234.567,89)
        "tr-TR":       3, // Turkish (1.234.567,89)
        "uk-UA":       3, // Ukrainian (1.234.567,89)
}

// var codeNumericFormats = map[string]int{
//         "ar":          3, // Arabic (general)
//         "ar-AE":       3, // Arabic (United Arab Emirates)
//         "ar-BH":       3, // Arabic (Bahrain)
//         "ar-DZ":       3, // Arabic (Algeria)
//         "ar-EG":       3, // Arabic (Egypt)
//         "ar-IQ":       3, // Arabic (Iraq)
//         "ar-JO":       3, // Arabic (Jordan)
//         "ar-KW":       3, // Arabic (Kuwait)
//         "ar-LB":       3, // Arabic (Lebanon)
//         "ar-LY":       3, // Arabic (Libya)
//         "ar-MA":       3, // Arabic (Morocco)
//         "ar-QA":       3, // Arabic (Qatar)
//         "ar-QM":       3, // Arabic (Oman)
//         "ar-SA":       3, // Arabic (Saudi Arabia)
//         "ar-SD":       3, // Arabic (Sudan)
//         "ar-SY":       3, // Arabic (Syria)
//         "ar-TN":       3, // Arabic (Tunisia)
//         "ar-YE":       3, // Arabic (Yemen)
//         "bg-BG":       2, // Bulgarian (Bulgaria)
//         "cs-CZ":       2, // Czech (Czech Republic)
//         "da-DK":       3, // Danish (Denmark)
//         "de-DE":       3, // German (Germany)
//         "en-AU":       0, // English (Australia)
//         "en-GB":       0, // English (United Kingdom)
//         "en-HK":       0, // English (Hong Kong)
//         "en-IN":       5, // English (India)
//         "en-NZ":       0, // English (New Zealand)
//         "en-US":       0, // English (United States)
//         "en-ZA":       2, // English (South Africa)
//         "en-ZM":       0, // English (Zambia)
//         "eo":          0, // Esperanto
//         "es-ES":       3, // Spanish (Spain)
//         "fr-FR":       2, // French (France)
//         "fr-CA":       0, // French (Canada)
//         "hu-HU":       2, // Hungarian (Hungary)
//         "it-IT":       3, // Italian (Italy)
//         "nb-NO":       3, // Norwegian Bokmål (Norway)
//         "nl-NL":       3, // Dutch (Netherlands)
//         "nn-NO":       3, // Norwegian Nynorsk (Norway)
//         "pl-PL":       2, // Polish (Poland)
//         "pt-BR":       2, // Portuguese (Brazil)
//         "pt-PT":       2, // Portuguese (Portugal)
//         "ru-RU":       2, // Russian (Russia)
//         "sl-SI":       3, // Slovenian (Slovenia)
//         "sr-RS":       3, // Serbian (Cyrillic, Serbia)
//         "sr-RS@latin": 3, // Serbian (Latin, Serbia)
//         "sv-SE":       3, // Swedish (Sweden)
//         "tr-TR":       3, // Turkish (Turkey)
//         "uk-UA":       2, // Ukrainian (Ukraine)
// }

// A validator that check if a string is a number.
//
// IsNumericOpts is a struct which defaults to { NoSymbols: false, Locale: ""}.
//
// If NoSymbols is true, the validator will reject numeric strings that feature a symbol (e.g. +, -, or .).
//
// Locale determines the numeric format and is one of ("ar", "ar-AE", "ar-BH", "ar-DZ", "ar-EG", "ar-IQ", "ar-JO", "ar-KW", "ar-LB", "ar-LY", "ar-MA", "ar-QA", "ar-QM", "ar-SA", "ar-SD", "ar-SY", "ar-TN", "ar-YE", "bg-BG", "cs-CZ", "da-DK", "de-DE", "en-AU", "en-GB", "en-HK", "en-IN", "en-NZ", "en-US", "en-ZA", "en-ZM", "eo", "es-ES", "fr-FR", "fr-CA", "hu-HU", "it-IT", "nb-NO", "nl-NL", "nn-NO", "pl-PL", "pt-BR", "pt-PT", "ru-RU", "sl-SI", "sr-RS", "sr-RS@latin", "sv-SE", "tr-TR", "uk-UA"). Locale will default to "en-US" if not present.
//
//        ok = validatorgo.IsNumeric("12345", validatorgo.IsNumericOpts{})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsNumeric("12.34.56", validatorgo.IsNumericOpts{})
//        fmt.Println(ok) // false
func IsNumeric(str string, opts IsNumericOpts) bool <span class="cov8" title="1">{
        var re *regexp.Regexp

        // has symbols and no Locale
        if !opts.NoSymbols &amp;&amp; opts.Locale == "" </span><span class="cov8" title="1">{
                re = regexp.MustCompile(`^[+-]?\d+(\.\d+)?$`)
                return re.MatchString(str)
        }</span>

        // no symbols and no Locale
        <span class="cov8" title="1">if opts.NoSymbols &amp;&amp; opts.Locale == "" </span><span class="cov8" title="1">{
                re = regexp.MustCompile(`^\d+$`)
                return re.MatchString(str)
        }</span>

        <span class="cov8" title="1">if opts.Locale == "" </span><span class="cov0" title="0">{
                opts.Locale = "en-US"
        }</span>

        // Locale is present and plus or minus symbols are optional(NoSymbol does not matter)
        <span class="cov8" title="1">codeNumForm := codeNumericFormats[opts.Locale]
        valFunc := numericFormatsRegex[codeNumForm]
        re = valFunc(opts)

        return re.MatchString(str)</span>
}

// // codeNumericFormats is the set of cldr chart codes
// var codeNumericFormats = map[string]int{
//         "af":      2, // Afrikaans
//         "sq":      2, // Albanian
//         "am":      0, // Amharic
//         "ar":      0, // Arabic
//         "hy":      2, // Armenian
//         "as":      5, // Assamese
//         "az":      3, // Azerbaijani
//         "bn":      5, // Bengali (India)
//         "eu":      3, // Basque
//         "be":      2, // Belarusian
//         "bs":      3, // Bosnian
//         "bg":      2, // Bulgarian
//         "de_CH":   7, // Swiss German
//         "fr_CH":   7, // Swiss French
//         "it_CH":   7, // Swiss Italian
//         "my":      0, // Burmese
//         "yue":     5, // Cantonese
//         "ca":      3, // Catalan
//         "chr":     5, // Cherokee
//         "zh":      0, // Chinese (Simplified)
//         "hr":      3, // Croatian
//         "cs":      2, // Czech
//         "da":      3, // Danish
//         "nl":      3, // Dutch
//         "en":      0, // English
//         "et":      2, // Estonian
//         "pt_PT":   2, // Portuguese (Portugal)
//         "fil":     0, // Filipino
//         "fi":      2, // Finnish
//         "fr":      2, // French
//         "gl":      3, // Galician
//         "ka":      2, // Georgian
//         "de":      3, // German
//         "el":      3, // Greek
//         "gu":      5, // Gujarati
//         "ha":      0, // Hausa
//         "hi":      0, // Hindi
//         "hi_Latn": 5, // Hindi (Latin script)
//         "hu":      2, // Hungarian
//         "is":      3, // Icelandic
//         "ig":      0, // Igbo
//         "id":      3, // Indonesian
//         "ga":      0, // Irish
//         "it":      3, // Italian
//         "ja":      0, // Japanese
//         "jv":      0, // Javanese
//         "kn":      5, // Kannada
//         "kk":      3, // Kazakh
//         "km":      0, // Khmer
//         "ko":      0, // Korean
//         "lo":      0, // Lao
//         "lv":      2, // Latvian
//         "lt":      2, // Lithuanian
//         "mk":      3, // Macedonian
//         "ms":      3, // Malay
//         "ml":      5, // Malayalam
//         "mr":      5, // Marathi
//         "mn":      0, // Mongolian
//         "ne":      5, // Nepali
//         "no":      3, // Norwegian
//         "fa":      3, // Persian
//         "pl":      2, // Polish
//         "pt_BR":   2, // Portuguese (Brazil)
//         "pa":      5, // Punjabi
//         "ro":      2, // Romanian
//         "ru":      2, // Russian
//         "sr":      3, // Serbian
//         "si":      5, // Sinhala
//         "sk":      2, // Slovak
//         "sl":      3, // Slovenian
//         "es":      3, // Spanish
//         "sw":      0, // Swahili
//         "sv":      3, // Swedish
//         "ta":      5, // Tamil
//         "te":      5, // Telugu
//         "th":      0, // Thai
//         "tr":      3, // Turkish
//         "uk":      2, // Ukrainian
//         "ur":      0, // Urdu
//         "uz":      3, // Uzbek
//         "vi":      0, // Vietnamese
//         "cy":      0, // Welsh
//         "yo":      0, // Yoruba
//         "zu":      0, // Zulu
// }
</pre>
		
		<pre class="file" id="file70" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string is a valid octal number.
//
//        ok := validatorgo.IsOctal("07")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsOctal("078")
//        fmt.Println(ok) // false
func IsOctal(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile(`^[0-7]+$`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package validatorgo

import "regexp"

// countryCodePassportNumberRegex is the set of country codes and their validating regex
var countryCodePassportNumberRegex = map[string]*regexp.Regexp{
        "AM": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Armenia
        "AR": regexp.MustCompile(`^[A-Z]{3}\d{6}$`),      // Argentina
        "AT": regexp.MustCompile(`^[A-Z]\d{7}$`),         // Austria
        "AU": regexp.MustCompile(`^[A-Z]\d{7}$`),         // Australia
        "AZ": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Azerbaijan
        "BE": regexp.MustCompile(`^[A-Z]{2}\d{6}$`),      // Belgium
        "BG": regexp.MustCompile(`^\d{9}$`),              // Bulgaria
        "BY": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Belarus
        "BR": regexp.MustCompile(`^[A-Z]{2}\d{6}$`),      // Brazil
        "CA": regexp.MustCompile(`^[A-Z]{2}\d{6}$`),      // Canada
        "CH": regexp.MustCompile(`^[A-Z]\d{7}$`),         // Switzerland
        "CN": regexp.MustCompile(`^G\d{8}$|^E\d{8}$`),    // China
        "CY": regexp.MustCompile(`^[A-Z]{2}\d{6}$`),      // Cyprus
        "CZ": regexp.MustCompile(`^\d{8}$`),              // Czech Republic
        "DE": regexp.MustCompile(`^[C-FH]\d{8}$`),        // Germany
        "DK": regexp.MustCompile(`^\d{9}$`),              // Denmark
        "DZ": regexp.MustCompile(`^\d{9}$`),              // Algeria
        "EE": regexp.MustCompile(`^[A-Z]\d{7}$`),         // Estonia
        "ES": regexp.MustCompile(`^[A-Z]\d{7}$`),         // Spain
        "FI": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Finland
        "FR": regexp.MustCompile(`^\d{2}[A-Z]{2}\d{5}$`), // France
        "GB": regexp.MustCompile(`^\d{9}$`),              // United Kingdom
        "GR": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Greece
        "HR": regexp.MustCompile(`^\d{9}$`),              // Croatia
        "HU": regexp.MustCompile(`^[A-Z]{2}\d{6}$`),      // Hungary
        "IE": regexp.MustCompile(`^[A-Z]\d{7}$`),         // Ireland
        "IN": regexp.MustCompile(`^[A-Z]\d{7}$`),         // India
        "IR": regexp.MustCompile(`^[A-Z]\d{8}$`),         // Iran
        "ID": regexp.MustCompile(`^[A-Z]\d{7}$`),         // Indonesia
        "IS": regexp.MustCompile(`^[A-Z]{2}\d{6}$`),      // Iceland
        "IT": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Italy
        "JM": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Jamaica
        "JP": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Japan
        "KR": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // South Korea
        "KZ": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Kazakhstan
        "LI": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Liechtenstein
        "LT": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Lithuania
        "LU": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Luxembourg
        "LV": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Latvia
        "LY": regexp.MustCompile(`^\d{8}$`),              // Libya
        "MT": regexp.MustCompile(`^\d{7}$`),              // Malta
        "MX": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Mexico
        "MY": regexp.MustCompile(`^[A-Z]\d{8}$`),         // Malaysia
        "MZ": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Mozambique
        "NL": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Netherlands
        "NZ": regexp.MustCompile(`^[A-Z]\d{7}$`),         // New Zealand
        "PH": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Philippines
        "PK": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Pakistan
        "PL": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Poland
        "PT": regexp.MustCompile(`^[A-Z]{2}\d{6}$`),      // Portugal
        "RO": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Romania
        "RU": regexp.MustCompile(`^\d{9}$`),              // Russia
        "SE": regexp.MustCompile(`^\d{8}$`),              // Sweden
        "SL": regexp.MustCompile(`^\d{8}$`),              // Sierra Leone
        "SK": regexp.MustCompile(`^\d{8}$`),              // Slovakia
        "TH": regexp.MustCompile(`^[A-Z]\d{7}$`),         // Thailand
        "TR": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Turkey
        "UA": regexp.MustCompile(`^[A-Z]{2}\d{6}$`),      // Ukraine
        "US": regexp.MustCompile(`^\d{9}$`),              // United States
        "ZA": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // South Africa
}

// A validator that checks if the string is a valid passport number.
//
// countryCode is one of ("AM", "AR", "AT", "AU", "AZ", "BE", "BG", "BY", "BR", "CA", "CH", "CN", "CY", "CZ", "DE", "DK", "DZ", "EE", "ES", "FI", "FR", "GB", "GR", "HR", "HU", "IE", "IN", "IR", "ID", "IS", "IT", "JM", "JP", "KR", "KZ", "LI", "LT", "LU", "LV", "LY", "MT", "MX", "MY", "MZ", "NL", "NZ", "PH", "PK", "PL", "PT", "RO", "RU", "SE", "SL", "SK", "TH", "TR", "UA", "US", "ZA").
//
//        ok := validatorgo.IsPassportNumber("123456789", "US")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsPassportNumber("A12345678", "US")
//        fmt.Println(ok) // false
func IsPassportNumber(str, countryCode string) bool <span class="cov8" title="1">{
        re, exists := countryCodePassportNumberRegex[countryCode]

        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return re.MatchString(str)</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string is a valid port number.
//
//        ok := validatorgo.IsPort("07")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsPort("078")
//        fmt.Println(ok) // false
func IsPort(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile(`^0*([0-9]|[1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">package validatorgo

import (
        "regexp"
)

// localePostalCodeRegex is the set of locales and postal code regex
var localePostalCodeRegex = map[string]*regexp.Regexp{
        "AD": regexp.MustCompile(`^AD\d{3}$`),                                  // Andorra
        "AT": regexp.MustCompile(`^\d{4}$`),                                    // Austria
        "AU": regexp.MustCompile(`^\d{4}$`),                                    // Australia
        "AZ": regexp.MustCompile(`^\d{4}$`),                                    // Azerbaijan
        "BA": regexp.MustCompile(`^\d{5}$`),                                    // Bosnia and Herzegovina
        "BE": regexp.MustCompile(`^\d{4}$`),                                    // Belgium
        "BG": regexp.MustCompile(`^\d{4}$`),                                    // Bulgaria
        "BR": regexp.MustCompile(`^\d{5}-\d{3}$`),                              // Brazil
        "BY": regexp.MustCompile(`^\d{6}$`),                                    // Belarus
        "CA": regexp.MustCompile(`^[A-Za-z]\d[A-Za-z] \d[A-Za-z]\d$`),          // Canada
        "CH": regexp.MustCompile(`^\d{4}$`),                                    // Switzerland
        "CN": regexp.MustCompile(`^\d{6}$`),                                    // China
        "CO": regexp.MustCompile(`^\d{6}$`),                                    // Colombia
        "CZ": regexp.MustCompile(`^\d{3} \d{2}$`),                              // Czech Republic
        "DE": regexp.MustCompile(`^\d{5}$`),                                    // Germany
        "DK": regexp.MustCompile(`^\d{4}$`),                                    // Denmark
        "DO": regexp.MustCompile(`^\d{5}$`),                                    // Dominican Republic
        "DZ": regexp.MustCompile(`^\d{5}$`),                                    // Algeria
        "EE": regexp.MustCompile(`^\d{5}$`),                                    // Estonia
        "ES": regexp.MustCompile(`^\d{5}$`),                                    // Spain
        "FI": regexp.MustCompile(`^\d{5}$`),                                    // Finland
        "FR": regexp.MustCompile(`^\d{5}$`),                                    // France
        "GB": regexp.MustCompile(`^[A-Za-z]{1,2}\d[A-Za-z\d]? \d[A-Za-z]{2}$`), // United Kingdom
        "GR": regexp.MustCompile(`^\d{3} \d{2}$`),                              // Greece
        "HR": regexp.MustCompile(`^\d{5}$`),                                    // Croatia
        "HT": regexp.MustCompile(`^\d{4}$`),                                    // Haiti
        "HU": regexp.MustCompile(`^\d{4}$`),                                    // Hungary
        "ID": regexp.MustCompile(`^\d{5}$`),                                    // Indonesia
        "IE": regexp.MustCompile(`^[A-Za-z]\d{2}[A-Za-z0-9]{4}$`),              // Ireland
        "IL": regexp.MustCompile(`^\d{7}$`),                                    // Israel
        "IN": regexp.MustCompile(`^\d{6}$`),                                    // India
        "IR": regexp.MustCompile(`^\d{5}-\d{5}$`),                              // Iran
        "IS": regexp.MustCompile(`^\d{3}$`),                                    // Iceland
        "IT": regexp.MustCompile(`^\d{5}$`),                                    // Italy
        "JP": regexp.MustCompile(`^\d{3}-\d{4}$`),                              // Japan
        "KE": regexp.MustCompile(`^\d{5}$`),                                    // Kenya
        "KR": regexp.MustCompile(`^\d{5}$`),                                    // South Korea
        "LI": regexp.MustCompile(`^\d{4}$`),                                    // Liechtenstein
        "LK": regexp.MustCompile(`^\d{5}$`),                                    // Sri Lanka
        "LT": regexp.MustCompile(`^LT-\d{5}$`),                                 // Lithuania
        "LU": regexp.MustCompile(`^\d{4}$`),                                    // Luxembourg
        "LV": regexp.MustCompile(`^LV-\d{4}$`),                                 // Latvia
        "MG": regexp.MustCompile(`^\d{3}$`),                                    // Madagascar
        "MT": regexp.MustCompile(`^[A-Za-z]{3} \d{4}$`),                        // Malta
        "MX": regexp.MustCompile(`^\d{5}$`),                                    // Mexico
        "MY": regexp.MustCompile(`^\d{5}$`),                                    // Malaysia
        "NL": regexp.MustCompile(`^\d{4} [A-Za-z]{2}$`),                        // Netherlands
        "NO": regexp.MustCompile(`^\d{4}$`),                                    // Norway
        "NP": regexp.MustCompile(`^\d{5}$`),                                    // Nepal
        "NZ": regexp.MustCompile(`^\d{4}$`),                                    // New Zealand
        "PL": regexp.MustCompile(`^\d{2}-\d{3}$`),                              // Poland
        "PR": regexp.MustCompile(`^\d{5}(-\d{4})?$`),                           // Puerto Rico
        "PT": regexp.MustCompile(`^\d{4}-\d{3}$`),                              // Portugal
        "RO": regexp.MustCompile(`^\d{6}$`),                                    // Romania
        "RU": regexp.MustCompile(`^\d{6}$`),                                    // Russia
        "SA": regexp.MustCompile(`^\d{5}$`),                                    // Saudi Arabia
        "SE": regexp.MustCompile(`^\d{3} \d{2}$`),                              // Sweden
        "SG": regexp.MustCompile(`^\d{6}$`),                                    // Singapore
        "SI": regexp.MustCompile(`^\d{4}$`),                                    // Slovenia
        "SK": regexp.MustCompile(`^\d{3} \d{2}$`),                              // Slovakia
        "TH": regexp.MustCompile(`^\d{5}$`),                                    // Thailand
        "TN": regexp.MustCompile(`^\d{4}$`),                                    // Tunisia
        "TW": regexp.MustCompile(`^\d{3}(?:-\d{2})?$`),                         // Taiwan
        "UA": regexp.MustCompile(`^\d{5}$`),                                    // Ukraine
        "US": regexp.MustCompile(`^\d{5}(-\d{4})?$`),                           // United States
        "ZA": regexp.MustCompile(`^\d{4}$`),                                    // South Africa
        "ZM": regexp.MustCompile(`^\d{5}$`),                                    // Zambia
}

// A validator that checks if the string is a postal code.
//
// locale is one of ("AD", "AT", "AU", "AZ", "BA", "BE", "BG", "BR", "BY", "CA", "CH", "CN", "CO", "CZ", "DE", "DK", "DO", "DZ", "EE", "ES", "FI", "FR", "GB", "GR", "HR", "HT", "HU", "ID", "IE", "IL", "IN", "IR", "IS", "IT", "JP", "KE", "KR", "LI", "LK", "LT", "LU", "LV", "MG", "MT", "MX", "MY", "NL", "NO", "NP", "NZ", "PL", "PR", "PT", "RO", "RU", "SA", "SE", "SG", "SI", "SK", "TH", "TN", "TW", "UA", "US", "ZA", "ZM"). If "any" or no locale is used, function will check if any of the locales match.
//
//        ok := validatorgo.IsPostalCode("90210", "US")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsPostalCode("902101", "DE")
//        fmt.Println(ok) // false
func IsPostalCode(str, locale string) bool <span class="cov8" title="1">{
        re, exists := localePostalCodeRegex[locale]

        if !exists </span><span class="cov8" title="1">{
                if locale != "" &amp;&amp; locale != "any" </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">for _, reg := range localePostalCodeRegex </span><span class="cov8" title="1">{
                        match := reg.MatchString(str)

                        if match </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }

                <span class="cov8" title="1">return false</span>
        }

        <span class="cov8" title="1">return re.MatchString(str)</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package validatorgo

import (
        "regexp"
)

// A validator that checks if the string is a valid [RFC 3339] date.
//
//        ok := validatorgo.IsRFC3339("2024-09-21T14:30:00Z")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsRFC3339("2024-09-21 14:30:00Z")
//        fmt.Println(ok) // false
//
// [RFC 3339]: https://tools.ietf.org/html/rfc3339
func IsRFC3339(str string) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(`^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])T([01]\d|2[0-3]):[0-5]\d:[0-5]\d(Z|([+-](0[0-9]|1[0-3]):[0-5]\d))$`)

        capGrp := re.FindStringSubmatch(str)

        if len(capGrp) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">year, month, day := capGrp[1], capGrp[2], capGrp[3]

        return validYearMonthDay(year, month, day)</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package validatorgo

import "regexp"

// IsRgbOpts is used to configure IsRgbColor
type IsRgbOpts struct {
        IncludePercentValues bool // must use percent values 90% not 0-255
        AllowSpaces bool // whether to include spaces
}

// A validator that checks if the string is a rgb or rgba color.
//
// IsRgbOpts is a struct with the following properties:
//
// IncludePercentValues defaults to false. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.
//
// AllowSpaces defaults to false, which prohibits whitespace. If set to false, whitespace between color values is allowed, such as rgb(255, 255, 255) or even rgba(255,       128,        0,      0.7).
//
//        ok := validatorgo.IsRgbColor("rgb(255,0,0)", validatorgo.IsRgbColor{})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsRgbColor("rgb( 255 , 0 , 0 )", validatorgo.IsRgbColor{})
//        fmt.Println(ok) // false
func IsRgbColor(str string, opts IsRgbOpts) bool <span class="cov8" title="1">{
        if opts.IncludePercentValues &amp;&amp; opts.AllowSpaces </span><span class="cov8" title="1">{
                return regexp.MustCompile(`^rgba?\((\d{0,100}(\.[0-9]*)?%|\d{0,255}),\s*(\d{0,100}(\.[0-9]*)?%|\d{0,255}),\s*(\d{0,100}(\.[0-9]*)?%|\d{0,255})(,\s*(1|0?\.[0-9])?)?\)$`).MatchString(str)
        }</span> else<span class="cov8" title="1"> if !opts.IncludePercentValues &amp;&amp; opts.AllowSpaces </span><span class="cov8" title="1">{
                return regexp.MustCompile(`^rgba?\(\d{0,255},\s*\d{0,255},\s*\d{0,255}(,\s*(1|0?\.[1-9])*)?\)$`).MatchString(str)
        }</span> else<span class="cov8" title="1"> if opts.IncludePercentValues &amp;&amp; !opts.AllowSpaces </span><span class="cov8" title="1">{
                return regexp.MustCompile(`^rgba?\((\d{0,100}(\.[0-9]*)?%|\d{0,255}),(\d{0,100}(\.[0-9]*)?%|\d{0,255}),(\d{0,100}(\.[0-9]*)?%|\d{0,255})(,(1|0?\.[0-9])?)?\)$`).MatchString(str)
        }</span>else<span class="cov8" title="1"> {
                return regexp.MustCompile(`^rgba?\(\d{0,255},\d{0,255},\d{0,255}(,(1|0?\.[1-9])*)?\)$`).MatchString(str)
        }</span>
}</pre>
		
		<pre class="file" id="file76" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string is a Semantic Versioning Specification (SemVer).
//
//        ok := validatorgo.IsSemVer("1.0.0")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsSemVer("1.0.0.0")
//        fmt.Println(ok) // false
func IsSemVer(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile(`^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string is of type slug.
//
//        ok := validatorgo.IsSlug("rgb(255,0,0)")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsSlug("rgb( 255 , 0 , 0 )")
//        fmt.Println(ok) // false
func IsSlug(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile(`^[a-z0-9]+(?:-[a-z0-9]+)*$`).MatchString(str)
}</pre>
		
		<pre class="file" id="file78" style="display: none">package validatorgo

import (
        "unicode"
)

// defaults values to configure IsStrongPassword, IsStrongPasswordOpts
const (
        defaultStrongPasswordMinimumLength    int = 8
        defaultStrongPasswordMinimumLowercase int = 1
        defaultStrongPasswordMinimumUppercase int = 1
        defaultStrongPasswordMinimumNumbers   int = 1
        defaultStrongPasswordMinimumSymbols   int = 1

        defaultStrongPasswordPointsPerUnique          float64 = 1
        defaultStrongPasswordPointsPerRepeat          float64 = 0.5
        defaultStrongPasswordPointsForContainingLower float64 = 10
        defaultStrongPasswordPointsForContainingUpper float64 = 10
        defaultStrongPasswordPointsContainingNumber   float64 = 10
        defaultStrongPasswordPointsContainingSymbol   float64 = 10
)

// IsStrongPasswordOpts is used to configure IsStrongPassword
type IsStrongPasswordOpts struct {
        MinLength    *int // passwords minimum length
        MinLowercase *int // passwords minimum lowercase letters
        MinUppercase *int // passwords minimum uppercase letters
        MinNumbers   *int // passwords minimum numbers
        MinSymbols   *int // passwords minimum symbols

        PointsPerUnique           *float64 // minimum points per unique character
        PointsPerRepeat           *float64 // minimum points per repeated character
        PointsForContainingLower  *float64 // minimum points per lowercase character
        PointsForContainingUpper  *float64 // minimum points per uppercase character
        PointsForContainingNumber *float64 // minimum points per numeric character
        PointsForContainingSymbol *float64 // minimum points per special character
}

// uppLwrSpecNumChars is used to count/differentiate different classes of characters
type uppLwrSpecNumChars struct {
        uppercase int
        lowercase int
        numbers   int
        symbol    int
        unique    int
        repeated  int
}

// A validator that checks if the string can be considered a strong password or not. Returns the validity and the score.
//
// Default IsStrongPasswordOpts: { MinLength: 8, MinLowercase: 1, MinUppercase: 1, MinNumbers: 1, MinSymbols: 1,  PointsPerUnique: 1, PointsPerRepeat: 0.5, PointsForContainingLower: 10, PointsForContainingUpper: 10, PointsForContainingNumber: 10, PointsForContainingSymbol: 10 }
//
//        ok, score := validatorgo.IsStrongPassword("Password123!", validatorgo.IsStrongPasswordOpts{})
//        fmt.Println(ok, score) // true, 130.5
//        ok, score := validatorgo.IsStrongPassword("P@ss1", validatorgo.IsStrongPasswordOpts{})
//        fmt.Println(ok, score) // false, 53.50
func IsStrongPassword(str string, opts IsStrongPasswordOpts) (bool, float64) <span class="cov8" title="1">{
        optsWithDefaults := strongPasswordOptsToDefault(opts)

        score := 0.00
        valid := true

        ulsc := cntUppLwrSymNumChars(str)

        // fmt.Printf("ulsc %+v\n", ulsc)
        score += float64(ulsc.lowercase) * *optsWithDefaults.PointsForContainingLower // 7 * 10
        score += float64(ulsc.uppercase) * *optsWithDefaults.PointsForContainingUpper // 1 * 10
        score += float64(ulsc.numbers) * *optsWithDefaults.PointsForContainingNumber  // 3 * 10
        score += float64(ulsc.symbol) * *optsWithDefaults.PointsForContainingSymbol   // 1 * 10
        score += float64(ulsc.unique) * *optsWithDefaults.PointsPerUnique             // 10 * 1
        score += float64(ulsc.repeated) * *optsWithDefaults.PointsPerRepeat           // 1 * 0.5

        // fmt.Println("score", score)

        if len(str) &lt; *optsWithDefaults.MinLength </span><span class="cov8" title="1">{
                return false, score
        }</span>

        <span class="cov8" title="1">if ulsc.lowercase &lt; *optsWithDefaults.MinLowercase </span><span class="cov8" title="1">{
                return false, score
        }</span>

        <span class="cov8" title="1">if ulsc.uppercase &lt; *optsWithDefaults.MinUppercase </span><span class="cov8" title="1">{
                return false, score
        }</span>

        <span class="cov8" title="1">if ulsc.numbers &lt; *optsWithDefaults.MinNumbers </span><span class="cov8" title="1">{
                return false, score
        }</span>

        <span class="cov8" title="1">if ulsc.symbol &lt; *optsWithDefaults.MinSymbols </span><span class="cov8" title="1">{
                return false, score
        }</span>

        <span class="cov8" title="1">return valid, score</span>
}

func strongPasswordOptsToDefault(opts IsStrongPasswordOpts) IsStrongPasswordOpts <span class="cov8" title="1">{
        if opts.MinLength == nil </span><span class="cov8" title="1">{
                opts.MinLength = intPtr(defaultStrongPasswordMinimumLength)
        }</span>

        <span class="cov8" title="1">if opts.MinLowercase == nil </span><span class="cov8" title="1">{
                opts.MinLowercase = intPtr(defaultStrongPasswordMinimumLowercase)
        }</span>

        <span class="cov8" title="1">if opts.MinUppercase == nil </span><span class="cov8" title="1">{
                opts.MinUppercase = intPtr(defaultStrongPasswordMinimumUppercase)
        }</span>

        <span class="cov8" title="1">if opts.MinNumbers == nil </span><span class="cov8" title="1">{
                opts.MinNumbers = intPtr(defaultStrongPasswordMinimumNumbers)
        }</span>

        <span class="cov8" title="1">if opts.MinSymbols == nil </span><span class="cov8" title="1">{
                opts.MinSymbols = intPtr(defaultStrongPasswordMinimumSymbols)
        }</span>

        <span class="cov8" title="1">if opts.PointsPerUnique == nil </span><span class="cov8" title="1">{
                opts.PointsPerUnique = floatPtr(defaultStrongPasswordPointsPerUnique)
        }</span>

        <span class="cov8" title="1">if opts.PointsPerRepeat == nil </span><span class="cov8" title="1">{
                opts.PointsPerRepeat = floatPtr(defaultStrongPasswordPointsPerRepeat)
        }</span>

        <span class="cov8" title="1">if opts.PointsForContainingLower == nil </span><span class="cov8" title="1">{
                opts.PointsForContainingLower = floatPtr(defaultStrongPasswordPointsForContainingLower)
        }</span>

        <span class="cov8" title="1">if opts.PointsForContainingUpper == nil </span><span class="cov8" title="1">{
                opts.PointsForContainingUpper = floatPtr(defaultStrongPasswordPointsForContainingUpper)
        }</span>

        <span class="cov8" title="1">if opts.PointsForContainingNumber == nil </span><span class="cov8" title="1">{
                opts.PointsForContainingNumber = floatPtr(defaultStrongPasswordPointsContainingNumber)
        }</span>

        <span class="cov8" title="1">if opts.PointsForContainingSymbol == nil </span><span class="cov8" title="1">{
                opts.PointsForContainingSymbol = floatPtr(defaultStrongPasswordPointsContainingSymbol)
        }</span>

        <span class="cov8" title="1">return opts</span>
}

func cntUppLwrSymNumChars(str string) (ulsc uppLwrSpecNumChars) <span class="cov8" title="1">{
        runeCountMap := make(map[rune]int, len(str))

        for _, char := range str </span><span class="cov8" title="1">{
                _, ok := runeCountMap[char]

                if ok </span><span class="cov8" title="1">{
                        runeCountMap[char] = runeCountMap[char] + 1
                }</span> else<span class="cov8" title="1"> {
                        runeCountMap[char] = 1
                }</span>

                <span class="cov8" title="1">if unicode.IsUpper(rune(char)) &amp;&amp; unicode.IsLetter(rune(char)) </span><span class="cov8" title="1">{
                        ulsc.uppercase++
                }</span> else<span class="cov8" title="1"> if unicode.IsLower(rune(char)) &amp;&amp; unicode.IsLetter(rune(char)) </span><span class="cov8" title="1">{
                        ulsc.lowercase++
                }</span> else<span class="cov8" title="1"> if unicode.IsNumber(rune(char)) </span><span class="cov8" title="1">{
                        ulsc.numbers++
                }</span> else<span class="cov8" title="1"> {
                        ulsc.symbol++
                }</span>
        }

        <span class="cov8" title="1">for _, count := range runeCountMap </span><span class="cov8" title="1">{
                if count &gt; 1 </span><span class="cov8" title="1">{
                        ulsc.repeated++
                        // fmt.Println("repeated", string(ru))
                }</span> else<span class="cov8" title="1"> {
                        ulsc.unique++
                        // fmt.Println("unique", string(ru))
                }</span>
        }

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package validatorgo

// A validator that checks if the string contains any surrogate pairs chars.
//
//        ok := validatorgo.IsSurrogatePair("")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsSurrogatePair("")
//        fmt.Println(ok) // false
func IsSurrogatePair(str string) bool <span class="cov8" title="1">{
        for _, r := range str </span><span class="cov8" title="1">{
                if r &gt; 0xFFFF </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package validatorgo


// A validator that checks if the string is a valid Tax Identification Number. Default locale is en-US.
//
// Supported locales: ("bg-BG", "cs-CZ", "de-AT", "de-DE", "dk-DK", "el-CY", "el-GR", "en-CA", "en-GB", "en-IE", "en-US", "es-AR", "es-ES", "et-EE", "fi-FI", "fr-BE", "fr-CA", "fr-FR", "fr-LU", "hr-HR", "hu-HU", "it-IT", "lb-LU", "lt-LT", "lv-LV", "mt-MT", "nl-BE", "nl-NL", "pl-PL", "pt-BR", "pt-PT", "ro-RO", "sk-SK", "sl-SI", "sv-SE", "uk-UA").
func IsTaxID(str, locale string) bool <span class="cov8" title="1">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">package validatorgo

import (
        "fmt"
        "regexp"
)

const (
        IsTimeOptsHourFormat24 string = "hour24"
        IsTimeOptsHourFormat12 string = "hour12"

        IsTimeOptsModeDefault     string = "defaults"
        IsTimeOptsModeWithSeconds string = "withSeconds"
)

type IsTimeOpts struct {
        HourFormat string // hour12 e.g 14:30 or hour24 e.g 02:30 PM
        Mode       string // default e.g 13:30 or withSeconds e.g 13:30:20
}

// A validator that checks if the string is a valid time e.g. 23:01:59
//
// IsTimeOpts is a struct which can contain the keys HourFormat and Mode.
//
// HourFormat is a key and defaults to "hour24".
//
// Mode is a key and defaults to "default".
//
// HourFormat can contain the values "hour12" or "hour24", "hour24" will validate hours in 24 format and "hour12" will validate hours in 12 format.
//
// Mode can contain the values "default" or "withSeconds", "default" will validate HH:MM or HH:MM:SS format, "withSeconds" will validate only HH:MM:SS format.
//
//        ok := validatorgo.IsTime("14:30", validatorgo.IsTime{})
//        fmt.Println(ok) // true
//        ok := validatorgo.IsTime("09:5", validatorgo.IsTime{})
//        fmt.Println(ok) // false
func IsTime(str string, opts IsTimeOpts) bool <span class="cov8" title="1">{
        if opts.HourFormat == "" </span><span class="cov8" title="1">{
                opts.HourFormat = IsTimeOptsHourFormat24
        }</span>

        <span class="cov8" title="1">if opts.HourFormat != IsTimeOptsHourFormat12 &amp;&amp; opts.HourFormat != IsTimeOptsHourFormat24 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if opts.Mode == "" </span><span class="cov8" title="1">{
                opts.Mode = IsTimeOptsModeDefault
        }</span>

        <span class="cov8" title="1">if opts.Mode != IsTimeOptsModeDefault &amp;&amp; opts.Mode != IsTimeOptsModeWithSeconds </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">hourFmtStr1, hourFmtStr2 := "", ""
        if opts.HourFormat == IsTimeOptsHourFormat24 </span><span class="cov8" title="1">{
                hourFmtStr1 = "(0[0-9]|1[0-9]|2[0-4])"
                hourFmtStr2 = ""
        }</span> else<span class="cov8" title="1"> {
                hourFmtStr1 = "(0[0-9]|1[0-2])"
                hourFmtStr2 = " (AM|PM|am|pm)"
        }</span>

        <span class="cov8" title="1">minFmtStr := ""
        if opts.Mode == IsTimeOptsModeDefault </span><span class="cov8" title="1">{
                minFmtStr = "(:[0-5][0-9])?"
        }</span> else<span class="cov8" title="1"> {
                minFmtStr = ":[0-5][0-9]"
        }</span>

        <span class="cov8" title="1">reStr := fmt.Sprintf(`^%s:[0-5][0-9]%s%s$`, hourFmtStr1, minFmtStr, hourFmtStr2)
        re := regexp.MustCompile(reStr)

        return re.MatchString(str)</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string is a [ULID].
//
//        ok := validatorgo.IsULID("01ARZ3NDEKTSV4RRFFQ69G5FAV")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsULID("01ARZ3NDEKTSV4RRFFQ69G5FA")
//        fmt.Println(ok) // false
//
// [ULID]: https://github.com/ulid/spec
func IsULID(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile(`[0-7][0-9A-HJKMNP-TV-Z]{25}`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">package validatorgo

import "strings"

// A validator that checks if the string is uppercase.
//
//        ok := validatorgo.IsUpperCase("HELLO")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsUpperCase("world")
//        fmt.Println(ok) // false
func IsUpperCase(str string) bool <span class="cov8" title="1">{
        return str == strings.ToUpper(str)
}</span>
</pre>
		
		<pre class="file" id="file84" style="display: none">package validatorgo

type IsURLOpts struct {
        Protocols                 []string
        RequireTld                bool
        RequireProtocol           bool
        RequireHost               bool
        RequirePort               bool
        RequireValidProtocol      bool
        AllowUnderscores          bool
        HostWhitelist             bool
        HostBlacklist             bool
        AllowTrailingDot          bool
        AllowProtocolRelativeUrls bool
        AllowFragments            bool
        AllowQueryComponents      bool
        DisallowAuth              bool
        ValidateLength            bool
        MaxAllowedLength          bool
}

// A validator that checks if the string is a URL.
//
// IsURLOpts is a struct which defaults to { Protocols: ["http","https","ftp"], RequireTld: true, RequireProtocol: false, RequireHost: true, RequirePort: false, RequireValidProtocol: true, AllowUnderscores: false, HostWhitelist: false, HostBlacklist: false, AllowTrailingDot: false, AllowProtocolRelativeUrls: false, AllowFragments: true, AllowQueryComponents: true, DisallowAuth: false, ValidateLength: true }.
//
// RequireProtocol - if set to true isURL will return false if protocol is not present in the URL.
//
// RequireValidProtocol - isURL will check if the URL's protocol is present in the protocols option.
//
// protocols - valid protocols can be modified with this option.
//
// RequireHost - if set to false isURL will not check if host is present in the URL.
//
// RequirePort - if set to true isURL will check if port is present in the URL.
//
// AllowProtocolRelativeUrls - if set to true protocol relative URLs will be allowed.
//
// AllowFragments - if set to false isURL will return false if fragments are present.
//
// AllowQueryComponents - if set to false isURL will return false if query components are present.
//
// ValidateLength - if set to false isURL will skip string length validation. MaxAllowedLength will be ignored if this is set as false.
//
// MaxAllowedLength - if set isURL will not allow URLs longer than the specified value (default is 2084 that IE maximum URL length).
func IsURL(str string, opts *IsURLOpts) bool <span class="cov0" title="0">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">package validatorgo

import "regexp"

var uuidRegex = map[string]*regexp.Regexp{
        "1": regexp.MustCompile(`(?i)^[0-9a-f]{8}-[0-9a-f]{4}-[1][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$`),
        "2": regexp.MustCompile(`(?i)^[0-9a-f]{8}-[0-9a-f]{4}-[2][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$`),
        "3": regexp.MustCompile(`(?i)^[0-9a-f]{8}-[0-9a-f]{4}-[3][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$`),
        "4": regexp.MustCompile(`(?i)^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$`),
        "5": regexp.MustCompile(`(?i)^[0-9a-f]{8}-[0-9a-f]{4}-[5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$`),
        // "6": regexp.MustCompile(`(?i)^[0-9a-f]{8}-[0-9a-f]{4}-[6][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$`),
        // "7": regexp.MustCompile(`(?i)^[0-9a-f]{8}-[0-9a-f]{4}-[7][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$`),
        // "8": regexp.MustCompile(`(?i)^[0-9a-f]{8}-[0-9a-f]{4}-[8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$`),
}

// A validator that checks if the string is an RFC9562 UUID.
//
// version is one of ("1"-"5"). if none is not provided, it will validate any of them.
//
//        ok := validatorgo.IsUUID("550e8400-e29b-11d4-a716-446655440000", "1")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsUUID("f47ac10b-58cc-4372-a567-0e02b2c3d479", "1")
//        fmt.Println(ok) // false
func IsUUID(str, version string) bool <span class="cov8" title="1">{
        re, exists := uuidRegex[version]

        if !exists </span><span class="cov8" title="1">{
                if version != "" </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">for _, uiRe := range uuidRegex </span><span class="cov8" title="1">{
                        match := uiRe.MatchString(str)

                        if match </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }

                <span class="cov8" title="1">return false</span>
        }

        <span class="cov8" title="1">return re.MatchString(str)</span>
}</pre>
		
		<pre class="file" id="file86" style="display: none">package validatorgo

// A validator that checks if the string contains a mixture of full and half-width chars.
//
//        ok := validatorgo.IsVariableWidth("ａｂｃ123")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsVariableWidth("ａｂｃ１２３")
//        fmt.Println(ok) // false
func IsVariableWidth(str string) bool <span class="cov8" title="1">{
        hasFullWidth := false
        hasHalfWidth := false

        for _, char := range str </span><span class="cov8" title="1">{
                if (char &gt;= '\uFF00' &amp;&amp; char &lt;= '\uFFEF') ||
                        (char &gt;= '\u4E00' &amp;&amp; char &lt;= '\u9FFF') ||
                        (char &gt;= '\u3040' &amp;&amp; char &lt;= '\u309F') ||
                        (char &gt;= '\u30A0' &amp;&amp; char &lt;= '\u30FF') </span><span class="cov8" title="1">{
                        hasFullWidth = true
                }</span>

                <span class="cov8" title="1">if char &gt;= '\u0020' &amp;&amp; char &lt;= '\u007E' </span><span class="cov8" title="1">{
                        hasHalfWidth = true
                }</span>

                <span class="cov8" title="1">if hasFullWidth &amp;&amp; hasHalfWidth </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package validatorgo

// A validator that checks if the string is a valid VAT number if validation is available for the given country code matching ISO 3166-1 alpha-2.
//
// countryCode is one of ("AL", "AR", "AT", "AU", "BE", "BG", "BO", "BR", "BY", "CA", "CH", "CL", "CO", "CR", "CY", "CZ", "DE", "DK", "DO", "EC", "EE", "EL", "ES", "FI", "FR", "GB", "GT", "HN", "HR", "HU", "ID", "IE", "IL", "IN", "IS", "IT", "KZ", "LT", "LU", "LV", "MK", "MT", "MX", "NG", "NI", "NL", "NO", "NZ", "PA", "PE", "PH", "PL", "PT", "PY", "RO", "RS", "RU", "SA", "SE", "SI", "SK", "SM", "SV", "TR", "UA", "UY", "UZ", "VE"). If none is provided will match every one.
func IsVAT(str, countryCode string) bool <span class="cov0" title="0">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file88" style="display: none">package validatorgo

// A validator that checks if the string consists only of characters that appear in the whitelist chars.
//
//        ok := validatorgo.IsWhitelisted("stop", "post")
//        fmt.Println(ok) // true
//        ok := validatorgo.IsWhitelisted("bang", "take")
//        fmt.Println(ok) // false
func IsWhitelisted(str, chars string) bool <span class="cov8" title="1">{
        charsM := make(map[string]int)

        for _, char := range chars </span><span class="cov8" title="1">{
                val := string(char)
                _, exist := charsM[val]

                if exist </span><span class="cov0" title="0">{
                        charsM[val] += 1
                }</span> else<span class="cov8" title="1"> {
                        charsM[val] = 1
                }</span>
        }

        <span class="cov8" title="1">for _, st := range str </span><span class="cov8" title="1">{
                val := string(st)

                _, exist := charsM[val]

                if !exist </span><span class="cov8" title="1">{
                        return false
                }</span>

        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string matches the regex.
//
//        ok := validatorgo.Matches("foo", regexp.MustCompile(`^foo$`))
//        fmt.Println(ok) // true
//        ok := validatorgo.Matches("foo", regexp.MustCompile(`^foobar$`))
//        fmt.Println(ok) // false
func Matches(str string, re *regexp.Regexp) bool <span class="cov8" title="1">{
        if re == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return re.MatchString(str)</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package validatorgo

import (
        "strconv"
        "strings"
)

func ptr(i uint) *uint <span class="cov8" title="1">{
        return &amp;i
}</span>

func intPtr(i int) *int <span class="cov8" title="1">{
        return &amp;i
}</span>

func floatPtr(f float64) *float64 <span class="cov8" title="1">{
        return &amp;f
}</span>

func stripDashesAndSpaces(str string) string <span class="cov8" title="1">{
        strWthOutDashes := strings.ReplaceAll(str, "-", "")
        strWthOutSpacesAndDashes := strings.ReplaceAll(strWthOutDashes, " ", "")

        return strWthOutSpacesAndDashes
}</span>

func stripDashes(str string) string <span class="cov0" title="0">{
        return strings.ReplaceAll(str, "-", "")
}</span>

func stripSpaces(str string) string <span class="cov0" title="0">{
        return strings.ReplaceAll(str, " ", "")
}</span>

func stripHyphens(str string) string <span class="cov8" title="1">{
        return strings.ReplaceAll(str, "-", "")
}</span>

// digitSum returns the sum of digits in an int.
func digitSum(i int) (sum int) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                sum += i % 10
                i /= 10
                if i == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func validYearMonthDay(year, month, day string) bool <span class="cov8" title="1">{
        yr, err := strconv.Atoi(year)

        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">mn, err := strconv.Atoi(month)

        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">dy, err := strconv.Atoi(day)

        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">monthLength := []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}

        // Adjust for leap years
        if yr%400 == 0 || (yr%100 != 0 &amp;&amp; yr%4 == 0) </span><span class="cov8" title="1">{
                monthLength[1] = 29
        }</span>

        <span class="cov8" title="1">if !(mn &gt; 0 &amp;&amp; mn &lt; 13) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if dy &lt; 0 || dy &gt; monthLength[mn-1] </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
