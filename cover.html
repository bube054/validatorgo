
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>validatorgo: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/bube054/validatorgo/contains.go (100.0%)</option>
				
				<option value="file1">github.com/bube054/validatorgo/equals.go (100.0%)</option>
				
				<option value="file2">github.com/bube054/validatorgo/isAlpham.go (91.4%)</option>
				
				<option value="file3">github.com/bube054/validatorgo/isabarouting.go (90.9%)</option>
				
				<option value="file4">github.com/bube054/validatorgo/isafter.go (88.9%)</option>
				
				<option value="file5">github.com/bube054/validatorgo/isalphanum.go (88.9%)</option>
				
				<option value="file6">github.com/bube054/validatorgo/isascii.go (100.0%)</option>
				
				<option value="file7">github.com/bube054/validatorgo/isbase32.go (100.0%)</option>
				
				<option value="file8">github.com/bube054/validatorgo/isbase58.go (100.0%)</option>
				
				<option value="file9">github.com/bube054/validatorgo/isbase64.go (100.0%)</option>
				
				<option value="file10">github.com/bube054/validatorgo/isbefore.go (88.9%)</option>
				
				<option value="file11">github.com/bube054/validatorgo/isbic.go (100.0%)</option>
				
				<option value="file12">github.com/bube054/validatorgo/isboolean.go (100.0%)</option>
				
				<option value="file13">github.com/bube054/validatorgo/isbtcaddress.go (100.0%)</option>
				
				<option value="file14">github.com/bube054/validatorgo/isbytelength.go (100.0%)</option>
				
				<option value="file15">github.com/bube054/validatorgo/iscountrycode.go (100.0%)</option>
				
				<option value="file16">github.com/bube054/validatorgo/iscreditcard.go (42.9%)</option>
				
				<option value="file17">github.com/bube054/validatorgo/iscurrency.go (51.1%)</option>
				
				<option value="file18">github.com/bube054/validatorgo/isdatauri.go (100.0%)</option>
				
				<option value="file19">github.com/bube054/validatorgo/isdate.go (100.0%)</option>
				
				<option value="file20">github.com/bube054/validatorgo/isdecimal.go (25.5%)</option>
				
				<option value="file21">github.com/bube054/validatorgo/isdivisibleby.go (83.3%)</option>
				
				<option value="file22">github.com/bube054/validatorgo/isean.go (100.0%)</option>
				
				<option value="file23">github.com/bube054/validatorgo/isemail.go (91.1%)</option>
				
				<option value="file24">github.com/bube054/validatorgo/isempty.go (100.0%)</option>
				
				<option value="file25">github.com/bube054/validatorgo/isetheruemaddress.go (100.0%)</option>
				
				<option value="file26">github.com/bube054/validatorgo/isfloat.go (75.0%)</option>
				
				<option value="file27">github.com/bube054/validatorgo/isfqdn.go (95.2%)</option>
				
				<option value="file28">github.com/bube054/validatorgo/isfreightcontainerid.go (0.0%)</option>
				
				<option value="file29">github.com/bube054/validatorgo/isfullwidth.go (100.0%)</option>
				
				<option value="file30">github.com/bube054/validatorgo/ishalfwidth.go (100.0%)</option>
				
				<option value="file31">github.com/bube054/validatorgo/ishash.go (75.0%)</option>
				
				<option value="file32">github.com/bube054/validatorgo/ishexadecimal.go (100.0%)</option>
				
				<option value="file33">github.com/bube054/validatorgo/ishexcolor.go (100.0%)</option>
				
				<option value="file34">github.com/bube054/validatorgo/ishsl.go (12.1%)</option>
				
				<option value="file35">github.com/bube054/validatorgo/isiban.go (75.0%)</option>
				
				<option value="file36">github.com/bube054/validatorgo/isidentitycard.go (100.0%)</option>
				
				<option value="file37">github.com/bube054/validatorgo/isin.go (100.0%)</option>
				
				<option value="file38">github.com/bube054/validatorgo/isint.go (93.3%)</option>
				
				<option value="file39">github.com/bube054/validatorgo/isip.go (87.5%)</option>
				
				<option value="file40">github.com/bube054/validatorgo/isiprange.go (87.5%)</option>
				
				<option value="file41">github.com/bube054/validatorgo/isisbn.go (91.4%)</option>
				
				<option value="file42">github.com/bube054/validatorgo/isisin.go (100.0%)</option>
				
				<option value="file43">github.com/bube054/validatorgo/isiso31661alpha2.go (100.0%)</option>
				
				<option value="file44">github.com/bube054/validatorgo/isiso31661alpha3.go (100.0%)</option>
				
				<option value="file45">github.com/bube054/validatorgo/isiso31661numeric.go (100.0%)</option>
				
				<option value="file46">github.com/bube054/validatorgo/isiso4217.go (100.0%)</option>
				
				<option value="file47">github.com/bube054/validatorgo/isiso6346.go (94.1%)</option>
				
				<option value="file48">github.com/bube054/validatorgo/isiso6391.go (100.0%)</option>
				
				<option value="file49">github.com/bube054/validatorgo/isiso8601.go (84.0%)</option>
				
				<option value="file50">github.com/bube054/validatorgo/isisrc.go (100.0%)</option>
				
				<option value="file51">github.com/bube054/validatorgo/isissn.go (94.3%)</option>
				
				<option value="file52">github.com/bube054/validatorgo/isjson.go (100.0%)</option>
				
				<option value="file53">github.com/bube054/validatorgo/isjwt.go (90.0%)</option>
				
				<option value="file54">github.com/bube054/validatorgo/islatlong.go (100.0%)</option>
				
				<option value="file55">github.com/bube054/validatorgo/islength.go (100.0%)</option>
				
				<option value="file56">github.com/bube054/validatorgo/islicenseplate.go (0.0%)</option>
				
				<option value="file57">github.com/bube054/validatorgo/islocale.go (100.0%)</option>
				
				<option value="file58">github.com/bube054/validatorgo/islowercase.go (100.0%)</option>
				
				<option value="file59">github.com/bube054/validatorgo/isluhnnumber.go (94.7%)</option>
				
				<option value="file60">github.com/bube054/validatorgo/ismacaddress.go (100.0%)</option>
				
				<option value="file61">github.com/bube054/validatorgo/ismagneturi.go (100.0%)</option>
				
				<option value="file62">github.com/bube054/validatorgo/ismailtouri.go (100.0%)</option>
				
				<option value="file63">github.com/bube054/validatorgo/ismd5str.go (100.0%)</option>
				
				<option value="file64">github.com/bube054/validatorgo/ismimetype.go (100.0%)</option>
				
				<option value="file65">github.com/bube054/validatorgo/ismobilephone.go (2.1%)</option>
				
				<option value="file66">github.com/bube054/validatorgo/ismongoid.go (100.0%)</option>
				
				<option value="file67">github.com/bube054/validatorgo/ismultibyte.go (100.0%)</option>
				
				<option value="file68">github.com/bube054/validatorgo/isnumeric.go (25.9%)</option>
				
				<option value="file69">github.com/bube054/validatorgo/isoctal.go (0.0%)</option>
				
				<option value="file70">github.com/bube054/validatorgo/ispassport.go (75.0%)</option>
				
				<option value="file71">github.com/bube054/validatorgo/isport.go (0.0%)</option>
				
				<option value="file72">github.com/bube054/validatorgo/issemver.go (100.0%)</option>
				
				<option value="file73">github.com/bube054/validatorgo/isuppercase.go (100.0%)</option>
				
				<option value="file74">github.com/bube054/validatorgo/isvat.go (0.0%)</option>
				
				<option value="file75">github.com/bube054/validatorgo/iswhilelisted.go (92.3%)</option>
				
				<option value="file76">github.com/bube054/validatorgo/matches.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// A go package for string validators and sanitizers.
package validatorgo

import "strings"

const defaultContainsMinOccurrence = 1

// ContainsOpt is used to configure Contains
// defaults to { IgnoreCase: false, MinOccurrences: 1 }.
type ContainsOpt struct {
        IgnoreCase     bool // ignore case when doing comparison, default false.
        MinOccurrences int  // minimum number of occurrences for the seed in the string. Defaults to 1.
}

// A validator that checks if the string contains the seed.
//
// ContainsOpt is a struct that defaults to { IgnoreCase: false, MinOccurrences: 1 }.
//
// ContainsOpt:
//
// IgnoreCase: Ignore case when doing comparison, default false.
//
// MinOccurrences: Minimum number of occurrences for the seed in the string. Defaults to 1.
//
//        ok := validatorgo.Contains("hello world", "world", ContainsOpt{})
//        fmt.Println(ok) // true
//
//        ok := validatorgo.Contains("hello world", "earth", ContainsOpt{})
//        fmt.Println(ok) // false
func Contains(str, seed string, options ContainsOpt) bool <span class="cov8" title="1">{
        if options.MinOccurrences &lt;= 0 </span><span class="cov8" title="1">{
                options.MinOccurrences = defaultContainsMinOccurrence
        }</span>

        <span class="cov8" title="1">if options.IgnoreCase </span><span class="cov8" title="1">{
                strLowerCase, seedLowerCase := strings.ToLower(str), strings.ToLower(seed)
                return strings.Contains(strLowerCase, seedLowerCase) &amp;&amp; strings.Count(strLowerCase, seedLowerCase) &gt;= options.MinOccurrences
        }</span> else<span class="cov8" title="1"> {
                return strings.Contains(str, seed) &amp;&amp; strings.Count(str, seed) &gt;= options.MinOccurrences
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package validatorgo

// A validator that checks if the string matches the comparison.
//
//        ok := govalidator.Equals("Hello", "Hello")
//        fmt.Println(ok) // true
//        ok := govalidator.Equals("Hello", "World")
//        fmt.Println(ok) // false
func Equals(str, comparison string) bool <span class="cov8" title="1">{
        return str == comparison
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package validatorgo

import (
        "regexp"
        "strings"
)

// IsAlphaOpts is used to configure IsAlpha
type IsAlphaOpts struct {
        Ignore string
        Locale string
}

// regexEscapes is the set of special regex characters escaped
var regexEscapes = map[string]string{
        ".":  `\.`,
        "*":  `\*`,
        "+":  `\+`,
        "?":  `\?`,
        "^":  `\^`,
        "$":  `\$`,
        "(":  `\(`,
        ")":  `\)`,
        "[":  `\[`,
        "]":  `\]`,
        "{":  `\{`,
        "}":  `\}`,
        "|":  `\|`,
        "\\": `\\`,
        "-":  `\-`,
        "&lt;":  `\&lt;`,
        "&gt;":  `\&gt;`,
        `"`:  `\"`,
        `'`:  `\'`,
}

var (
        // writingSystemAlphaRegex is the set of common writing systems and their validating alphabetical regex
        writingSystemAlphaRegex = map[string]string{
                "arabic":          "^[\u0600-\u06FF\u0750-\u077F]+$",              // Arabic
                "latin":           "^[A-Za-z]+$",                                  // Latin
                "latin_czech":     "^[A-Za-zÁČĎÉĚÍŇÓŘŠŤÚŮÝŽáčďéěíňóřšťúůýž]+$",    // Latin with Czech-specific characters
                "latin_danish":    "^[A-Za-zÆØÅæøå]+$",                            // Latin with Danish-specific characters
                "latin_german":    "^[A-Za-zÄÖÜßäöü]+$",                           // Latin with German-specific characters
                "latin_spanish":   "^[A-Za-zÁÉÍÑÓÚÜáéíñóúü]+$",                    // Latin with Spanish-specific characters
                "latin_french":    "^[A-Za-zÀÂÇÉÈÊËÎÏÔŒÙÛÜŸàâçéèêëîïôœùûüÿ]+$",    // Latin with French-specific characters
                "latin_esperanto": "^[A-Za-zĈĜĤĴŜŬĉĝĥĵŝŭ]+$",                      // Latin with Esperanto-specific characters
                "cyrillic":        "^[А-Яа-яЁё]+$",                                // Cyrillic
                "greek":           "^[Α-Ωα-ω]+$",                                  // Greek
                "armenian":        "^[\u0530-\u058F]+$",                           // Armenian
                "bengali":         "^[\u0980-\u09FF]+$",                           // Bengali
                "tibetan":         "^[\u0F00-\u0FFF]+$",                           // Tibetan
                "myanmar":         "^[\u1000-\u109F]+$",                           // Myanmar
                "chinese":         "^[\u4E00-\u9FFF]+$",                           // Chinese
                "hebrew":          "^[\u0590-\u05FF]+$",                           // Hebrew
                "devanagari":      "^[\u0900-\u097F]+$",                           // Devanagari
                "hangul":          "^[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F]+$", // Hangul
                "japanese":        "^[\u4E00-\u9FFF\u3040-\u309F\u30A0-\u30FF]+$", // Kanji, Hiragana, Katakana
                "thai":            "^[\u0E00-\u0E7F]+$",                           // Thai
                "ukrainian":       "^[А-Яа-яЁёІЇЄҐіїєґ]+$",                        // Cyrillic with Ukrainian-specific characters
        }

        // localeWritingSystems is the set of locales and their writing systems
        localeWritingSystems = map[string]string{
                "ar":          "arabic",
                "ar-AE":       "arabic",
                "ar-BH":       "arabic",
                "ar-DZ":       "arabic",
                "ar-EG":       "arabic",
                "ar-IQ":       "arabic",
                "ar-JO":       "arabic",
                "ar-KW":       "arabic",
                "ar-LB":       "arabic",
                "ar-LY":       "arabic",
                "ar-MA":       "arabic",
                "ar-QA":       "arabic",
                "ar-QM":       "arabic",
                "ar-SA":       "arabic",
                "ar-SD":       "arabic",
                "ar-SY":       "arabic",
                "ar-TN":       "arabic",
                "ar-YE":       "arabic",
                "bg-BG":       "cyrillic",
                "bn":          "bengali",
                "cs-CZ":       "latin_czech",
                "da-DK":       "latin_danish",
                "de-DE":       "latin_german",
                "el-GR":       "greek",
                "en-AU":       "latin",
                "en-GB":       "latin",
                "en-HK":       "latin",
                "en-IN":       "latin",
                "en-NZ":       "latin",
                "en-US":       "latin",
                "en-ZA":       "latin",
                "en-ZM":       "latin",
                "eo":          "latin_esperanto",
                "es-ES":       "latin_spanish",
                "fa-IR":       "arabic",
                "fi-FI":       "latin_finnish",
                "fr-CA":       "latin_french",
                "fr-FR":       "latin_french",
                "he":          "hebrew",
                "hi-IN":       "devanagari",
                "hu-HU":       "latin_hungarian",
                "it-IT":       "latin_italian",
                "kk-KZ":       "cyrillic",
                "ko-KR":       "hangul",
                "ja-JP":       "japanese",
                "ku-IQ":       "arabic",
                "nb-NO":       "latin_norwegian",
                "nl-NL":       "latin_dutch",
                "nn-NO":       "latin_norwegian",
                "pl-PL":       "latin_polish",
                "pt-BR":       "latin_portuguese",
                "pt-PT":       "latin_portuguese",
                "ru-RU":       "cyrillic",
                "si-LK":       "sinhala",
                "sl-SI":       "latin_slovenian",
                "sk-SK":       "latin_slovak",
                "sr-RS":       "cyrillic",
                "sr-RS@latin": "latin_serbian",
                "sv-SE":       "latin_swedish",
                "th-TH":       "thai",
                "tr-TR":       "latin_turkish",
                "uk-UA":       "ukrainian",
        }
)

// escapeRegexChars returns escaped regex special characters
func escapeRegexChars(str string) string <span class="cov8" title="1">{
        var escIgnChars strings.Builder

        for _, char := range str </span><span class="cov8" title="1">{
                charStr := string(char)
                escChar, ok := regexEscapes[charStr]

                if ok </span><span class="cov8" title="1">{
                        escIgnChars.WriteString(escChar)
                }</span> else<span class="cov8" title="1"> {
                        escIgnChars.WriteString(charStr)
                }</span>
        }

        <span class="cov8" title="1">return escIgnChars.String()</span>
}

// A validator that checks if the string contains only letters (a-zA-Z).
// locale is one of ('ar', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', 'ar-JO', 'ar-KW', 'ar-LB', 'ar-LY', 'ar-MA', 'ar-QA', 'ar-QM', 'ar-SA', 'ar-SD', 'ar-SY', 'ar-TN', 'ar-YE', 'bg-BG', 'bn', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-AU', 'en-GB', 'en-HK', 'en-IN', 'en-NZ', 'en-US', 'en-ZA', 'en-ZM', 'eo', 'es-ES', 'fa-IR', 'fi-FI', 'fr-CA', 'fr-FR', 'he', 'hi-IN', 'hu-HU', 'it-IT', 'kk-KZ', 'ko-KR', 'ja-JP', 'ku-IQ', 'nb-NO', 'nl-NL', 'nn-NO', 'pl-PL', 'pt-BR', 'pt-PT', 'ru-RU', 'si-LK', 'sl-SI', 'sk-SK', 'sr-RS', 'sr-RS@latin', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA') and defaults to en-US. Locale list is validator.isAlphaLocales. options is an optional object that can be supplied with the following key(s): ignore is the string to be ignored e.g. " -" will ignore spaces and -'s.
//
//        isAlpha := govalidator.IsAlpha("helloWORLD", govalidator.IsAlphaOpts{})
//        fmt.Println(isAlpha) // true
//        isAlpha := govalidator.IsAlpha("Привет", govalidator.IsAlphaOpts{Locale: "bg-BG"})
//        fmt.Println(isAlpha) // true
//        isAlpha := govalidator.IsAlpha("Hello89", govalidator.IsAlphaOpts{Ignore: "89"})
//        fmt.Println(isAlpha) // true
//        isAlpha := govalidator.IsAlpha("1Привет2", govalidator.IsAlphaOpts{Ignore: "12", Locale: "bg-BG"})
//        fmt.Println(isAlpha) // true
func IsAlpha(str string, opts IsAlphaOpts) bool <span class="cov8" title="1">{
        var (
                re                *regexp.Regexp
                defLocWrtSys      = "latin"
                lenClsCharFromEnd = 3
        )

        if opts.Ignore == "" &amp;&amp; opts.Locale == "" </span><span class="cov8" title="1">{
                re = regexp.MustCompile(`^[a-zA-z]+$`)
        }</span>

        <span class="cov8" title="1">if opts.Ignore == "" &amp;&amp; opts.Locale != "" </span><span class="cov8" title="1">{
                wrtSys, ok := localeWritingSystems[opts.Locale]
                if !ok </span><span class="cov8" title="1">{
                        wrtSys = defLocWrtSys
                }</span>
                <span class="cov8" title="1">re = regexp.MustCompile(writingSystemAlphaRegex[wrtSys])</span>
        }

        <span class="cov8" title="1">if opts.Ignore != "" &amp;&amp; opts.Locale == "" </span><span class="cov8" title="1">{
                charsToIgn := escapeRegexChars(opts.Ignore)
                rec, err := regexp.Compile(`^[a-zA-z` + charsToIgn + `]+$`)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">re = rec</span>
        }

        <span class="cov8" title="1">if opts.Ignore != "" &amp;&amp; opts.Locale != "" </span><span class="cov8" title="1">{
                charsToIgn := escapeRegexChars(opts.Ignore)
                wrtSys, ok := localeWritingSystems[opts.Locale]
                if !ok </span><span class="cov0" title="0">{
                        wrtSys = defLocWrtSys
                }</span>
                <span class="cov8" title="1">wrtSysRe := writingSystemAlphaRegex[wrtSys]
                divLen := len(wrtSysRe) - lenClsCharFromEnd
                fstPrtRe, secPrtRe := wrtSysRe[:divLen], wrtSysRe[divLen:]
                rec, err := regexp.Compile(fstPrtRe + charsToIgn + secPrtRe)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">re = rec</span>
        }

        <span class="cov8" title="1">return re.MatchString(str)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package validatorgo

import (
        "strconv"
        "unicode/utf8"
)

// A validator that checks if the string is an ABA routing number for US bank account / cheque.
//
//        ok := govalidator.IsAbaRouting("123456789")
//        fmt.Println(ok) // false
//        ok := govalidator.IsAbaRouting("021000021")
//        fmt.Println(ok) // true
func IsAbaRouting(str string) bool <span class="cov8" title="1">{
        strWithoutDashes := stripDashesAndSpaces(str)

        if utf8.RuneCountInString(strWithoutDashes) != 9 || !IsNumeric(strWithoutDashes, IsNumericOpts{NoSymbols: true}) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">digits := make([]int, 9)

        for i, char := range strWithoutDashes </span><span class="cov8" title="1">{
                digit, err := strconv.Atoi(string(char))
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">digits[i] = digit</span>
        }

        <span class="cov8" title="1">checksum := 3*(digits[0]+digits[3]+digits[6]) + 7*(digits[1]+digits[4]+digits[7]) + 1*(digits[2]+digits[5]+digits[8])

        return checksum%10 == 0</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package validatorgo

import (
        "time"

        "github.com/bube054/validatorgo/sanitizers"
)

// A validator that checks if the string is a date that is after the specified date.
// comparisonDate defaults to the current time.
// string layouts for str and comparisonDate can be different layout.
// these are the only valid layouts from the time package e.g Layout, ANSIC, UnixDate, RubyDate, RFC822, RFC822Z, RFC850, RFC1123, RFC1123Z, Kitchen, Stamp, StampMilli, StampMicro, StampNano, DateTime, DateOnly, TimeOnly
//
//        ok := govalidator.IsAfter("2009-06-02", "2007-01-02")
//        fmt.Println(ok) // true
//        ok = govalidator.IsAfter("2020-04-03", "")
//        fmt.Println(ok) // false
func IsAfter(str string, comparisonDate string) bool <span class="cov8" title="1">{
        date1 := sanitizers.ToDate(str)

        var date2 *time.Time
        if comparisonDate == "" </span><span class="cov8" title="1">{
                now := time.Now()
                date2 = &amp;now
        }</span> else<span class="cov8" title="1"> {
                date2 = sanitizers.ToDate(comparisonDate)
        }</span>

        <span class="cov8" title="1">if date1 == nil || date2 == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return date1.After(*date2)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package validatorgo

import (
        "regexp"
)

// IsAlphanumericOpts is used to configure IsAlpha
type IsAlphanumericOpts struct {
        Ignore string
        Locale string
}

// writingSystemAlphaNumRegex is the set of common writing systems and their validating alphanumeric regex
var writingSystemAlphaNumRegex = map[string]string{
        "arabic":          "^[A-Za-z0-9\u0600-\u06FF\u0750-\u077F]+$",              // Alphanumeric + Arabic
        "latin":           "^[A-Za-z0-9]+$",                                        // Alphanumeric (Latin)
        "latin_czech":     "^[A-Za-z0-9ÁČĎÉĚÍŇÓŘŠŤÚŮÝŽáčďéěíňóřšťúůýž]+$",          // Alphanumeric + Latin with Czech-specific characters
        "latin_danish":    "^[A-Za-z0-9ÆØÅæøå]+$",                                  // Alphanumeric + Latin with Danish-specific characters
        "latin_german":    "^[A-Za-z0-9ÄÖÜßäöü]+$",                                 // Alphanumeric + Latin with German-specific characters
        "latin_spanish":   "^[A-Za-z0-9ÁÉÍÑÓÚÜáéíñóúü]+$",                          // Alphanumeric + Latin with Spanish-specific characters
        "latin_french":    "^[A-Za-z0-9ÀÂÇÉÈÊËÎÏÔŒÙÛÜŸàâçéèêëîïôœùûüÿ]+$",          // Alphanumeric + Latin with French-specific characters
        "latin_esperanto": "^[A-Za-z0-9ĈĜĤĴŜŬĉĝĥĵŝŭ]+$",                            // Alphanumeric + Latin with Esperanto-specific characters
        "cyrillic":        "^[A-Za-z0-9А-Яа-яЁё]+$",                                // Alphanumeric + Cyrillic
        "greek":           "^[A-Za-z0-9Α-Ωα-ω]+$",                                  // Alphanumeric + Greek
        "armenian":        "^[A-Za-z0-9\u0530-\u058F]+$",                           // Alphanumeric + Armenian
        "bengali":         "^[A-Za-z0-9\u0980-\u09FF]+$",                           // Alphanumeric + Bengali
        "tibetan":         "^[A-Za-z0-9\u0F00-\u0FFF]+$",                           // Alphanumeric + Tibetan
        "myanmar":         "^[A-Za-z0-9\u1000-\u109F]+$",                           // Alphanumeric + Myanmar
        "chinese":         "^[A-Za-z0-9\u4E00-\u9FFF]+$",                           // Alphanumeric + Chinese
        "hebrew":          "^[A-Za-z0-9\u0590-\u05FF]+$",                           // Alphanumeric + Hebrew
        "devanagari":      "^[A-Za-z0-9\u0900-\u097F]+$",                           // Alphanumeric + Devanagari
        "hangul":          "^[A-Za-z0-9\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F]+$", // Alphanumeric + Hangul
        "japanese":        "^[A-Za-z0-9\u4E00-\u9FFF\u3040-\u309F\u30A0-\u30FF]+$", // Alphanumeric + Kanji, Hiragana, Katakana
        "thai":            "^[A-Za-z0-9\u0E00-\u0E7F]+$",                           // Alphanumeric + Thai
        "ukrainian":       "^[A-Za-z0-9А-Яа-яЁёІЇЄҐіїєґ]+$",                        // Alphanumeric + Cyrillic with Ukrainian-specific characters
}

// A validator that checks if the string contains only letters and numbers (a-zA-Z0-9).
// locale is one of ('ar', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', 'ar-JO', 'ar-KW', 'ar-LB', 'ar-LY', 'ar-MA', 'ar-QA', 'ar-QM', 'ar-SA', 'ar-SD', 'ar-SY', 'ar-TN', 'ar-YE', 'bg-BG', 'bn', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-AU', 'en-GB', 'en-HK', 'en-IN', 'en-NZ', 'en-US', 'en-ZA', 'en-ZM', 'eo', 'es-ES', 'fa-IR', 'fi-FI', 'fr-CA', 'fr-FR', 'he', 'hi-IN', 'hu-HU', 'it-IT', 'kk-KZ', 'ko-KR', 'ja-JP', 'ku-IQ', 'nb-NO', 'nl-NL', 'nn-NO', 'pl-PL', 'pt-BR', 'pt-PT', 'ru-RU', 'si-LK', 'sl-SI', 'sk-SK', 'sr-RS', 'sr-RS@latin', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA') and defaults to en-US. Locale list is validator.isAlphaLocales. options is an optional object that can be supplied with the following key(s): ignore is the string to be ignored e.g. " -" will ignore spaces and -'s.
//
//        isAlpha := govalidator.IsAlphanumeric("helloWORLD", govalidator.IsAlphanumericOpts{})
//        fmt.Println(isAlpha) // true
//        isAlpha := govalidator.IsAlphanumeric("7889gygu", govalidator.IsAlphanumericOpts{Locale: "bg-BG"})
//        fmt.Println(isAlpha) // true
//        isAlpha := govalidator.IsAlphanumeric("1Hello23", govalidator.IsAlphanumericOpts{Ignore: "^"})
//        fmt.Println(isAlpha) // true
//        isAlpha := govalidator.IsAlphanumeric("Привет89a", govalidator.IsAlphanumericOpts{Ignore: "89a", Locale: "bg-BG"})
//        fmt.Println(isAlpha) // true
func IsAlphanumeric(str string, opts IsAlphanumericOpts) bool <span class="cov8" title="1">{
        var (
                re                *regexp.Regexp
                defLocWrtSys      = "latin"
                lenClsCharFromEnd = 3
        )

        if opts.Ignore == "" &amp;&amp; opts.Locale == "" </span><span class="cov8" title="1">{
                re = regexp.MustCompile(`^[a-zA-z0-9]+$`)
        }</span>

        <span class="cov8" title="1">if opts.Ignore == "" &amp;&amp; opts.Locale != "" </span><span class="cov8" title="1">{
                wrtSys, ok := localeWritingSystems[opts.Locale]
                if !ok </span><span class="cov8" title="1">{
                        wrtSys = defLocWrtSys
                }</span>
                <span class="cov8" title="1">re = regexp.MustCompile(writingSystemAlphaNumRegex[wrtSys])</span>
        }

        <span class="cov8" title="1">if opts.Ignore != "" &amp;&amp; opts.Locale == "" </span><span class="cov8" title="1">{
                charsToIgn := escapeRegexChars(opts.Ignore)
                rec, err := regexp.Compile(`^[a-zA-z0-9` + charsToIgn + `]+$`)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">re = rec</span>
        }

        <span class="cov8" title="1">if opts.Ignore != "" &amp;&amp; opts.Locale != "" </span><span class="cov8" title="1">{
                charsToIgn := escapeRegexChars(opts.Ignore)
                wrtSys, ok := localeWritingSystems[opts.Locale]
                if !ok </span><span class="cov0" title="0">{
                        wrtSys = defLocWrtSys
                }</span>
                <span class="cov8" title="1">wrtSysRe := writingSystemAlphaNumRegex[wrtSys]
                divLen := len(wrtSysRe) - lenClsCharFromEnd
                fstPrtRe, secPrtRe := wrtSysRe[:divLen], wrtSysRe[divLen:]
                rec, err := regexp.Compile(fstPrtRe + charsToIgn + secPrtRe)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">re = rec</span>
        }

        <span class="cov8" title="1">return re.MatchString(str)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string contains ASCII chars only.
//        ok := govalidator.IsAscii("Hello")
//        fmt.Println(ok) // true
func IsAscii(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile("^[ -~]+$").MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package validatorgo

import (
        "regexp"
        "strings"
)

// IsBase32Opts is used to configure IsBase32
type IsBase32Opts struct {
        Crockford bool
}

// A validator that checks if the string is base32 encoded.
// IsBase32Opts defaults to { crockford: false }.
// When crockford is true it tests the given base32 encoded string using Crockford's base32 alternative(http://www.crockford.com/base32.html).
func IsBase32(str string, opts IsBase32Opts) bool <span class="cov8" title="1">{
        str = strings.TrimRight(str, "=")

        base32Regex := "^[A-Z2-7]+$"
        crockfordRegex := "^[A-HJ-KM-NP-TV-Z0-9]+$"

        if opts.Crockford </span><span class="cov8" title="1">{
                return regexp.MustCompile(crockfordRegex).MatchString(strings.ToUpper(str))
        }</span> else<span class="cov8" title="1"> {
                return regexp.MustCompile(base32Regex).MatchString(str)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package validatorgo

import (
        "regexp"
)

// A validator that checks if the string is base58 encoded.
func IsBase58(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile("^[A-HJ-NP-Za-km-z1-9]*$").MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package validatorgo

import (
        "regexp"
)

// IsBase64Opts is used to configure IsBase64
type IsBase64Opts struct {
        UrlSafe bool
}

// A validator that checks if the string is base64 encoded. options is optional and defaults to { urlSafe: false }
// when urlSafe is true it tests the given base64 encoded string is url safe.
func IsBase64(str string, opts IsBase64Opts) bool <span class="cov8" title="1">{
        base64Regex := "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$"
        urlSafeRegex := "^(?:[A-Za-z0-9_-]{4})*(?:[A-Za-z0-9_-]{2}(?:==)?|[A-Za-z0-9_-]{3}=?)?$"

        if opts.UrlSafe </span><span class="cov8" title="1">{
                return regexp.MustCompile(urlSafeRegex).MatchString(str)
        }</span> else<span class="cov8" title="1"> {
                return regexp.MustCompile(base64Regex).MatchString(str)
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package validatorgo

import (
        "time"

        "github.com/bube054/validatorgo/sanitizers"
)

// A validator that checks if the string is a date that is before the specified date.
// comparisonDate defaults to the current time.
// string layouts for str and comparisonDate can be different layout.
// these are the only valid layouts from the time package e.g Layout, ANSIC, UnixDate, RubyDate, RFC822, RFC822Z, RFC850, RFC1123, RFC1123Z, Kitchen, Stamp, StampMilli, StampMicro, StampNano, DateTime, DateOnly, TimeOnly
//
//        ok := govalidator.IsBefore("2009-06-02", "2007-01-02")
//        fmt.Println(ok) // false
//        ok = govalidator.IsBefore("2020-04-03", "")
//        fmt.Println(ok) // true
func IsBefore(str string, comparisonDate string) bool <span class="cov8" title="1">{
        date1 := sanitizers.ToDate(str)

        var date2 *time.Time
        if comparisonDate == "" </span><span class="cov8" title="1">{
                now := time.Now()
                date2 = &amp;now
        }</span> else<span class="cov8" title="1"> {
                date2 = sanitizers.ToDate(comparisonDate)
        }</span>

        <span class="cov8" title="1">if date1 == nil || date2 == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return date1.Before(*date2)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string is a BIC (Bank Identification Code) or SWIFT code.
func IsBic(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile("^[A-Z]{4}(AF|AX|AL|DZ|AS|AD|AO|AI|AQ|AG|AR|AM|AW|AU|AT|AZ|BS|BH|BD|BB|BY|BE|BZ|BJ|BM|BT|BO|BQ|BA|BW|BV|BR|IO|BN|BG|BF|BI|CV|KH|CM|CA|KY|CF|TD|CL|CN|CX|CC|CO|KM|CG|CD|CK|CR|CI|HR|CU|CW|CY|CZ|DK|DJ|DM|DO|EC|EG|SV|GQ|ER|EE|SZ|ET|FK|FO|FJ|FI|FR|GF|PF|TF|GA|GM|GE|DE|GH|GI|GR|GL|GD|GP|GU|GT|GG|GN|GW|GY|HT|HM|VA|HN|HK|HU|IS|IN|ID|IR|IQ|IE|IM|IL|IT|JM|JP|JE|JO|KZ|KE|KI|KP|KR|KW|KG|LA|LV|LB|LS|LR|LY|LI|LT|LU|MO|MG|MW|MY|MV|ML|MT|MH|MQ|MR|MU|YT|MX|FM|MD|MC|MN|ME|MS|MA|MZ|MM|NA|NR|NP|NL|NC|NZ|NI|NE|NG|NU|NF|MK|MP|NO|OM|PK|PW|PS|PA|PG|PY|PE|PH|PN|PL|PT|PR|QA|RE|RO|RU|RW|BL|SH|KN|LC|MF|PM|VC|WS|SM|ST|SA|SN|RS|SC|SL|SG|SX|SK|SI|SB|SO|ZA|GS|SS|ES|LK|SD|SR|SJ|SE|CH|SY|TW|TJ|TZ|TH|TL|TG|TK|TO|TT|TN|TR|TM|TC|TV|UG|UA|AE|GB|US|UM|UY|UZ|VU|VE|VN|VG|VI|WF|EH|YE|ZM|ZW)[0-9A-Z]{2}([A-Z0-9]{3})?$").MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package validatorgo

import "regexp"

// IsBooleanOpts is used to configure IsBoolean
type IsBooleanOpts struct {
        Loose bool
}

// A validator that check if the string is a boolean.
// IsBooleanOpts is a struct which defaults to { Loose: false }. If Loose is set to false, the validator will strictly match ['true', 'false', '0', '1'].
// If Loose is set to true, the validator will also match 'yes', 'no', and will match a valid boolean string of any case. (e.g.: ['true', 'True', 'TRUE', "false", "False", "FALSE"]).
func IsBoolean(str string, opts IsBooleanOpts) bool <span class="cov8" title="1">{
        if opts.Loose </span><span class="cov8" title="1">{
                return regexp.MustCompile("^(true|True|TRUE|false|False|FALSE|yes|no|0|1)$").MatchString(str)
        }</span> else<span class="cov8" title="1"> {
                return regexp.MustCompile("^(true|false|0|1)$").MatchString(str)
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string is a valid BTC address.
func IsBTCAddress(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile("^(bc1|[13])[a-km-zA-HJ-NP-Z1-9]{25,34}$").MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package validatorgo

// IsByteLengthOpts is used to configure IsByteLength
type IsByteLengthOpts struct {
        Min uint
        Max *uint
}

// A validator that checks if the string's length (in UTF-8 bytes) falls in a range.
// options is a struct which defaults to { Min: 0, Max: nil }.
func IsByteLength(str string, opts IsByteLengthOpts) bool <span class="cov8" title="1">{
        lenInBytes := len(str)
        if opts.Max == nil </span><span class="cov8" title="1">{
                return lenInBytes &gt;= int(opts.Min)
        }</span> else<span class="cov8" title="1"> {
                return lenInBytes &gt;= int(opts.Min) &amp;&amp; lenInBytes &lt;= int(*opts.Max)
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package validatorgo

var AllCountryCodes = [...]string{"AF", "AL", "DZ", "AS", "AD", "AO", "AI", "AQ", "AG", "AR", "AM", "AW", "AU", "AT", "AZ", "BS", "BH", "BD", "BB", "BY", "BE", "BZ", "BJ", "BM", "BT", "BO", "BA", "BW", "BV", "BR", "IO", "BN", "BG", "BF", "BI", "KH", "CM", "CA", "CV", "KY", "CF", "TD", "CL", "CN", "CX", "CC", "CO", "KM", "CG", "CD", "CK", "CR", "CI", "HR", "CU", "CY", "CZ", "DK", "DJ", "DM", "DO", "EC", "EG", "SV", "GQ", "ER", "EE", "ET", "FK", "FO", "FJ", "FI", "FR", "GF", "PF", "TF", "GA", "GM", "GE", "DE", "GH", "GI", "GR", "GL", "GD", "GP", "GU", "GT", "GN", "GW", "GY", "HT", "HM", "HN", "HK", "HU", "IS", "IN", "ID", "IR", "IQ", "IE", "IL", "IT", "JM", "JP", "JO", "KZ", "KE", "KI", "KP", "KR", "KW", "KG", "LA", "LV", "LB", "LS", "LR", "LY", "LI", "LT", "LU", "MO", "MG", "MW", "MY", "MV", "ML", "MT", "MH", "MQ", "MR", "MU", "YT", "MX", "FM", "MD", "MC", "MN", "MS", "MA", "MZ", "MM", "NA", "NR", "NP", "NL", "AN", "NC", "NZ", "NI", "NE", "NG", "NU", "NF", "MP", "NO", "OM", "PK", "PW", "PA", "PG", "PY", "PE", "PH", "PN", "PL", "PT", "PR", "QA", "RE", "RO", "RU", "RW", "SH", "KN", "LC", "PM", "VC", "WS", "SM", "ST", "SA", "SN", "CS", "SC", "SL", "SG", "SK", "SI", "SB", "SO", "ZA", "GS", "ES", "LK", "SD", "SR", "SJ", "SZ", "SE", "CH", "SY", "TW", "TJ", "TZ", "TH", "TL", "TG", "TK", "TO", "TT", "TN", "TR", "TM", "TC", "TV", "UG", "UA", "AE", "GB", "US", "UM", "UY", "UZ", "VU", "VA", "VE", "VN", "VG", "VI", "WF", "EH", "YE", "ZM", "ZW"}

// A validator that checks if the string is a country code.
func IsCountryCode(str string) bool <span class="cov8" title="1">{
        return IsIn(str, AllCountryCodes[:])

}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package validatorgo

import "regexp"

// IsCreditCardOpts is used to configure IsCreditCard
type IsCreditCardOpts struct {
        Provider string
}

var creditCardProviderRegex = map[string]string{
        "amex":           "^3[47][0-9]{13}$",
        "bcglobal":       "^(6541|6556)[0-9]{12}$",
        "carteblanche":   "^389[0-9]{11}$",
        "dinersclub":     "^3(?:0[0-5]|[68][0-9])[0-9]{11}$",
        "discover":       "^65[4-9][0-9]{13}|64[4-9][0-9]{13}|6011[0-9]{12}|(622(?:12[6-9]|1[3-9][0-9]|[2-8][0-9][0-9]|9[01][0-9]|92[0-5])[0-9]{10})$",
        "instapayment":   "^63[7-9][0-9]{13}$",
        "jcb":            "^(?:2131|1800|35\\d{3})\\d{11}$",
        "koreanlocal":    "^9[0-9]{15}$",
        "laser":          "^(6304|6706|6709|6771)[0-9]{12,15}$",
        "maestro":        "^(5018|5020|5038|6304|6759|6761|6763)[0-9]{8,15}$",
        "mastercard":     "^(5[1-5][0-9]{14}|2(22[1-9][0-9]{12}|2[3-9][0-9]{13}|[3-6][0-9]{14}|7[0-1][0-9]{13}|720[0-9]{12}))$",
        "solo":           "^(6334|6767)[0-9]{12}|(6334|6767)[0-9]{14}|(6334|6767)[0-9]{15}$",
        "switch":         "^(4903|4905|4911|4936|6333|6759)[0-9]{12}|(4903|4905|4911|4936|6333|6759)[0-9]{14}|(4903|4905|4911|4936|6333|6759)[0-9]{15}|564182[0-9]{10}|564182[0-9]{12}|564182[0-9]{13}|633110[0-9]{10}|633110[0-9]{12}|633110[0-9]{13}$",
        "unionpay":       "^(62[0-9]{14,17})$",
        "visa":           "^4[0-9]{12}(?:[0-9]{3})?$",
        "visamastercard": "^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14})$",
}

// A validator that checks if the string is a credit card number.
// options is an struct that can be supplied with the following key(s): Provider is a key whose value should be a string, and defines the company issuing the credit card.
// Valid values include amex, bcglobal, carteblanche, dinersclub, discover, instapayment, jcb, koreanlocal, laser, maestro, mastercard, solo, switch, unionpay, visa, visamastercard or blank will check for any provider.
func IsCreditCard(str string, opts IsCreditCardOpts) bool <span class="cov8" title="1">{
        reStr, ok := creditCardProviderRegex[opts.Provider]

        if !ok </span><span class="cov0" title="0">{
                for _, val := range creditCardProviderRegex </span><span class="cov0" title="0">{
                        if isVal := regexp.MustCompile(val).MatchString(str); isVal </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                return regexp.MustCompile(reStr).MatchString(str)
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package validatorgo

import (
        "regexp"
        "strconv"
)

type IsCurrencyOpts struct {
        // deals with the options for currency
        Symbol                string // '$10.50'
        RequireSymbol         bool   // $10.50
        AllowSpaceAfterSymbol bool   // $ 10.50
        SymbolAfterDigits     bool   // 10.50$

        // deals with the numeric signs
        AllowNegatives               bool // -$10.50
        ParensForNegatives           bool // ($10.50)
        NegativeSignBeforeDigits     bool // $-10.50
        NegativeSignAfterDigits      bool // $10.50-
        AllowNegativeSignPlaceholder bool // $ 10.50

        // deals with the decimals/separator
        ThousandSeparator     string // 10,000.50
        DecimalSeparator      string // 10.50
        AllowDecimal          bool   // $10.00
        RequireDecimal        bool   // $10.00
        DigitsAfterDecimal    []int  // $10.50 []
        AllowSpaceAfterDigits bool   // '$ 10.50
}

func getMaxDigits(digits []int) string <span class="cov0" title="0">{
        if len(digits) == 0 </span><span class="cov0" title="0">{
                return "2"
        }</span>
        <span class="cov0" title="0">return strconv.Itoa(digits[len(digits)-1])</span>
}

func getMinDigits(digits []int) string <span class="cov0" title="0">{
        if len(digits) == 0 </span><span class="cov0" title="0">{
                return "0"
        }</span>
        <span class="cov0" title="0">return strconv.Itoa(digits[0])</span>
}

// A validator that checks if the string is a valid currency amount.
// options is a struct which defaults to { Symbol: '$', RequireSymbol: false, AllowSpaceAfterSymbol: false, SymbolAfterDigits: false, AllowNegatives: true, ParensForNegatives: false, NegativeSignBeforeDigits: false, NegativeSignAfterDigits: false, AllowNegativeSignPlaceholder: false, ThousandsSeparator: ',', DecimalSeparator: '.', AllowDecimal: true, RequireDecimal: false, DigitsAfterDecimal: [2], AllowSpaceAfterDigits: false }.
// Note: The array digits_after_decimal is filled with the exact number of digits allowed not a range, for example a range 1 to 3 will be given as [1, 2, 3].

func IsCurrency(str string, opts IsCurrencyOpts) bool <span class="cov8" title="1">{
        // Build the regex pattern based on options
        symbol := regexp.QuoteMeta(opts.Symbol)
        decimalSeparator := regexp.QuoteMeta(opts.DecimalSeparator)
        thousandSeparator := regexp.QuoteMeta(opts.ThousandSeparator)

        symbolPattern := ""
        if opts.RequireSymbol </span><span class="cov0" title="0">{
                symbolPattern = symbol
                if opts.AllowSpaceAfterSymbol </span><span class="cov0" title="0">{
                        symbolPattern += "\\s?"
                }</span>
        } else<span class="cov8" title="1"> {
                symbolPattern = symbol + "?\\s*"
        }</span>

        <span class="cov8" title="1">negativesPattern := ""
        if opts.AllowNegatives </span><span class="cov0" title="0">{
                if opts.ParensForNegatives </span><span class="cov0" title="0">{
                        negativesPattern = "\\(?"
                }</span> else<span class="cov0" title="0"> if opts.NegativeSignBeforeDigits </span><span class="cov0" title="0">{
                        negativesPattern = "[-"
                }</span>
        }

        <span class="cov8" title="1">if opts.AllowNegativeSignPlaceholder </span><span class="cov0" title="0">{
                negativesPattern += " ?"
        }</span> else<span class="cov8" title="1"> if opts.NegativeSignAfterDigits </span><span class="cov0" title="0">{
                negativesPattern = ""
        }</span>

        <span class="cov8" title="1">if opts.ParensForNegatives </span><span class="cov0" title="0">{
                negativesPattern += "\\)?"
        }</span>

        <span class="cov8" title="1">decimalPattern := ""
        if opts.AllowDecimal </span><span class="cov0" title="0">{
                decimalPattern = decimalSeparator + "\\d{1," + getMaxDigits(opts.DigitsAfterDecimal) + "}"
                if opts.RequireDecimal </span><span class="cov0" title="0">{
                        decimalPattern = decimalSeparator + "\\d{" + getMinDigits(opts.DigitsAfterDecimal) + "," + getMaxDigits(opts.DigitsAfterDecimal) + "}"
                }</span>
        } else<span class="cov8" title="1"> {
                decimalPattern = ""
        }</span>

        <span class="cov8" title="1">thousandsPattern := ""
        if thousandSeparator != "" </span><span class="cov0" title="0">{
                thousandsPattern = "(?:(?:\\d{1,3}(?:\\" + thousandSeparator + "\\d{3})*)|\\d+)"
        }</span> else<span class="cov8" title="1"> {
                thousandsPattern = "\\d+"
        }</span>

        <span class="cov8" title="1">suffix := ""
        if opts.SymbolAfterDigits </span><span class="cov0" title="0">{
                suffix = symbol
        }</span>

        <span class="cov8" title="1">if opts.AllowSpaceAfterDigits </span><span class="cov0" title="0">{
                suffix += "\\s*"
        }</span>

        <span class="cov8" title="1">pattern := "^" + symbolPattern + negativesPattern + thousandsPattern + decimalPattern + negativesPattern + suffix + "$"

        re := regexp.MustCompile(pattern)
        return re.MatchString(str)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string is a data uri format.
func IsDataURI(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile(`data:([-\w]+\/[-+\w.]+)?(;?\w+=[-\w]+)*(;base64)?,.*`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package validatorgo

import (
        "regexp"
)

type IsDateOpts struct {
        Format     string
        StrictMode bool
}

const (
        ISO8601       = "2006-01-02"              // YYYY-MM-DD
        USFormat      = "01/02/2006"              // MM/DD/YYYY
        EUFormat      = "02/01/2006"              // DD/MM/YYYY
        JapanFormat   = "2006年01月02日"             // YYYY年MM月DD日
        LongForm      = "January 02, 2006"        // Month DD, YYYY
        ShortForm     = "02-Jan-2006"             // DD-MMM-YYYY
        NoDelim       = "20060102"                // YYYYMMDD
        WeekDay       = "Monday, 02 January 2006" // Day, DD Month YYYY
        YearMonth     = "2006-01"                 // YYYY-MM
        UnixTimestamp = "2006-01-02 15:04:05"     // Full date and time
)

var dateFormatRegex = map[string]*regexp.Regexp{
        ISO8601:       regexp.MustCompile(`^\d{4}-\d{2}-\d{2}$`),                   // YYYY-MM-DD
        USFormat:      regexp.MustCompile(`^\d{2}/\d{2}/\d{4}$`),                   // MM/DD/YYYY
        EUFormat:      regexp.MustCompile(`^\d{2}/\d{2}/\d{4}$`),                   // DD/MM/YYYY
        JapanFormat:   regexp.MustCompile(`^\d{4}年\d{2}月\d{2}日$`),                  // YYYY年MM月DD日
        LongForm:      regexp.MustCompile(`^[A-Za-z]+ \d{2}, \d{4}$`),              // Month DD, YYYY
        ShortForm:     regexp.MustCompile(`^\d{2}-[A-Za-z]{3}-\d{4}$`),             // DD-MMM-YYYY
        NoDelim:       regexp.MustCompile(`^\d{8}$`),                               // YYYYMMDD
        WeekDay:       regexp.MustCompile(`^[A-Za-z]+, \d{2} [A-Za-z]+ \d{4}$`),    // Day, DD Month YYYY
        YearMonth:     regexp.MustCompile(`^\d{4}-\d{2}$`),                         // YYYY-MM
        UnixTimestamp: regexp.MustCompile(`^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$`), // Full date and time
}

func dateMatchesAnyFormat(str string) bool <span class="cov8" title="1">{
        for _, format := range dateFormatRegex </span><span class="cov8" title="1">{
                matches := format.MatchString(str)
                if matches </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// A Validator that checks if the string is a valid date. e.g. 2002-07-15.
// ISO8601 is a struct which can contain the keys format, strictMode.
// format is a string and defaults to ginvalidator.ISO8601 if not provided or found.
// strictMode is a boolean and defaults to false. If strictMode is set to true, the validator will reject strings different from format.
func IsDate(str string, opts IsDateOpts) bool <span class="cov8" title="1">{
        switch opts.Format </span>{
        case ISO8601, USFormat, EUFormat, JapanFormat, LongForm, ShortForm, NoDelim, WeekDay, YearMonth, UnixTimestamp:<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1">
                opts.Format = ISO8601</span>
        }

        <span class="cov8" title="1">if opts.StrictMode </span><span class="cov8" title="1">{
                return dateFormatRegex[opts.Format].MatchString(str)
        }</span> else<span class="cov8" title="1"> {
                return dateMatchesAnyFormat(str)
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package validatorgo

import (
        "fmt"
        "regexp"
)

// DecimalDigits is used to configure IsDecimalOpts
type DecimalDigits struct {
        Min uint
        Max uint
}

// IsDecimalOpts is used to configure IsDecimal
type IsDecimalOpts struct {
        ForceDecimal bool
        DecimalDigits
        Locale string
}

// decimalFormats is the set of decimal formats and their validating functions
var decimalFormats = map[string]func(IsDecimalOpts) *regexp.Regexp{
        "dot_decimal_comma_thousands": func(ido IsDecimalOpts) *regexp.Regexp <span class="cov8" title="1">{ // 1,234.56
                var q = "?"
                if ido.ForceDecimal </span><span class="cov8" title="1">{
                        q = ""
                }</span>
                <span class="cov8" title="1">return regexp.MustCompile(fmt.Sprintf(`^[+-]?(\d{1,3}(,\d{3})*)?(\.\d{%d,%d})%s$`, ido.DecimalDigits.Min, ido.DecimalDigits.Max, q))</span>
        },
        "comma_decimal_dot_thousands": func(ido IsDecimalOpts) *regexp.Regexp <span class="cov0" title="0">{ // 1.234,56
                var q = "?"
                if ido.ForceDecimal </span><span class="cov0" title="0">{
                        q = ""
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(fmt.Sprintf(`^[+-]?(\d{1,3}(\.\d{3})*)?(\,\d{%d,%d})%s$`, ido.DecimalDigits.Min, ido.DecimalDigits.Max, q))</span>
        },
        "comma_decimal_space_thousands": func(ido IsDecimalOpts) *regexp.Regexp <span class="cov0" title="0">{ // 1 234,56
                var q = "?"
                if ido.ForceDecimal </span><span class="cov0" title="0">{
                        q = ""
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(fmt.Sprintf(`^[+-]?(\d{1,3}( \d{3})*)?(\,\d{%d,%d})%s$`, ido.DecimalDigits.Min, ido.DecimalDigits.Max, q))</span>
        },
        "dot_decimal_space_thousands": func(ido IsDecimalOpts) *regexp.Regexp <span class="cov0" title="0">{ // 1 234.56
                var q = "?"
                if ido.ForceDecimal </span><span class="cov0" title="0">{
                        q = ""
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(fmt.Sprintf(`^[+-]?(\d{1,3}( \d{3})*)?(\.\d{%d,%d})%s$`, ido.DecimalDigits.Min, ido.DecimalDigits.Max, q))</span>
        },
        "dot_decimal_apostrophe_thousands": func(ido IsDecimalOpts) *regexp.Regexp <span class="cov0" title="0">{ // 1'234.56
                var q = "?"
                if ido.ForceDecimal </span><span class="cov0" title="0">{
                        q = ""
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(fmt.Sprintf(`^[+-]?(\d{1,3}('\d{3})*)?(\.\d{%d,%d})%s$`, ido.DecimalDigits.Min, ido.DecimalDigits.Max, q))</span>
        },
        "comma_decimal_apostrophe_thousands": func(ido IsDecimalOpts) *regexp.Regexp <span class="cov0" title="0">{ // 1'234,56
                var q = "?"
                if ido.ForceDecimal </span><span class="cov0" title="0">{
                        q = ""
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(fmt.Sprintf(`^[+-]?(\d{1,3}('\d{3})*)?(\,\d{%d,%d})%s$`, ido.DecimalDigits.Min, ido.DecimalDigits.Max, q))</span>
        },
        "dot_decimal_no_thousands": func(ido IsDecimalOpts) *regexp.Regexp <span class="cov0" title="0">{ // 123456.78
                var q = "?"
                if ido.ForceDecimal </span><span class="cov0" title="0">{
                        q = ""
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(fmt.Sprintf(`^[+-]?(\d*)?(\.\d{%d,%d})%s$`, ido.DecimalDigits.Min, ido.DecimalDigits.Max, q))</span>
        },
        "comma_decimal_no_thousands": func(ido IsDecimalOpts) *regexp.Regexp <span class="cov0" title="0">{ // 123456,78
                var q = "?"
                if ido.ForceDecimal </span><span class="cov0" title="0">{
                        q = ""
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(fmt.Sprintf(`^[+-]?(\d*)?(\,\d{%d,%d})%s$`, ido.DecimalDigits.Min, ido.DecimalDigits.Max, q))</span>
        },
        "indian_numbering_system": func(ido IsDecimalOpts) *regexp.Regexp <span class="cov0" title="0">{ // 1,23,456.78
                var q = "?"
                if ido.ForceDecimal </span><span class="cov0" title="0">{
                        q = ""
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(fmt.Sprintf(`^[+-]?(\d{1,2}(,\d{2})*(,\d{3}))?(\.\d{%d,%d})%s$`, ido.DecimalDigits.Min, ido.DecimalDigits.Max, q))</span>
        },
        "arabic_numerals_dot_decimal": func(ido IsDecimalOpts) *regexp.Regexp <span class="cov0" title="0">{ // ١٫٢٣٤,٥٦
                var q = "?"
                if ido.ForceDecimal </span><span class="cov0" title="0">{
                        q = ""
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(fmt.Sprintf(`^[+-]?[٠١٢٣٤٥٦٧٨٩]*(\.[٠١٢٣٤٥٦٧٨٩]{%d,%d})%s$`, ido.DecimalDigits.Min, ido.DecimalDigits.Max, q))</span>
        },
        "arabic_numerals_comma_decimal": func(ido IsDecimalOpts) *regexp.Regexp <span class="cov0" title="0">{ // ١٬٢٣٤٫٥٦
                var q = "?"
                if ido.ForceDecimal </span><span class="cov0" title="0">{
                        q = ""
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(fmt.Sprintf(`^[+-]?[٠١٢٣٤٥٦٧٨٩]*(٬[٠١٢٣٤٥٦٧٨٩]{%d,%d})%s$`, ido.DecimalDigits.Min, ido.DecimalDigits.Max, q))</span>
        },
}

// localeDecimalFormats is the set of Locales and their decimal formats
var localeDecimalFormats = map[string]string{
        "ar":          "arabic_numerals_dot_decimal",
        "ar-AE":       "arabic_numerals_dot_decimal",
        "ar-BH":       "arabic_numerals_dot_decimal",
        "ar-DZ":       "arabic_numerals_dot_decimal",
        "ar-EG":       "arabic_numerals_dot_decimal",
        "ar-IQ":       "arabic_numerals_dot_decimal",
        "ar-JO":       "arabic_numerals_dot_decimal",
        "ar-KW":       "arabic_numerals_dot_decimal",
        "ar-LB":       "arabic_numerals_dot_decimal",
        "ar-LY":       "arabic_numerals_dot_decimal",
        "ar-MA":       "arabic_numerals_dot_decimal",
        "ar-QA":       "arabic_numerals_dot_decimal",
        "ar-QM":       "arabic_numerals_dot_decimal",
        "ar-SA":       "arabic_numerals_dot_decimal",
        "ar-SD":       "arabic_numerals_dot_decimal",
        "ar-SY":       "arabic_numerals_dot_decimal",
        "ar-TN":       "arabic_numerals_dot_decimal",
        "ar-YE":       "arabic_numerals_dot_decimal",
        "bg-BG":       "comma_decimal_space_thousands",
        "cs-CZ":       "comma_decimal_dot_thousands",
        "da-DK":       "comma_decimal_dot_thousands",
        "de-DE":       "comma_decimal_dot_thousands",
        "el-GR":       "comma_decimal_dot_thousands",
        "en-AU":       "dot_decimal_comma_thousands",
        "en-GB":       "dot_decimal_comma_thousands",
        "en-HK":       "dot_decimal_comma_thousands",
        "en-IN":       "indian_numbering_system",
        "en-NZ":       "dot_decimal_comma_thousands",
        "en-US":       "dot_decimal_comma_thousands",
        "en-ZA":       "dot_decimal_comma_thousands",
        "en-ZM":       "dot_decimal_comma_thousands",
        "eo":          "dot_decimal_no_thousands",
        "es-ES":       "comma_decimal_dot_thousands",
        "fa":          "arabic_numerals_comma_decimal",
        "fa-AF":       "arabic_numerals_comma_decimal",
        "fa-IR":       "arabic_numerals_comma_decimal",
        "fr-FR":       "comma_decimal_space_thousands",
        "fr-CA":       "dot_decimal_comma_thousands",
        "hu-HU":       "comma_decimal_space_thousands",
        "id-ID":       "dot_decimal_no_thousands",
        "it-IT":       "comma_decimal_dot_thousands",
        "ku-IQ":       "arabic_numerals_dot_decimal",
        "nb-NO":       "comma_decimal_space_thousands",
        "nl-NL":       "comma_decimal_dot_thousands",
        "nn-NO":       "comma_decimal_space_thousands",
        "pl-PL":       "comma_decimal_space_thousands",
        "pl-Pl":       "comma_decimal_space_thousands",
        "pt-BR":       "comma_decimal_dot_thousands",
        "pt-PT":       "comma_decimal_dot_thousands",
        "ru-RU":       "comma_decimal_space_thousands",
        "sl-SI":       "comma_decimal_dot_thousands",
        "sr-RS":       "comma_decimal_dot_thousands",
        "sr-RS@latin": "comma_decimal_dot_thousands",
        "sv-SE":       "comma_decimal_space_thousands",
        "tr-TR":       "comma_decimal_dot_thousands",
        "uk-UA":       "comma_decimal_space_thousands",
        "vi-VN":       "dot_decimal_no_thousands",

        "zh-CN": "dot_decimal_comma_thousands",
        "zh-TW": "dot_decimal_comma_thousands",
        "ja-JP": "dot_decimal_no_thousands",
        "ko-KR": "dot_decimal_no_thousands",
        "th-TH": "dot_decimal_no_thousands",
}

const (
        defaultIsDecimalMinDigit = 1
        defaultIsDecimalMaxDigit = 10

        defaultIsDecimalFormat = "dot_decimal_comma_thousands"
)

// A validator that check if the string represents a decimal number, such as 0.1, .3, 1.1, 1.00003, 4.0, etc.
// IsDecimalOpts is a struct which defaults to {ForceDecimal: false, DecimalDigits: {Min: 1, Max: 10}, locale: 'en-US'}, if any are invalid or logically impossible (Min greater than Max).
// locale determines the decimal separator and is one of ('ar', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', 'ar-JO', 'ar-KW', 'ar-LB', 'ar-LY', 'ar-MA', 'ar-QA', 'ar-QM', 'ar-SA', 'ar-SD', 'ar-SY', 'ar-TN', 'ar-YE', 'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-AU', 'en-GB', 'en-HK', 'en-IN', 'en-NZ', 'en-US', 'en-ZA', 'en-ZM', 'eo', 'es-ES', 'fa', 'fa-AF', 'fa-IR', 'fr-FR', 'fr-CA', 'hu-HU', 'id-ID', 'it-IT', 'ku-IQ', 'nb-NO', 'nl-NL', 'nn-NO', 'pl-PL', 'pl-Pl', 'pt-BR', 'pt-PT', 'ru-RU', 'sl-SI', 'sr-RS', 'sr-RS@latin', 'sv-SE', 'tr-TR', 'uk-UA', 'vi-VN').
// ForceDecimal simply means a decimal must be present "123" will not pass but "123.45" will pass
func IsDecimal(str string, opts IsDecimalOpts) bool <span class="cov8" title="1">{
        if opts.DecimalDigits.Min &lt;= 0 </span><span class="cov8" title="1">{
                opts.DecimalDigits.Min = defaultIsDecimalMinDigit
        }</span>
        <span class="cov8" title="1">if opts.DecimalDigits.Max &lt;= 0 </span><span class="cov8" title="1">{
                opts.DecimalDigits.Max = defaultIsDecimalMaxDigit
        }</span>
        <span class="cov8" title="1">if opts.DecimalDigits.Min &gt; opts.DecimalDigits.Max </span><span class="cov0" title="0">{
                opts.DecimalDigits.Min, opts.DecimalDigits.Max = opts.DecimalDigits.Max, opts.DecimalDigits.Min
        }</span>

        <span class="cov8" title="1">format, ok := localeDecimalFormats[opts.Locale]

        if !ok </span><span class="cov8" title="1">{
                format = defaultIsDecimalFormat
        }</span>

        <span class="cov8" title="1">validReFunc := decimalFormats[format]

        return validReFunc(opts).MatchString(str)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package validatorgo

import (
        "math"
        "strconv"
)

// A validator thats checks if the string is a number(integer not a floating point) that is divisible by another(integer not a floating point).
func IsDivisibleBy(str string, num int) bool <span class="cov8" title="1">{
        if num == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">strInt, err := strconv.Atoi(str)

        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return math.Abs(float64(strInt%num)) == float64(0)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package validatorgo

import (
        "strconv"
)

// IsEAN checks if the string is a valid EAN (European Article Number).
func IsEAN(str string) bool <span class="cov8" title="1">{
        length := len(str)
        if length != 8 &amp;&amp; length != 13 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check if all characters are digits
        <span class="cov8" title="1">for _, r := range str </span><span class="cov8" title="1">{
                if r &lt; '0' || r &gt; '9' </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        // Calculate checksum
        <span class="cov8" title="1">var sum int
        for i, r := range str[:length-1] </span><span class="cov8" title="1">{
                digit, _ := strconv.Atoi(string(r))
                if (length == 8 &amp;&amp; i%2 == 0) || (length == 13 &amp;&amp; i%2 != 0) </span><span class="cov8" title="1">{
                        sum += digit * 3
                }</span> else<span class="cov8" title="1"> {
                        sum += digit
                }</span>
        }

        // The checksum digit is the last digit of the EAN
        <span class="cov8" title="1">checksum := (10 - (sum % 10)) % 10
        lastDigit, _ := strconv.Atoi(string(str[length-1]))

        return checksum == lastDigit</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package validatorgo

import (
        "fmt"
        "net"
        "regexp"
        "strings"
)

// IsEmailOpts is used to configure IsEmail
type IsEmailOpts struct {
        AllowDisplayName         bool
        RequireDisplayName       bool
        AllowUTF8LocalPart       bool
        RequireTld               bool
        IgnoreMaxLength          bool
        AllowIpDomain            bool
        DomainSpecificValidation bool
        BlacklistedChars         string
        HostBlacklist            []string
        HostWhitelist            []string
}

// A validator that checks if the string is an email.
// IsEmailOpts is a struct which defaults to { AllowDisplayName: false, RequireDisplayName: false, AllowUTF8LocalPart: true, RequireTld: true, AllowIpDomain: false, allow_underscores: false, DomainSpecificValidation: false, BlacklistedChars: ”, HostBlacklist: [] }.
// If AllowDisplayName is set to true, the validator will also match Display Name &lt;email-address&gt;.
// If RequireDisplayName is set to true, the validator will reject strings without the format Display Name &lt;email-address&gt;.
// If AllowUTF8LocalPart is set to false, the validator will not allow any non-English UTF8 character in email address' local part.
// If RequireTld is set to false, email addresses without a TLD in their domain will also be matched.
// If IgnoreMaxLength is set to true, the validator will not check for the standard max length of an email.
// If AllowIpDomain is set to true, the validator will allow IP addresses in the host part.
// If DomainSpecificValidation is true, some additional validation will be enabled, e.g. disallowing certain syntactically valid email addresses that are rejected by Gmail.
// If BlacklistedChars receives a string, then the validator will reject emails that include any of the characters in the string, in the name part.
// If HostBlacklist is set to an array of strings and the part of the email after the @ symbol matches one of the strings defined in it, the validation fails.
// If HostWhitelist is set to an array of strings and the part of the email after the @ symbol matches none of the strings defined in it, the validation fails.
func IsEmail(str string, opts IsEmailOpts) bool <span class="cov8" title="1">{
        // Basic email regex, allowing for UTF-8 if specified
        var emailRegex *regexp.Regexp
        if opts.AllowUTF8LocalPart </span><span class="cov8" title="1">{
                emailRegex = regexp.MustCompile(`^[\p{L}0-9.!#$%&amp;'*+/=?^_` + "`" + `{|}~-]+@([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}|(\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])$`)
        }</span> else<span class="cov8" title="1"> {
                emailRegex = regexp.MustCompile(`^[a-zA-Z0-9.!#$%&amp;'*+/=?^_` + "`" + `{|}~-]+@([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}|(\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])$`)
        }</span>

        // Handle display name if required
        <span class="cov8" title="1">if opts.RequireDisplayName || opts.AllowDisplayName </span><span class="cov8" title="1">{
                displayNameRegex := regexp.MustCompile(`^.+\s&lt;(.+)&gt;$`)
                matches := displayNameRegex.FindStringSubmatch(str)
                if len(matches) == 2 </span><span class="cov8" title="1">{
                        str = matches[1]
                }</span> else<span class="cov8" title="1"> if opts.RequireDisplayName </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        // Basic email validation
        <span class="cov8" title="1">if !emailRegex.MatchString(str) </span><span class="cov8" title="1">{
                fmt.Println(emailRegex.String())
                fmt.Println("Basic email validation")
                return false
        }</span>

        // Extract the domain part
        <span class="cov8" title="1">parts := strings.Split(str, "@")
        domain := parts[1]

        // Handle IP domain if allowed
        if opts.AllowIpDomain &amp;&amp; strings.HasPrefix(domain, "[") &amp;&amp; strings.HasSuffix(domain, "]") </span><span class="cov8" title="1">{
                ip := domain[1 : len(domain)-1]
                if net.ParseIP(ip) != nil </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>
        }

        // Handle TLD requirement
        <span class="cov8" title="1">if opts.RequireTld &amp;&amp; !strings.Contains(domain, ".") </span><span class="cov0" title="0">{
                return false
        }</span>

        // Domain-specific validation
        <span class="cov8" title="1">if opts.DomainSpecificValidation &amp;&amp; domain == "gmail.com" </span><span class="cov8" title="1">{
                local := parts[0]
                if strings.Contains(local, "+") </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        // Blacklisted characters
        <span class="cov8" title="1">if opts.BlacklistedChars != "" </span><span class="cov8" title="1">{
                for _, char := range opts.BlacklistedChars </span><span class="cov8" title="1">{
                        if strings.ContainsRune(str, char) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }

        // Host blacklist/whitelist
        <span class="cov8" title="1">if len(opts.HostBlacklist) &gt; 0 </span><span class="cov8" title="1">{
                for _, blacklisted := range opts.HostBlacklist </span><span class="cov8" title="1">{
                        if strings.HasSuffix(domain, blacklisted) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(opts.HostWhitelist) &gt; 0 </span><span class="cov8" title="1">{
                allowed := false
                for _, whitelisted := range opts.HostWhitelist </span><span class="cov8" title="1">{
                        if strings.HasSuffix(domain, whitelisted) </span><span class="cov0" title="0">{
                                allowed = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !allowed </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package validatorgo

import "regexp"

// IsEmptyOpts is used to configure IsEmpty
type IsEmptyOpts struct {
        IgnoreWhitespace bool
}

// A validator check if the string has a length of zero.
// IsEmptyOpts is a struct which defaults to { IgnoreWhitespace: false }.
func IsEmpty(str string, opts IsEmptyOpts) bool <span class="cov8" title="1">{
        if opts.IgnoreWhitespace </span><span class="cov8" title="1">{
                return regexp.MustCompile(`^(\s+)?$`).MatchString(str)
        }</span> else<span class="cov8" title="1"> {
                return regexp.MustCompile(`^$`).MatchString(str)
        }</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package validatorgo

import "regexp"

// A validator checks if the string is an Ethereum address. Does not validate address checksums.
func IsEthereumAddress(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile(`^0x[a-fA-F0-9]{40}$`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package validatorgo

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"
)

type IsFloatOpts struct {
        Min    float64
        Max    float64
        Gt     float64
        Lt     float64
        Locale string
}

// Define the map with the format as the key and a function as the value
var formatFloat = map[string]func(string) string{
        "dot_decimal_comma_thousands": func(s string) string <span class="cov8" title="1">{
                // Remove the thousands separator and replace the comma with a dot
                s = strings.Replace(s, ",", "", -1)
                return strings.Replace(s, ".", ".", 1)
        }</span>,
        "comma_decimal_dot_thousands": func(s string) string <span class="cov8" title="1">{
                // Remove the thousands separator and replace the comma with a dot
                s = strings.Replace(s, ".", "", -1)
                return strings.Replace(s, ",", ".", 1)
        }</span>,
        "arabic_numerals_dot_decimal": func(s string) string <span class="cov0" title="0">{
                // This is an example for converting Arabic numerals (assuming input is already in Arabic format)
                return s // Assuming Arabic numerals are correctly formatted
        }</span>,
        "comma_decimal_space_thousands": func(s string) string <span class="cov0" title="0">{
                // Remove the thousands separator (space) and replace the comma with a dot
                s = strings.Replace(s, " ", "", -1)
                return strings.Replace(s, ",", ".", 1)
        }</span>,
        "dot_decimal_no_thousands": func(s string) string <span class="cov0" title="0">{
                // No thousands separator, just replace the comma with a dot
                return strings.Replace(s, ",", ".", 1)
        }</span>,
        "arabic_numerals_comma_decimal": func(s string) string <span class="cov0" title="0">{
                // Assuming input is already in Arabic numerals with comma
                return strings.Replace(s, ",", ".", 1)
        }</span>,
        "indian_numbering_system": func(s string) string <span class="cov0" title="0">{
                // Remove the Indian grouping comma and replace it with the standard format
                s = strings.Replace(s, ",", "", -1)
                return strings.Replace(s, ".", ".", 1)
        }</span>,
}

// floatFormats is the set of decimal formats and their validating regular expressions
var floatFormats = map[string]*regexp.Regexp{
        "dot_decimal_comma_thousands":        regexp.MustCompile(`^[+-]?(\d{1,3}(,\d{3})*\.\d+|\d+\.\d+)$`),          // Matches 1,234.56 and 1234567.56
        "comma_decimal_dot_thousands":        regexp.MustCompile(`^[+-]?(\d{1,3}(\.\d{3})*,\d+|\d+,\d+)$`),           // Matches 1.234,56 and 1234567,56
        "comma_decimal_space_thousands":      regexp.MustCompile(`^[+-]?(\d{1,3}( \d{3})*,\d+|\d+,\d+)$`),            // Matches 1 234,56 and 1234567,56
        "dot_decimal_space_thousands":        regexp.MustCompile(`^[+-]?(\d{1,3}( \d{3})*\.\d+|\d+\.\d+)$`),          // Matches 1 234.56 and 1234567.56
        "dot_decimal_apostrophe_thousands":   regexp.MustCompile(`^[+-]?(\d{1,3}('\d{3})*\.\d+|\d+\.\d+)$`),          // Matches 1'234.56 and 1234567.56
        "comma_decimal_apostrophe_thousands": regexp.MustCompile(`^[+-]?(\d{1,3}('\d{3})*,\d+|\d+,\d+)$`),            // Matches 1'234,56 and 1234567,56
        "dot_decimal_no_thousands":           regexp.MustCompile(`^[+-]?\d*\.\d+$`),                                  // Matches 1234567.78
        "comma_decimal_no_thousands":         regexp.MustCompile(`^[+-]?\d*,\d+$`),                                   // Matches 1234567,78
        "indian_numbering_system":            regexp.MustCompile(`^[+-]?(\d{1,2}(,\d{2})*(,\d{3})*\.\d+|\d+\.\d+)$`), // Matches 1,23,456.78 and 1234567.78
        "arabic_numerals_dot_decimal":        regexp.MustCompile(`^[+-]?[٠١٢٣٤٥٦٧٨٩]*(\.\d+|\d+\.\d+)$`),             // Matches ١٢٣٤٥٦٧٫٥٦
        "arabic_numerals_comma_decimal":      regexp.MustCompile(`^[+-]?[٠١٢٣٤٥٦٧٨٩]*(\,\d+|\d+\,\d+)$`),             // Matches ١٢٣٤٥٦٧،٥٦
}

// floatDecimalFormats is the set of Locales and their decimal formats
var floatDecimalFormats = map[string]string{
        "ar":          "arabic_numerals_dot_decimal",
        "ar-AE":       "arabic_numerals_dot_decimal",
        "ar-BH":       "arabic_numerals_dot_decimal",
        "ar-DZ":       "arabic_numerals_dot_decimal",
        "ar-EG":       "arabic_numerals_dot_decimal",
        "ar-IQ":       "arabic_numerals_dot_decimal",
        "ar-JO":       "arabic_numerals_dot_decimal",
        "ar-KW":       "arabic_numerals_dot_decimal",
        "ar-LB":       "arabic_numerals_dot_decimal",
        "ar-LY":       "arabic_numerals_dot_decimal",
        "ar-MA":       "arabic_numerals_dot_decimal",
        "ar-QA":       "arabic_numerals_dot_decimal",
        "ar-QM":       "arabic_numerals_dot_decimal",
        "ar-SA":       "arabic_numerals_dot_decimal",
        "ar-SD":       "arabic_numerals_dot_decimal",
        "ar-SY":       "arabic_numerals_dot_decimal",
        "ar-TN":       "arabic_numerals_dot_decimal",
        "ar-YE":       "arabic_numerals_dot_decimal",
        "bg-BG":       "comma_decimal_space_thousands",
        "cs-CZ":       "comma_decimal_dot_thousands",
        "da-DK":       "comma_decimal_dot_thousands",
        "de-DE":       "comma_decimal_dot_thousands",
        "el-GR":       "comma_decimal_dot_thousands",
        "en-AU":       "dot_decimal_comma_thousands",
        "en-GB":       "dot_decimal_comma_thousands",
        "en-HK":       "dot_decimal_comma_thousands",
        "en-IN":       "indian_numbering_system",
        "en-NZ":       "dot_decimal_comma_thousands",
        "en-US":       "dot_decimal_comma_thousands",
        "en-ZA":       "dot_decimal_comma_thousands",
        "en-ZM":       "dot_decimal_comma_thousands",
        "eo":          "dot_decimal_no_thousands",
        "es-ES":       "comma_decimal_dot_thousands",
        "fa":          "arabic_numerals_comma_decimal",
        "fa-AF":       "arabic_numerals_comma_decimal",
        "fa-IR":       "arabic_numerals_comma_decimal",
        "fr-FR":       "comma_decimal_space_thousands",
        "fr-CA":       "dot_decimal_comma_thousands",
        "hu-HU":       "comma_decimal_space_thousands",
        "id-ID":       "dot_decimal_no_thousands",
        "it-IT":       "comma_decimal_dot_thousands",
        "ku-IQ":       "arabic_numerals_dot_decimal",
        "nb-NO":       "comma_decimal_space_thousands",
        "nl-NL":       "comma_decimal_dot_thousands",
        "nn-NO":       "comma_decimal_space_thousands",
        "pl-PL":       "comma_decimal_space_thousands",
        "pl-Pl":       "comma_decimal_space_thousands",
        "pt-BR":       "comma_decimal_dot_thousands",
        "pt-PT":       "comma_decimal_dot_thousands",
        "ru-RU":       "comma_decimal_space_thousands",
        "sl-SI":       "comma_decimal_dot_thousands",
        "sr-RS":       "comma_decimal_dot_thousands",
        "sr-RS@latin": "comma_decimal_dot_thousands",
        "sv-SE":       "comma_decimal_space_thousands",
        "tr-TR":       "comma_decimal_dot_thousands",
        "uk-UA":       "comma_decimal_space_thousands",
        "vi-VN":       "dot_decimal_no_thousands",

        "zh-CN": "dot_decimal_comma_thousands",
        "zh-TW": "dot_decimal_comma_thousands",
        "ja-JP": "dot_decimal_no_thousands",
        "ko-KR": "dot_decimal_no_thousands",
        "th-TH": "dot_decimal_no_thousands",
}

const defaultIsFloatFormat = "dot_decimal_comma_thousands"

// A validator that checks if the string is a float.
// IsFloatOpts is a struct which can contain the fields Min, Max, Gt, and/or Lt to validate the float is within boundaries (e.g. { Min: 7.22, Max: 9.55 }) it also has locale as an option.
// Min and Max are equivalent to 'greater or equal' and 'less or equal', respectively while Gt and Lt are their strict counterparts. It's either Min/Max or Gt/Lt.
// locale determines the decimal separator and is one of ('ar', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', 'ar-JO', 'ar-KW', 'ar-LB', 'ar-LY', 'ar-MA', 'ar-QA', 'ar-QM', 'ar-SA', 'ar-SD', 'ar-SY', 'ar-TN', 'ar-YE', 'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'en-AU', 'en-GB', 'en-HK', 'en-IN', 'en-NZ', 'en-US', 'en-ZA', 'en-ZM', 'eo', 'es-ES', 'fr-CA', 'fr-FR', 'hu-HU', 'it-IT', 'nb-NO', 'nl-NL', 'nn-NO', 'pl-PL', 'pt-BR', 'pt-PT', 'ru-RU', 'sl-SI', 'sr-RS', 'sr-RS@latin', 'sv-SE', 'tr-TR', 'uk-UA').
func IsFloat(str string, opts IsFloatOpts) bool <span class="cov8" title="1">{
        if opts.Min &gt; opts.Max </span><span class="cov0" title="0">{
                opts.Min, opts.Max = opts.Max, opts.Min
        }</span>

        <span class="cov8" title="1">if opts.Lt &gt; opts.Gt </span><span class="cov8" title="1">{
                opts.Lt, opts.Gt = opts.Gt, opts.Lt
        }</span>

        <span class="cov8" title="1">format, ok := floatDecimalFormats[opts.Locale]

        if !ok </span><span class="cov8" title="1">{
                format = defaultIsFloatFormat
        }</span>

        <span class="cov8" title="1">parsableFltFunc := formatFloat[format]
        parsableFlt := parsableFltFunc(str)

        flt, err := strconv.ParseFloat(parsableFlt, 64)

        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">re := floatFormats[format]

        fmt.Println(str, parsableFlt, format)

        if opts.Max != 0 </span><span class="cov8" title="1">{
                fmt.Println("USES MINMAX")
                return re.MatchString(str) &amp;&amp; flt &gt;= opts.Min &amp;&amp; flt &lt;= opts.Max
        }</span>

        <span class="cov8" title="1">if opts.Gt != 0 </span><span class="cov8" title="1">{
                fmt.Println("USES GTLT")
                return re.MatchString(str) &amp;&amp; flt &gt; opts.Lt &amp;&amp; flt &lt; opts.Gt
        }</span>

        <span class="cov8" title="1">return re.MatchString(str)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package validatorgo

import (
        "fmt"
        "regexp"
        "unicode/utf8"
)

const defaultMaxFQDNLength = 253

// IsFQDNoptsOpts is used to configure IsFQDNopts
type IsFQDNopts struct {
        RequireTld       bool
        AllowUnderscores bool
        AllowTrailingDot bool
        AllowNumericTld  bool
        IgnoreMaxLength  bool
}

// A validator that checks if the string is a fully qualified domain name (e.g. domain.com).
// If allow_wildcard is set to true, the validator will allow domain starting with *. (e.g. *.example.com or *.shop.example.com).
func IsFQDN(str string, opts IsFQDNopts) bool <span class="cov8" title="1">{
        ignMaxLength := true
        len := utf8.RuneCountInString(str)

        if !opts.IgnoreMaxLength &amp;&amp; len &gt; defaultMaxFQDNLength </span><span class="cov8" title="1">{
                ignMaxLength = false
        }</span>

        <span class="cov8" title="1">allowUnderScoreRe := `a-zA-Z0-9`
        if opts.AllowUnderscores </span><span class="cov8" title="1">{
                allowUnderScoreRe = `\w`
        }</span>
        <span class="cov8" title="1">requireTldRe := "?"
        if opts.RequireTld </span><span class="cov0" title="0">{
                requireTldRe = ""
        }</span>
        <span class="cov8" title="1">allowTrailingDotRe := ``
        if opts.AllowTrailingDot </span><span class="cov8" title="1">{
                allowTrailingDotRe = `\.?`
        }</span>
        <span class="cov8" title="1">allowNumTldRe := `[a-zA-Z_]`
        if opts.AllowNumericTld </span><span class="cov8" title="1">{
                allowNumTldRe = `\w`
        }</span>

        <span class="cov8" title="1">reStr := fmt.Sprintf(`^([%s])+(\.[%s]+)?\.%s%s+%s$`, allowUnderScoreRe, allowUnderScoreRe, requireTldRe, allowNumTldRe, allowTrailingDotRe)
        // fmt.Println(reStr)
        re := regexp.MustCompile(reStr)
        isValid := re.MatchString(str)
        fmt.Printf("length is, %d while defleng is %d and isvalid is %t\n", len, defaultMaxFQDNLength, isValid)
        return isValid &amp;&amp; ignMaxLength</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package validatorgo

import (
        "fmt"
        "math"
        "regexp"
        "strconv"
        "unicode/utf8"
)

var alphaFreightNumVal = map[string]int{
        "A": 10,
        "B": 12,
        "C": 13,
        "D": 14,
        "E": 15,
        "F": 16,
        "G": 17,
        "H": 18,
        "I": 19,
        "J": 20,
        "K": 21,
        "L": 23,
        "M": 24,
        "N": 25,
        "O": 26,
        "P": 27,
        "Q": 28,
        "R": 29,
        "S": 30,
        "T": 31,
        "U": 32,
        "V": 34,
        "W": 35,
        "X": 36,
        "Y": 37,
        "Z": 38,
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9,
}

// A validator that checks alias for IsISO6346, check if the string is a valid ISO 6346 shipping container identification.
func IsFreightContainerID(str string) bool <span class="cov0" title="0">{
        len := utf8.RuneCountInString(str)
        if len != 11 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">re := regexp.MustCompile(`^([A-Z]{3})([UJZ])([0-9]{6})([0-9])$`)
        match := re.MatchString(str)

        if !match </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">sum := 0
        for ind, char := range str </span><span class="cov0" title="0">{
                if ind &gt; 9 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">wgh := int(math.Pow(2.0, float64(9-ind)))
                num, ok := alphaFreightNumVal[string(char)]

                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">fmt.Println(wgh * num)
                sum += wgh * num</span>
        }

        <span class="cov0" title="0">grps := re.FindStringSubmatch(str)
        checkDig := grps[4]
        rem := sum % 11
        fmt.Println("GROUPS", grps)
        fmt.Println("CHECKDIG", checkDig)
        fmt.Println("SUM", sum)
        fmt.Println("REM", rem)

        if rem == 10 &amp;&amp; checkDig == "0" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">checkDigInt, err := strconv.Atoi(checkDig)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return checkDigInt == rem</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string contains any full-width chars.
func IsFullWidth(str string) bool <span class="cov8" title="1">{
        fullWidthRegex := regexp.MustCompile(`[^\x{0020}-\x{007E}\x{FF61}-\x{FF9F}\x{FFA0}-\x{FFDC}\x{FFE8}-\x{FFEE}]`)
        return fullWidthRegex.MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string contains any half-width chars.
func IsHalfWidth(str string) bool <span class="cov8" title="1">{
        halfWidthRegex := regexp.MustCompile(`[\x{FF61}-\x{FFDC}\x{FFE8}-\x{FFEE}]`)
        return halfWidthRegex.MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package validatorgo

import "regexp"

// hashAlgoRegex is the set of regex's for hashing algo
var hashAlgoRegex = map[string]*regexp.Regexp{
        "crc32":     regexp.MustCompile(`^[a-fA-F0-9]{8}$`),   // 8 hex characters
        "crc32b":    regexp.MustCompile(`^[a-fA-F0-9]{8}$`),   // 8 hex characters
        "md4":       regexp.MustCompile(`^[a-fA-F0-9]{32}$`),  // 32 hex characters
        "md5":       regexp.MustCompile(`^[a-fA-F0-9]{32}$`),  // 32 hex characters
        "ripemd128": regexp.MustCompile(`^[a-fA-F0-9]{32}$`),  // 32 hex characters
        "ripemd160": regexp.MustCompile(`^[a-fA-F0-9]{40}$`),  // 40 hex characters
        "sha1":      regexp.MustCompile(`^[a-fA-F0-9]{40}$`),  // 40 hex characters
        "sha256":    regexp.MustCompile(`^[a-fA-F0-9]{64}$`),  // 64 hex characters
        "sha384":    regexp.MustCompile(`^[a-fA-F0-9]{96}$`),  // 96 hex characters
        "sha512":    regexp.MustCompile(`^[a-fA-F0-9]{128}$`), // 128 hex characters
        "tiger128":  regexp.MustCompile(`^[a-fA-F0-9]{32}$`),  // 32 hex characters
        "tiger160":  regexp.MustCompile(`^[a-fA-F0-9]{40}$`),  // 40 hex characters
        "tiger192":  regexp.MustCompile(`^[a-fA-F0-9]{48}$`),  // 48 hex characters
}

// A validator that checks if the string is a hash of type algorithm.
// Algorithm is one of ('crc32', 'crc32b', 'md4', 'md5', 'ripemd128', 'ripemd160', 'sha1', 'sha256', 'sha384', 'sha512', 'tiger128', 'tiger160', 'tiger192'), no checksum.
func IsHash(str, algorithm string) bool <span class="cov8" title="1">{
        re, exist := hashAlgoRegex[algorithm]

        if !exist </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return re.MatchString(str)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string is a hexadecimal number.
func IsHexadecimal(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile(`^[a-fA-F0-9]+$`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string is a hexadecimal color.
func IsHexColor(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile(`^#(?:[0-9a-fA-F]{3}){1,2}$`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package validatorgo

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"
)

// A validator that checks if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.
func IsHSL(str string) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(`(?im)^hsla?\(\s*(?&lt;h&gt;[-+]?\d{1,3}(?:\.\d+)?)(deg|grad|rad|turn)?\s*,\s*(?&lt;s&gt;[-+]?\d{1,3}(?:\.\d+)?)%\s*,\s*(?&lt;l&gt;[-+]?\d{1,3}(?:\.\d+)?)%\s*(?:,\s*(?&lt;alpha&gt;[-+]?[\d.]+%?)\s*)?\)$
`)

        match := re.MatchString(str)

        if !match </span><span class="cov8" title="1">{
                return match
        }</span>

        <span class="cov0" title="0">grps := re.FindStringSubmatch(str)
        fmt.Printf("GRPS %+v\n", grps)
        fmt.Println("0", grps[0])
        fmt.Println("1", grps[1])
        fmt.Println("2", grps[2])
        fmt.Println("3", grps[3])
        fmt.Println("4", grps[4])
        fmt.Println("5", grps[5])
        hue, sat, light, alpha := grps[1], grps[3], grps[4], grps[5]

        // fmt.Println("hue", hue)
        // fmt.Println("sat", sat)
        // fmt.Println("light", light)

        const bitSize = 64
        hueNum, err := strconv.ParseFloat(hue, bitSize)

        if err != nil || hueNum &lt; 0 || hueNum &gt; 360 </span><span class="cov0" title="0">{
                return false
        }</span>

        // satWthOutPer := strings.Replace(sat, "%", "", 1)
        <span class="cov0" title="0">satNum, err := strconv.ParseFloat(sat, bitSize)
        fmt.Println(sat, satNum, err)

        if err != nil || satNum &lt; 0 || satNum &gt; 100 </span><span class="cov0" title="0">{
                return false
        }</span>

        // lightWthOutPer := strings.Replace(light, "%", "", 1)
        <span class="cov0" title="0">lightNum, err := strconv.ParseFloat(light, bitSize)

        if err != nil || lightNum &lt; 0 || lightNum &gt; 100 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">var (
                alphaNum float64
                alphaErr error
        )
        if strings.HasSuffix(alpha, "%") </span><span class="cov0" title="0">{
                alphaWthOutPer := strings.Replace(alpha, "%", "", 1)
                alphaNum, alphaErr = strconv.ParseFloat(alphaWthOutPer, bitSize)
                alphaNum = alphaNum / 100
        }</span> else<span class="cov0" title="0"> {
                alphaNum, alphaErr = strconv.ParseFloat(alpha, bitSize)
        }</span>

        <span class="cov0" title="0">if alpha != "" &amp;&amp; (alphaErr != nil || alphaNum &lt; 0 || alphaNum &gt; 1) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package validatorgo

import "regexp"

// iban regex's for country codes
var ibanRegex = map[string]*regexp.Regexp{
        "AD": regexp.MustCompile(`^AD\d{2}\d{4}\d{4}\d{12}$`),               // Andorra
        "AE": regexp.MustCompile(`^AE\d{2}\d{3}\d{16}$`),                    // United Arab Emirates
        "AL": regexp.MustCompile(`^AL\d{2}\d{8}\d{16}$`),                    // Albania
        "AT": regexp.MustCompile(`^AT\d{2}\d{5}\d{11}$`),                    // Austria
        "AZ": regexp.MustCompile(`^AZ\d{2}[A-Z]{4}\d{20}$`),                 // Azerbaijan
        "BA": regexp.MustCompile(`^BA\d{2}\d{3}\d{3}\d{8}\d{2}$`),           // Bosnia and Herzegovina
        "BE": regexp.MustCompile(`^BE\d{2}\d{3}\d{7}\d{2}$`),                // Belgium
        "BG": regexp.MustCompile(`^BG\d{2}[A-Z]{4}\d{4}\d{10}$`),            // Bulgaria
        "BH": regexp.MustCompile(`^BH\d{2}[A-Z]{4}\d{14}$`),                 // Bahrain
        "BR": regexp.MustCompile(`^BR\d{2}\d{8}\d{5}\d{10}[A-Z]{1}\d{1}$`),  // Brazil
        "BY": regexp.MustCompile(`^BY\d{2}[A-Z]{4}\d{4}\d{16}$`),            // Belarus
        "CH": regexp.MustCompile(`^CH\d{2}\d{5}\d{12}$`),                    // Switzerland
        "CR": regexp.MustCompile(`^CR\d{2}\d{4}\d{14}$`),                    // Costa Rica
        "CY": regexp.MustCompile(`^CY\d{2}\d{3}\d{5}\d{16}$`),               // Cyprus
        "CZ": regexp.MustCompile(`^CZ\d{2}\d{4}\d{6}\d{10}$`),               // Czech Republic
        "DE": regexp.MustCompile(`^DE\d{2}\d{8}\d{10}$`),                    // Germany
        "DK": regexp.MustCompile(`^DK\d{2}\d{4}\d{10}$`),                    // Denmark
        "DO": regexp.MustCompile(`^DO\d{2}[A-Z]{4}\d{20}$`),                 // Dominican Republic
        "EE": regexp.MustCompile(`^EE\d{2}\d{2}\d{2}\d{11}$`),               // Estonia
        "ES": regexp.MustCompile(`^ES\d{2}\d{4}\d{4}\d{2}\d{10}$`),          // Spain
        "FI": regexp.MustCompile(`^FI\d{2}\d{6}\d{7}\d{1}$`),                // Finland
        "FO": regexp.MustCompile(`^FO\d{2}\d{4}\d{9}\d{1}$`),                // Faroe Islands
        "FR": regexp.MustCompile(`^FR\d{2}\d{5}\d{5}[A-Z0-9]{11}\d{2}$`),    // France
        "GB": regexp.MustCompile(`^GB\d{2}[A-Z]{4}\d{6}\d{8}$`),             // United Kingdom
        "GE": regexp.MustCompile(`^GE\d{2}[A-Z]{2}\d{16}$`),                 // Georgia
        "GI": regexp.MustCompile(`^GI\d{2}[A-Z]{4}\d{15}$`),                 // Gibraltar
        "GL": regexp.MustCompile(`^GL\d{2}\d{4}\d{10}$`),                    // Greenland
        "GR": regexp.MustCompile(`^GR\d{2}\d{3}\d{4}[A-Z0-9]{16}$`),         // Greece
        "GT": regexp.MustCompile(`^GT\d{2}[A-Z0-9]{4}\d{20}$`),              // Guatemala
        "HR": regexp.MustCompile(`^HR\d{2}\d{7}\d{10}$`),                    // Croatia
        "HU": regexp.MustCompile(`^HU\d{2}\d{3}\d{4}\d{1}\d{15}\d{1}$`),     // Hungary
        "IE": regexp.MustCompile(`^IE\d{2}[A-Z]{4}\d{6}\d{8}$`),             // Ireland
        "IL": regexp.MustCompile(`^IL\d{2}\d{3}\d{3}\d{13}$`),               // Israel
        "IS": regexp.MustCompile(`^IS\d{2}\d{4}\d{2}\d{6}\d{10}$`),          // Iceland
        "IT": regexp.MustCompile(`^IT\d{2}[A-Z]{1}\d{5}\d{5}[A-Z0-9]{12}$`), // Italy
        "JO": regexp.MustCompile(`^JO\d{2}[A-Z]{4}\d{4}\d{18}$`),            // Jordan
        "KW": regexp.MustCompile(`^KW\d{2}[A-Z]{4}\d{22}$`),                 // Kuwait
        "KZ": regexp.MustCompile(`^KZ\d{2}\d{3}\d{13}$`),                    // Kazakhstan
        "LB": regexp.MustCompile(`^LB\d{2}\d{4}\d{20}$`),                    // Lebanon
        "LC": regexp.MustCompile(`^LC\d{2}[A-Z]{4}[A-Z0-9]{24}$`),           // Saint Lucia
        "LI": regexp.MustCompile(`^LI\d{2}\d{5}\d{12}$`),                    // Liechtenstein
        "LT": regexp.MustCompile(`^LT\d{2}\d{5}\d{11}$`),                    // Lithuania
        "LU": regexp.MustCompile(`^LU\d{2}\d{3}\d{13}$`),                    // Luxembourg
        "LV": regexp.MustCompile(`^LV\d{2}[A-Z]{4}\d{13}$`),                 // Latvia
        "MC": regexp.MustCompile(`^MC\d{2}\d{5}\d{5}[A-Z0-9]{11}\d{2}$`),    // Monaco
        "MD": regexp.MustCompile(`^MD\d{2}[A-Z0-9]{2}\d{18}$`),              // Moldova
        "ME": regexp.MustCompile(`^ME\d{2}\d{3}\d{13}\d{2}$`),               // Montenegro
        "MK": regexp.MustCompile(`^MK\d{2}\d{3}[A-Z0-9]{10}\d{2}$`),         // North Macedonia
        "MR": regexp.MustCompile(`^MR\d{2}\d{5}\d{5}\d{11}\d{2}$`),          // Mauritania
        "MT": regexp.MustCompile(`^MT\d{2}[A-Z]{4}\d{5}\d{18}$`),            // Malta
        "MU": regexp.MustCompile(`^MU\d{2}[A-Z]{4}\d{19}[A-Z]{3}$`),         // Mauritius
        "NL": regexp.MustCompile(`^NL\d{2}[A-Z]{4}\d{10}$`),                 // Netherlands
        "NO": regexp.MustCompile(`^NO\d{2}\d{4}\d{6}\d{1}$`),                // Norway
        "PK": regexp.MustCompile(`^PK\d{2}[A-Z]{4}\d{16}$`),                 // Pakistan
        "PL": regexp.MustCompile(`^PL\d{2}\d{8}\d{16}$`),                    // Poland
        "PS": regexp.MustCompile(`^PS\d{2}[A-Z]{4}\d{21}$`),                 // Palestine
        "PT": regexp.MustCompile(`^PT\d{2}\d{4}\d{4}\d{11}\d{2}$`),          // Portugal
        "QA": regexp.MustCompile(`^QA\d{2}[A-Z]{4}\d{21}$`),                 // Qatar
        "RO": regexp.MustCompile(`^RO\d{2}[A-Z]{4}\d{16}$`),                 // Romania
        "RS": regexp.MustCompile(`^RS\d{2}\d{3}\d{13}\d{2}$`),               // Serbia
        "SA": regexp.MustCompile(`^SA\d{2}\d{2}\d{18}$`),                    // Saudi Arabia
        "SC": regexp.MustCompile(`^SC\d{2}[A-Z]{4}\d{20}[A-Z]{3}$`),         // Seychelles
        "SE": regexp.MustCompile(`^SE\d{2}\d{3}\d{16}\d{1}$`),               // Sweden
        "SI": regexp.MustCompile(`^SI\d{2}\d{5}\d{8}\d{2}$`),                // Slovenia
        "SK": regexp.MustCompile(`^SK\d{2}\d{4}\d{6}\d{10}$`),               // Slovakia
        "SM": regexp.MustCompile(`^SM\d{2}[A-Z]{1}\d{5}\d{5}[A-Z0-9]{12}$`), // San Marino
        "ST": regexp.MustCompile(`^ST\d{2}\d{4}\d{4}\d{11}\d{2}$`),          // Sao Tome and Principe
        "SV": regexp.MustCompile(`^SV\d{2}[A-Z]{4}\d{20}$`),                 // El Salvador
        "TL": regexp.MustCompile(`^TL\d{2}\d{3}\d{14}$`),                    // East Timor
        "TN": regexp.MustCompile(`^TN\d{2}\d{2}\d{3}\d{13}\d{2}$`),          // Tunisia
        "TR": regexp.MustCompile(`^TR\d{2}\d{5}\d{1}\d{16}$`),               // Turkey
        "UA": regexp.MustCompile(`^UA\d{2}\d{6}\d{19}$`),                    // Ukraine
        "VG": regexp.MustCompile(`^VG\d{2}[A-Z]{4}\d{16}$`),                 // British Virgin Islands
        "XK": regexp.MustCompile(`^XK\d{2}\d{4}\d{10}\d{2}$`),               // Kosovo
        "IQ": regexp.MustCompile(`^IQ\d{2}[A-Z]{4}\d{15}$`),                 // Iraq
        "MZ": regexp.MustCompile(`^MZ\d{2}[A-Z0-9]{21}$`),                   // Mozambique
        "VA": regexp.MustCompile(`^VA\d{2}[A-Z0-9]{18}$`),                   // Vatican City
}

// A validator that checks if the string is an IBAN (International Bank Account Number).
// these are the allowed country codes ('AD','AE','AL','AT','AZ','BA','BE','BG','BH','BR','BY','CH','CR','CY','CZ','DE','DK','DO','EE','EG','ES','FI','FO','FR','GB','GE','GI','GL','GR','GT','HR','HU','IE','IL','IQ','IR','IS','IT','JO','KW','KZ','LB','LC','LI','LT','LU','LV','MC','MD','ME','MK','MR','MT','MU','MZ','NL','NO','PK','PL','PS','PT','QA','RO','RS','SA','SC','SE','SI','SK','SM','SV','TL','TN','TR','UA','VA','VG','XK').
// Abeg no checksum 😭😭😭😭
func IsIBAN(str string, countryCode string) bool <span class="cov8" title="1">{
        re, exist := ibanRegex[countryCode]

        if !exist </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return re.MatchString(str)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package validatorgo

import (
        "regexp"
)

var identityCardLocaleRegex = map[string]*regexp.Regexp{
        "LK":    regexp.MustCompile(`^\d{9}[VXvx]$`),              // Sri Lanka
        "PL":    regexp.MustCompile(`^[A-Z]{3}\d{6}$`),            // Poland
        "ES":    regexp.MustCompile(`^\d{8}[A-Z]$`),               // Spain
        "FI":    regexp.MustCompile(`^\d{6}[+\-A]\d{3}[A-Z0-9]$`), // Finland
        "IN":    regexp.MustCompile(`^\d{12}$`),                   // India
        "IT":    regexp.MustCompile(`^[A-Z0-9]{9}$`),              // Italy
        "IR":    regexp.MustCompile(`^\d{10}$`),                   // Iran
        "MZ":    regexp.MustCompile(`^\d{13}$`),                   // Mozambique
        "NO":    regexp.MustCompile(`^\d{11}$`),                   // Norway
        "TH":    regexp.MustCompile(`^\d{13}$`),                   // Thailand
        "zh-TW": regexp.MustCompile(`^[A-Z][12]\d{8}$`),           // Taiwan
        "he-IL": regexp.MustCompile(`^\d{9}$`),                    // Israel
        "ar-LY": regexp.MustCompile(`^\d{12}$`),                   // Libya
        "ar-TN": regexp.MustCompile(`^\d{8}$`),                    // Tunisia
        "zh-CN": regexp.MustCompile(`^\d{17}[\dX]$`),              // China
        "zh-HK": regexp.MustCompile(`^[A-Z]\d{6}[\dA]$`),          // Hong Kong
        "PK":    regexp.MustCompile(`^\d{13}$`),                   // Pakistan
}

// A validator that checks if the string is a valid identity card code.
// locale is one of ['LK', 'PL', 'ES', 'FI', 'IN', 'IT', 'IR', 'MZ', 'NO', 'TH', 'zh-TW', 'he-IL', 'ar-LY', 'ar-TN', 'zh-CN', 'zh-HK', 'PK'] OR 'any'. If 'any' is used, function will check if any of the locales match.
// Defaults to 'any' if locale not found. No checksums.
func IsIdentityCard(str, locale string) bool <span class="cov8" title="1">{
        re, ok := identityCardLocaleRegex[locale]

        if ok </span><span class="cov8" title="1">{
                return re.MatchString(str)
        }</span> else<span class="cov8" title="1"> {
                for _, reg := range identityCardLocaleRegex </span><span class="cov8" title="1">{
                        matches := reg.MatchString(str)
                        if matches </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        }
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package validatorgo

// A validator that checks if the string is in a slice of allowed values.
func IsIn(str string, values []string) bool <span class="cov8" title="1">{
        for _, val := range values </span><span class="cov8" title="1">{
                if str == val </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package validatorgo

import (
        "fmt"
        "regexp"
        "strconv"
)

type IsIntOpts struct {
        Min *int
        Max *int

        Gt *int
        Lt *int

        AllowLeadingZeroes bool
}

// A validator that checks if the string is an integer.
// IsIntOpts is a struct which can contain the keys Min and/or Max to check the integer is within boundaries (e.g. { Min: 10, Max: 99 }). IsIntOpts can also contain the key AllowLeadingZeroes, which when set to false will disallow integer values with leading zeroes (e.g. { AllowLeadingZeroes: false }). Finally, IsIntOpts can contain the keys Gt and/or Lt which will enforce integers being greater than or less than, respectively, the value provided (e.g. {Gt: 1, Lt: 4} for a number between 1 and 4).
func IsInt(str string, opts IsIntOpts) bool <span class="cov8" title="1">{
        var matches bool

        if opts.AllowLeadingZeroes </span><span class="cov8" title="1">{
                matches = regexp.MustCompile(`^([+-]?0*\d+)(\.0+)?$`).MatchString(str)
        }</span> else<span class="cov8" title="1"> {
                matches = regexp.MustCompile(`^([+-]?)((0|[1-9]\d*)(\.0*)?|0)$`).MatchString(str)
        }</span>

        <span class="cov8" title="1">if !matches </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">strInt, err := strconv.Atoi(str)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("failed parsing")
                return false
        }</span>

        <span class="cov8" title="1">fmt.Println("Passes regex and conversion")

        withinLimits := true

        if opts.Min != nil </span><span class="cov8" title="1">{
                fmt.Println("within min")
                isMin := *(opts.Min) &lt;= strInt
                withinLimits = withinLimits &amp;&amp; isMin
        }</span>

        <span class="cov8" title="1">if opts.Max != nil </span><span class="cov8" title="1">{
                fmt.Println("within max")
                isMax := *(opts.Max) &gt;= strInt
                withinLimits = withinLimits &amp;&amp; isMax
        }</span>

        <span class="cov8" title="1">fmt.Println(strInt, withinLimits)

        if opts.Lt != nil </span><span class="cov8" title="1">{
                isMin := strInt &lt; *(opts.Lt)
                withinLimits = withinLimits &amp;&amp; isMin
                fmt.Println("within lt", withinLimits)
        }</span>

        <span class="cov8" title="1">if opts.Gt != nil </span><span class="cov8" title="1">{
                isMax := strInt &gt; *(opts.Gt)
                withinLimits = withinLimits &amp;&amp; isMax
                fmt.Println("within gt", withinLimits)
        }</span>

        <span class="cov8" title="1">return withinLimits</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package validatorgo

import (
        "regexp"
)

// ipVersionRegex is the set of versions and their validating regex
var ipVersionRegex = map[string]*regexp.Regexp{
        "4": regexp.MustCompile(`^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$`),
        "6": regexp.MustCompile(`^([[:xdigit:]]{1,4}(?::[[:xdigit:]]{1,4}){7}|::|:(?::[[:xdigit:]]{1,4}){1,6}|[[:xdigit:]]{1,4}:(?::[[:xdigit:]]{1,4}){1,5}|(?:[[:xdigit:]]{1,4}:){2}(?::[[:xdigit:]]{1,4}){1,4}|(?:[[:xdigit:]]{1,4}:){3}(?::[[:xdigit:]]{1,4}){1,3}|(?:[[:xdigit:]]{1,4}:){4}(?::[[:xdigit:]]{1,4}){1,2}|(?:[[:xdigit:]]{1,4}:){5}:[[:xdigit:]]{1,4}|(?:[[:xdigit:]]{1,4}:){1,6}:)$`),
}

func IsIP(str, version string) bool <span class="cov8" title="1">{
        if version != "4" &amp;&amp; version != "6" </span><span class="cov8" title="1">{
                for _, re := range ipVersionRegex </span><span class="cov8" title="1">{
                        matches := re.MatchString(str)
                        if matches </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        } else<span class="cov8" title="1"> {
                re := ipVersionRegex[version]
                return re.MatchString(str)
        }</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package validatorgo

import (
        "net"
        "strings"
)

func IsIPRange(str, version string) bool <span class="cov8" title="1">{
        switch version </span>{
        case "4":<span class="cov8" title="1">
                return isValidIPv4Range(str)</span>
        case "6":<span class="cov8" title="1">
                return isValidIPv6Range(str)</span>
        default:<span class="cov0" title="0">
                return isValidIPv4Range(str) || isValidIPv6Range(str)</span>
        }
}

func isValidIPv4Range(str string) bool <span class="cov8" title="1">{
        if strings.Contains(str, "/") </span><span class="cov8" title="1">{
                return isValidCIDR(str, 32)
        }</span> else<span class="cov8" title="1"> if strings.Contains(str, "-") </span><span class="cov8" title="1">{
                return isValidDashSeparatedRange(str, "4")
        }</span>
        <span class="cov0" title="0">return false</span>
}

func isValidIPv6Range(str string) bool <span class="cov8" title="1">{
        if strings.Contains(str, "/") </span><span class="cov8" title="1">{
                return isValidCIDR(str, 128)
        }</span> else<span class="cov8" title="1"> if strings.Contains(str, "-") </span><span class="cov8" title="1">{
                return isValidDashSeparatedRange(str, "6")
        }</span>
        <span class="cov8" title="1">return false</span>
}

func isValidCIDR(str string, maxPrefixLength int) bool <span class="cov8" title="1">{
        _, ipNet, err := net.ParseCIDR(str)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">ones, bits := ipNet.Mask.Size()
        return bits == maxPrefixLength &amp;&amp; ones &gt;= 0 &amp;&amp; ones &lt;= maxPrefixLength</span>
}

func isValidDashSeparatedRange(str string, version string) bool <span class="cov8" title="1">{
        parts := strings.Split(str, "-")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">startIP := strings.TrimSpace(parts[0])
        endIP := strings.TrimSpace(parts[1])

        // Parse the start and end IPs
        start := net.ParseIP(startIP)
        end := net.ParseIP(endIP)

        // Ensure both IPs are valid and of the same version
        if start == nil || end == nil || !isSameIPVersion(start, end, version) </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check that start IP is less than or equal to end IP
        <span class="cov8" title="1">return isIPLessThanOrEqual(start, end)</span>
}

func isSameIPVersion(ip1, ip2 net.IP, version string) bool <span class="cov8" title="1">{
        if version == "4" </span><span class="cov8" title="1">{
                return ip1.To4() != nil &amp;&amp; ip2.To4() != nil
        }</span> else<span class="cov8" title="1"> if version == "6" </span><span class="cov8" title="1">{
                return ip1.To16() != nil &amp;&amp; ip2.To16() != nil &amp;&amp; ip1.To4() == nil &amp;&amp; ip2.To4() == nil
        }</span>
        <span class="cov0" title="0">return false</span>
}

func isIPLessThanOrEqual(start, end net.IP) bool <span class="cov8" title="1">{
        for i := range start </span><span class="cov8" title="1">{
                if start[i] &lt; end[i] </span><span class="cov8" title="1">{
                        return true
                }</span> else<span class="cov8" title="1"> if start[i] &gt; end[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package validatorgo

import (
        // "fmt"
        "strconv"
        "strings"
)

// A validator that checks if the string is an ISBN.
// version: ISBN version to compare to. Accepted values are '10' and '13'. If none provided, both will be tested.
func IsISBN(str, version string) bool <span class="cov8" title="1">{
        strNum := stripDashesAndSpaces(str)

        if version == "10" </span><span class="cov8" title="1">{
                return valIsISBNv10(strNum)
        }</span> else<span class="cov8" title="1"> if version == "13" </span><span class="cov8" title="1">{
                return valIsISBNv13(strNum)
        }</span> else<span class="cov8" title="1"> {
                return valIsISBNv10(strNum) || valIsISBNv13(strNum)
        }</span>
}

func valIsISBNv10(str string) bool <span class="cov8" title="1">{
        len := len(str)
        sum := 0

        if len != 10 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for i, char := range str </span><span class="cov8" title="1">{
                pos := len - i
                num, err := strconv.Atoi(string(char))

                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">sum += pos * num</span>
        }

        <span class="cov8" title="1">rem := sum % 11

        return rem == 0</span>
}

func valIsISBNv13(str string) bool <span class="cov8" title="1">{
        len := len(str)
        sum := 0

        if len != 13 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for i, char := range str </span><span class="cov8" title="1">{
                pos := len - i
                num, err := strconv.Atoi(string(char))

                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">if pos%2 == 0 </span><span class="cov8" title="1">{
                        sum += 3 * num
                        // fmt.Printf("3 * %d\n", num)
                }</span> else<span class="cov8" title="1"> {
                        sum += 1 * num
                        // fmt.Printf("1 * %d\n", num)
                }</span>
        }

        // fmt.Println("Sum is", sum)

        <span class="cov8" title="1">rem := sum % 10

        return rem == 0</span>
}

func stripDashesAndSpaces(str string) string <span class="cov8" title="1">{
        strWthOutDashes := strings.ReplaceAll(str, "-", "")
        strWthOutSpacesAndDashes := strings.ReplaceAll(strWthOutDashes, " ", "")

        return strWthOutSpacesAndDashes
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package validatorgo

import "regexp"

var r = regexp.MustCompile(`^[A-Z]{2}[A-Z0-9]{9}\d$`)

var inc = [2][10]int{
        {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
        {0, 2, 4, 6, 8, 1, 3, 5, 7, 9},
}

// A validator that checks if the string is an ISIN (stock/security identifier).
func IsISIN(str string) bool <span class="cov8" title="1">{
        if !r.MatchString(str) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">var sum, p int
        for i := 10; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                p = 1 - p
                if d := str[i]; d &lt; 'A' </span><span class="cov8" title="1">{
                        sum += inc[p][d-'0']
                }</span> else<span class="cov8" title="1"> {
                        d -= 'A'
                        sum += inc[p][d%10]
                        p = 1 - p
                        sum += inc[p][d/10+1]
                }</span>
        }
        <span class="cov8" title="1">sum += int(str[11] - '0')
        return sum%10 == 0</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package validatorgo

var AllISO31661Alpha2 = [...]string{"AA", "AB", "AC", "AD", "AE", "AF", "AG", "AH", "AI", "AJ", "AK", "AL", "AM", "AN", "AO", "AP", "AQ", "AR", "AS", "AT",
        "AU", "AV", "AW", "AX", "AY", "AZ",
        "BA", "BB", "BC", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BK", "BL", "BM", "BN", "BO", "BP", "BQ", "BR", "BS", "BT", "BU", "BV", "BW", "BX", "BY", "BZ",
        "CA", "CB", "CC", "CD", "CE", "CF", "CG", "CH", "CI", "CJ", "CK", "CL", "CM", "CN", "CO", "CP", "CQ", "CR", "CS", "CT", "CU", "CV", "CW", "CX", "CY", "CZ",
        "DA", "DB", "DC", "DD", "DE", "DF", "DG", "DH", "DI", "DJ", "DK", "DL", "DM", "DN", "DO", "DP", "DQ", "DR", "DS", "DT", "DU", "DV", "DW", "DX", "DY", "DZ",
        "EA", "EB", "EC", "ED", "EE", "EF", "EG", "EH", "EI", "EJ", "EK", "EL", "EM", "EN", "EO", "EP", "EQ", "ER", "ES", "ET", "EU", "EV", "EW", "EX", "EY", "EZ",
        "FA", "FB", "FC", "FD", "FE", "FF", "FG", "FH", "FI", "FJ", "FK", "FL", "FM", "FN", "FO", "FP", "FQ", "FR", "FS", "FT", "FU", "FV", "FW", "FX", "FY", "FZ",
        "GA", "GB", "GC", "GD", "GE", "GF", "GG", "GH", "GI", "GJ", "GK", "GL", "GM", "GN", "GO", "GP", "GQ", "GR", "GS", "GT", "GU", "GV", "GW", "GX", "GY", "GZ",
        "HA", "HB", "HC", "HD", "HE", "HF", "HG", "HH", "HI", "HJ", "HK", "HL", "HM", "HN", "HO", "HP", "HQ", "HR", "HS", "HT", "HU", "HV", "HW", "HX", "HY", "HZ",
        "IA", "IB", "IC", "ID", "IE", "IF", "IG", "IH", "II", "IJ", "IK", "IL", "IM", "IN", "IO", "IP", "IQ", "IR", "IS", "IT", "IU", "IV", "IW", "IX", "IY", "IZ",
        "JA", "JB", "JC", "JD", "JE", "JF", "JG", "JH", "JI", "JJ", "JK", "JL", "JM", "JN", "JO", "JP", "JQ", "JR", "JS", "JT", "JU", "JV", "JW", "JX", "JY", "JZ",
        "KA", "KB", "KC", "KD", "KE", "KF", "KG", "KH", "KI", "KJ", "KK", "KL", "KM", "KN", "KO", "KP", "KQ", "KR", "KS", "KT", "KU", "KV", "KW", "KX", "KY", "KZ",
        "LA", "LB", "LC", "LD", "LE", "LF", "LG", "LH", "LI", "LJ", "LK", "LL", "LM", "LN", "LO", "LP", "LQ", "LR", "LS", "LT", "LU", "LV", "LW", "LX", "LY", "LZ",
        "MA", "MB", "MC", "MD", "ME", "MF", "MG", "MH", "MI", "MJ", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ",
        "NA", "NB", "NC", "ND", "NE", "NF", "NG", "NH", "NI", "NJ", "NK", "NL", "NM", "NN", "NO", "NP", "NQ", "NR", "NS", "NT", "NU", "NV", "NW", "NX", "NY", "NZ",
        "OA", "OB", "OC", "OD", "OE", "OF", "OG", "OH", "OI", "OJ", "OK", "OL", "OM", "ON", "OO", "OP", "OQ", "OR", "OS", "OT", "OU", "OV", "OW", "OX", "OY", "OZ",
        "PA", "PB", "PC", "PD", "PE", "PF", "PG", "PH", "PI", "PJ", "PK", "PL", "PM", "PN", "PO", "PP", "PQ", "PR", "PS", "PT", "PU", "PV", "PW", "PX", "PY", "PZ",
        "QA", "QB", "QC", "QD", "QE", "QF", "QG", "QH", "QI", "QJ", "QK", "QL", "QM", "QN", "QO", "QP", "QQ", "QR", "QS", "QT", "QU", "QV", "QW", "QX", "QY", "QZ",
        "RA", "RB", "RC", "RD", "RE", "RF", "RG", "RH", "RI", "RJ", "RK", "RL", "RM", "RN", "RO", "RP", "RQ", "RR", "RS", "RT", "RU", "RV", "RW", "RX", "RY", "RZ",
        "SA", "SB", "SC", "SD", "SE", "SF", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SP", "SQ", "SR", "SS", "ST", "SU", "SV", "SW", "SX", "SY", "SZ",
        "TA", "TB", "TC", "TD", "TE", "TF", "TG", "TH", "TI", "TJ", "TK", "TL", "TM", "TN", "TO", "TP", "TQ", "TR", "TS", "TT", "TU", "TV", "TW", "TX", "TY", "TZ",
        "UA", "UB", "UC", "UD", "UE", "UF", "UG", "UH", "UI", "UJ", "UK", "UL", "UM", "UN", "UO", "UP", "UQ", "UR", "US", "UT", "UU", "UV", "UW", "UX", "UY", "UZ",
        "VA", "VB", "VC", "VD", "VE", "VF", "VG", "VH", "VI", "VJ", "VK", "VL", "VM", "VN", "VO", "VP", "VQ", "VR", "VS", "VT", "VU", "VV", "VW", "VX", "VY", "VZ",
        "WA", "WB", "WC", "WD", "WE", "WF", "WG", "WH", "WI", "WJ", "WK", "WL", "WM", "WN", "WO", "WP", "WQ", "WR", "WS", "WT", "WU", "WV", "WW", "WX", "WY", "WZ",
        "XA", "XB", "XC", "XD", "XE", "XF", "XG", "XH", "XI", "XJ", "XK", "XL", "XM", "XN", "XO", "XP", "XQ", "XR", "XS", "XT", "XU", "XV", "XW", "XX", "XY", "XZ",
        "YA", "YB", "YC", "YD", "YE", "YF", "YG", "YH", "YI", "YJ", "YK", "YL", "YM", "YN", "YO", "YP", "YQ", "YR", "YS", "YT", "YU", "YV", "YW", "YX", "YY", "YZ",
        "ZA", "ZB", "ZC", "ZD", "ZE", "ZF", "ZG", "ZH", "ZI", "ZJ", "ZK", "ZL", "ZM", "ZN", "ZO", "ZP", "ZQ", "ZR", "ZS", "ZT", "ZU", "ZV", "ZW", "ZX", "ZY", "ZZ",
}

// A validator that checks if the string is a valid ISO 3166-1 alpha-2 officially assigned country code.
func IsISO31661Alpha2(str string) bool <span class="cov8" title="1">{
        return IsIn(str, AllISO31661Alpha2[:])
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package validatorgo

var AllISO31661Alpha3 = [...]string{"AFG", "ALB", "DZA", "ASM", "AND", "AGO", "AIA", "ATA", "ATG", "ARG", "ARM", "ABW", "AUS", "AUT", "AZE",
        "BHS", "BHR", "BGD", "BRB", "BLR", "BEL", "BLZ", "BEN", "BMU", "BTN", "BOL", "BIH", "BWA", "BVT", "BRA",
        "IOT", "BRN", "BGR", "BFA", "BDI", "CPV", "KHM", "CMR", "CAN", "CYM", "CAF", "TCD", "CHL", "CHN", "CXR",
        "CCK", "COL", "COM", "COG", "COD", "COK", "CRI", "CIV", "HRV", "CUB", "CUW", "CYP", "CZE", "DNK", "DJI",
        "DMA", "DOM", "ECU", "EGY", "SLV", "GNQ", "ERI", "EST", "SWZ", "ETH", "FLK", "FRO", "FJI", "FIN", "FRA",
        "GUF", "PYF", "ATF", "GAB", "GMB", "GEO", "DEU", "GHA", "GIB", "GRC", "GRL", "GRD", "GLP", "GUM", "GTM",
        "GGY", "GIN", "GNB", "GUY", "HTI", "HMD", "VAT", "HND", "HKG", "HUN", "ISL", "IND", "IDN", "IRN", "IRQ",
        "IRL", "IMN", "ISR", "ITA", "JAM", "JPN", "JEY", "JOR", "KAZ", "KEN", "KIR", "PRK", "KOR", "KWT", "KGZ",
        "LAO", "LVA", "LBN", "LSO", "LBR", "LBY", "LIE", "LTU", "LUX", "MAC", "MDG", "MWI", "MYS", "MDV", "MLI",
        "MLT", "MHL", "MTQ", "MRT", "MUS", "MYT", "MEX", "FSM", "MDA", "MCO", "MNG", "MNE", "MSR", "MAR", "MOZ",
        "MMR", "NAM", "NRU", "NPL", "NLD", "NCL", "NZL", "NIC", "NER", "NGA", "NIU", "NFK", "MKD", "MNP", "NOR",
        "OMN", "PAK", "PLW", "PAN", "PNG", "PRY", "PER", "PHL", "PCN", "POL", "PRT", "PRI", "QAT", "MKD", "ROU",
        "RUS", "RWA", "REU", "BLM", "SHN", "KNA", "LCA", "MAF", "SPM", "VCT", "WSM", "SMR", "STP", "SAU", "SEN",
        "SRB", "SYC", "SLE", "SGP", "SXM", "SVK", "SVN", "SLB", "SOM", "ZAF", "SGS", "SSD", "ESP", "LKA", "SDN",
        "SUR", "SWE", "CHE", "SYR", "TWN", "TJK", "TZA", "THA", "TLS", "TGO", "TKL", "TON", "TTO", "TUN", "TUR",
        "TKM", "TCA", "TUV", "UGA", "UKR", "ARE", "GBR", "USA", "URY", "UZB", "VUT", "VEN", "VNM", "WLF", "ESH",
        "YEM", "ZMB", "ZWE",
}

// A validator that checks if the string is a valid ISO 3166-1 alpha-3 officially assigned country code.
func IsISO31661Alpha3(str string) bool <span class="cov8" title="1">{
        return IsIn(str, AllISO31661Alpha3[:])
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package validatorgo

var AllISO31661Numeric = [...]string{"004", "008", "010", "012", "016", "020", "024", "028", "031", "032", "036", "040", "044", "048", "050", "051", "052", "056", "060", "064", "068", "070", "072", "074", "076", "084", "086", "090", "092", "096", "100", "104", "108", "112", "116", "120", "124", "132", "136", "140", "144", "148", "150", "154", "156", "158", "162", "166", "170", "174", "175", "178", "180", "184", "188", "192", "196", "200", "204", "208", "212", "214", "218", "222", "226", "231", "232", "233", "234", "236", "240", "244", "248", "250", "254", "258", "260", "262", "266", "268", "270", "275", "276", "288", "292", "296", "300", "304", "308", "312", "316", "320", "324", "328", "332", "334", "336", "340", "344", "348", "352", "356", "360", "364", "368", "372", "376", "380", "384", "388", "392", "398", "400", "404", "408", "410", "414", "417", "418", "422", "426", "428", "430", "434", "438", "440", "442", "446", "450", "454", "458", "462", "466", "470", "474", "478", "480", "484", "492", "496", "498", "499", "500", "504", "508", "512", "516", "520", "524", "528", "531", "533", "534", "536", "540", "548", "552", "556", "562", "566", "570", "574", "578", "580", "581", "583", "584", "585", "586", "591", "598", "600", "604", "608", "612", "616", "620", "624", "626", "630", "634", "638", "642", "643", "646", "652", "654", "659", "660", "662", "663", "666", "670", "674", "678", "682", "686", "688", "690", "694", "702", "703", "704", "705", "706", "710", "716", "724", "728", "729", "732", "740", "744", "748", "750", "754", "758", "760", "762", "764", "768", "772", "776", "780", "784", "788", "792", "795", "796", "798", "800", "804", "808", "812", "816", "818", "826", "831", "832", "833", "834", "840", "850", "854", "858", "860", "862", "876", "882", "887", "894"}

// A validator that checks check if the string is a valid ISO 3166-1 numeric officially assigned country code.
func IsISO31661Numeric(str string) bool <span class="cov8" title="1">{
        return IsIn(str, AllISO31661Numeric[:])
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package validatorgo

var AllISO4217Codes = [...]string{
        "AED", "AFN", "ALL", "AMD", "ANG", "AOA", "ARS", "AUD", "AWG", "AZN",
        "BAM", "BBD", "BDT", "BGN", "BHD", "BIF", "BMD", "BND", "BOB", "BOV",
        "BRL", "BSD", "BTN", "BWP", "BYN", "BZD", "CAD", "CDF", "CHE", "CHF",
        "CHW", "CLF", "CLP", "CNY", "COP", "COU", "CRC", "CUC", "CUP", "CVE",
        "CZK", "DJF", "DKK", "DOP", "DZD", "EGP", "ERN", "ETB", "EUR", "FJD",
        "FKP", "FOK", "GBP", "GEL", "GGP", "GHS", "GIP", "GMD", "GNF", "GTQ",
        "GYD", "HKD", "HNL", "HRK", "HTG", "HUF", "IDR", "ILS", "IMP", "INR",
        "IQD", "IRR", "ISK", "JMD", "JOD", "JPY", "KES", "KGS", "KHR", "KID",
        "KMF", "KPW", "KRW", "KWD", "KYD", "KZT", "LAK", "LBP", "LKR", "LRD",
        "LSL", "LYD", "MAD", "MDL", "MGA", "MKD", "MMK", "MNT", "MOP", "MRU",
        "MUR", "MVR", "MWK", "MXN", "MXV", "MYR", "MZN", "NAD", "NGN", "NIO",
        "NOK", "NPR", "NZD", "OMR", "PAB", "PEN", "PGK", "PHP", "PKR", "PLN",
        "PYG", "QAR", "RON", "RSD", "RUB", "RWF", "SAR", "SBD", "SCR", "SDG",
        "SEK", "SGD", "SHP", "SLL", "SOS", "SRD", "SSP", "STN", "SVC", "SYP",
        "SZL", "THB", "TJS", "TMT", "TND", "TOP", "TRY", "TTD", "TVD", "TWD",
        "TZS", "UAH", "UGX", "USD", "USN", "UYI", "UYU", "UYW", "UZS", "VED",
        "VES", "VND", "VUV", "WST", "XAF", "XAG", "XAU", "XBA", "XBB", "XBC",
        "XBD", "XCD", "XDR", "XOF", "XPD", "XPF", "XPT", "XSU", "XTS", "XUA",
        "YER", "ZAR", "ZMW", "ZWL",
}

// A validator that checks if the string is a valid ISO 4217 officially assigned currency code.
func IsIso4217(str string) bool <span class="cov8" title="1">{
        return IsIn(str, AllISO4217Codes[:])
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package validatorgo

import (
        "math"
        "regexp"
        "strconv"
)

// iso6346numValues is the set of alphabets and their iso6346 numerical values
var iso6346numValues = map[string]int{
        "A": 10, "B": 12, "C": 13, "D": 14, "E": 15, "F": 16, "G": 17, "H": 18, "I": 19, "J": 20, "K": 21, "L": 23, "M": 24,
        "N": 25, "O": 26, "P": 27, "Q": 28, "R": 29, "S": 30, "T": 31, "U": 32, "V": 34, "W": 35, "X": 36, "Y": 37, "Z": 38,
        "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9,
}

// A validator that checks if the string is a valid ISO 6346 shipping container identification.
func IsISO6346(str string) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(`^([A-Z]{3})([UJZR])(\d{6})(\d)$`)
        capGrps := re.FindStringSubmatch(str)
        if capGrps == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">checkDig := capGrps[4]
        len := len(str)
        sum := 0
        for ind, char := range str </span><span class="cov8" title="1">{
                if len-1 == ind </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">numVal, ok := iso6346numValues[string(char)]

                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">sum += int(float64(numVal) * math.Pow(2.00, float64(ind)))</span>
        }

        <span class="cov8" title="1">rem := sum % 11
        remStr := strconv.Itoa(rem)

        return remStr == checkDig</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package validatorgo

var AllISO6391Codes = [...]string{"aa", "ab", "af", "ak", "am", "an", "ar", "as", "av", "ay", "az", "ba", "be", "bg", "bh", "bi", "bm", "bn", "bo", "br", "bs", "ca", "ce", "ch", "co", "cr", "cs", "cv", "cy", "da", "de", "dv", "dz", "ee", "el", "en", "es", "et", "eu", "fa", "ff", "fi", "fj", "fo", "fr", "fy", "ga", "gd", "gl", "gn", "gu", "gv", "ha", "he", "hi", "ho", "hr", "ht", "hu", "hy", "hz", "id", "ig", "ii", "ik", "io", "is", "it", "iu", "ja", "jv", "ka", "kg", "ki", "kj", "kk", "kl", "km", "kn", "ko", "kr", "ks", "ku", "kv", "kw", "ky", "lb", "lg", "li", "ln", "lo", "lt", "lu", "lv", "mg", "mh", "mi", "mk", "ml", "mn", "mr", "ms", "mt", "my", "na", "nb", "nd", "ne", "ng", "nl", "nn", "no", "nr", "nv", "ny", "oc", "oj", "om", "or", "os", "pa", "pl", "ps", "pt", "qu", "rm", "rn", "ro", "ru", "rw", "sa", "sc", "sd", "se", "sg", "si", "sk", "sl", "sm", "sn", "so", "sq", "sr", "ss", "st", "su", "sv", "sw", "ta", "te", "tg", "th", "ti", "tk", "tl", "tn", "to", "tr", "ts", "tt", "tw", "ty", "ug", "uk", "ur", "uz", "ve", "vi", "wa", "wo", "xh", "yi", "yo", "za", "zh", "zu"}

// A validator that checks if the string is a valid ISO 639-1 language code.
func IsISO6391(str string) bool <span class="cov8" title="1">{
        return IsIn(str, AllISO6391Codes[:])
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package validatorgo

import (
        "regexp"
        "strconv"
)

type IsISO8601Opts struct {
        Strict          bool
        StrictSeparator bool
}

// A validator that checks if the string is a valid ISO 8601 date.
// IsISO8601Opts is a struct which defaults to { Strict: false, StrictSeparator: false }.
// If Strict is true, date strings with invalid dates like 2009-02-29 will be invalid.
// If StrictSeparator is true, date strings with date and time separated by anything other than a T will be invalid.
func IsISO8601(str string, opts IsISO8601Opts) bool <span class="cov8" title="1">{
        var re *regexp.Regexp

        if opts.StrictSeparator </span><span class="cov8" title="1">{
                re = regexp.MustCompile(`^(\d{4})(-(0[1-9]|1[0-2])(-([12]\d|0[1-9]|3[01]))([T\s]((([01]\d|2[0-3])((:)[0-5]\d))([\:]\d+)?)?(:[0-5]\d([\.]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)$`)
        }</span> else<span class="cov8" title="1"> {
                re = regexp.MustCompile(`^(\d{4})([-\/\. ](0[1-9]|1[0-2])([-\/\. ]([12]\d|0[1-9]|3[01]))([T\s]((([01]\d|2[0-3])([: \.])[0-5]\d)(([: \.])\d+)?([: \.][0-5]\d([\.]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3])[: \.]?([0-5]\d)?)?)?)?)$`)
        }</span>

        <span class="cov8" title="1">capGrps := re.FindStringSubmatch(str)

        if capGrps == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if opts.Strict </span><span class="cov8" title="1">{
                year, err := strconv.Atoi(capGrps[1])

                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">month, err := strconv.Atoi(capGrps[3])

                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">day, err := strconv.Atoi(capGrps[5])

                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">monthLength := []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}

                // Adjust for leap years
                if year%400 == 0 || (year%100 != 0 &amp;&amp; year%4 == 0) </span><span class="cov8" title="1">{
                        monthLength[1] = 29
                }</span>

                <span class="cov8" title="1">if !(month &gt; 0 &amp;&amp; month &lt; 13) </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">if day &lt; 0 || day &gt; monthLength[month-1] </span><span class="cov8" title="1">{
                        return false
                }</span>

        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package validatorgo

import (
        "fmt"
        "regexp"
)

// A validator that checks if the string is an ISRC.
// allowHyphens will allow codes with dashes present CC-XXX-YY-NNNNN
func IsISRC(str string, allowHyphens bool) bool <span class="cov8" title="1">{
        var char string

        if allowHyphens </span><span class="cov8" title="1">{
                char = "-?"
        }</span>

        <span class="cov8" title="1">re := regexp.MustCompile(fmt.Sprintf(`^([A-Z]{2})%s([A-Z]{3})%s(\d{2})%s(\d{5})$`, char, char, char))
        capGrp := re.FindStringSubmatch(str)

        if capGrp == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">cntryCode := capGrp[1]

        return IsISO31661Alpha2(cntryCode)</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package validatorgo

import (
        "fmt"
        "regexp"
        "strconv"
)

type IsISSNOpts struct {
        RequireHyphen bool
        CaseSensitive bool
}

// A validator that checks if the string is an ISSN.
// IsISSNOpts is a struct which defaults to { CaseSensitive: false, RequireHyphen: false }.
// If CaseSensitive is true, ISSNs with a lowercase 'x' as the check digit are rejected.
func IsISSN(str string, opts IsISSNOpts) bool <span class="cov8" title="1">{
        var reqHypStr string
        if !opts.RequireHyphen </span><span class="cov8" title="1">{
                reqHypStr = "?"
        }</span>

        <span class="cov8" title="1">var reqCasSenStr string
        if !opts.CaseSensitive </span><span class="cov8" title="1">{
                reqCasSenStr = "x"
        }</span>

        <span class="cov8" title="1">re := regexp.MustCompile(fmt.Sprintf(`^[0-9]{4}-%s[0-9]{3}[0-9X%s]$`, reqHypStr, reqCasSenStr))
        capGrp := re.FindStringSubmatch(str)

        if capGrp == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">strWithoutDashes := stripDashesAndSpaces(str)
        len := len(strWithoutDashes)

        sum := 0
        checkVal := ""
        for ind, char := range strWithoutDashes </span><span class="cov8" title="1">{
                charVal := string(char)

                if len-1 == ind </span><span class="cov8" title="1">{
                        checkVal = charVal
                        break</span>
                }

                <span class="cov8" title="1">pos := len - ind
                charInt, err := strconv.Atoi(charVal)

                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                // fmt.Printf("%d x %d\n", charInt, pos)
                <span class="cov8" title="1">sum += pos * charInt</span>
        }

        // fmt.Printf("Sum: %d\n", sum)

        <span class="cov8" title="1">checkValIsNotX := checkVal != "X" &amp;&amp; checkVal != "x"
        checkDig, err := strconv.Atoi(checkVal)

        if checkValIsNotX &amp;&amp; err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">rem := sum % 11

        if rem == 0 </span><span class="cov8" title="1">{
                // fmt.Printf("There is no rem and check digit: %d", checkDig)
                return checkDig == 0
        }</span>

        <span class="cov8" title="1">remSub11 := 11 - rem

        if remSub11 &lt; 10 </span><span class="cov8" title="1">{
                // fmt.Printf("rem sub is less than 10 check digit: %d, remSub: %d\n", checkDig, remSub11)
                return remSub11 == checkDig
        }</span>

        // fmt.Printf("rem sub is greater than 10 check val: %s", checkVal)
        <span class="cov8" title="1">return checkVal == "X" || checkVal == "x"</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package validatorgo

import "encoding/json"

// type IsJSONOpts struct {
// AllowPrimitives bool
// }

// A validator that checks if the string is valid JSON (note: uses json.Valid).
func IsJSON(str string) bool <span class="cov8" title="1">{
        // var js json.RawMessage

        // return json.Unmarshal([]byte(str), &amp;js) == nil
        return json.Valid([]byte(str))
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package validatorgo

import (
        "encoding/base64"
        "regexp"
)

// A validator that checks if the string is valid JWT token.
func IsJWT(str string) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(`^([a-zA-Z0-9_=]+)\.([a-zA-Z0-9_=]+)\.([a-zA-Z0-9_\-\+\/=]*)`)
        capGrp := re.FindStringSubmatch(str)

        if capGrp == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">payload := capGrp[2]

        rawDecodedTxt, err := base64.RawURLEncoding.DecodeString(payload)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">jsonDecodedTxt := string(rawDecodedTxt)

        return IsJSON(jsonDecodedTxt)</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package validatorgo

import (
        "regexp"
)

type IsLatLongOpts struct {
        CheckDMS bool
}

// A validator that checks if the string is a valid latitude-longitude coordinate in the format lat,long or lat, long.
// options is an object that defaults to { CheckDMS: false }.
// Pass CheckDMS as true to validate DMS(degrees, minutes, and seconds) latitude-longitude format.
func IsLatLong(str string, opts IsLatLongOpts) bool <span class="cov8" title="1">{
        var re *regexp.Regexp
        if opts.CheckDMS </span><span class="cov8" title="1">{
                re = regexp.MustCompile(`^([+\-]?[0-8]?\d|90)[°˚º\s-]+([0-5]?\d)['′\s-]+([0-5]?\d(\.\d*)?)["¨˝\s-]*([NnSs])[\s,]+([+\-]?(0?\d?\d|1[0-7]\d|180))[°˚º\s-]+([0-5]?\d)['′\s-]+([0-5]?\d(\.\d*)?)["¨˝\s-]*([EeWw])$`)
                return re.MatchString(str)
        }</span> else<span class="cov8" title="1"> {
                re = regexp.MustCompile(`^[-+]?([1-8]?\d(\.\d+)?|90(\.0+)?),\s*[-+]?(180(\.0+)?|((1[0-7]\d)|([1-9]?\d))(\.\d+)?)$`)
                return re.MatchString(str)
        }</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package validatorgo

import (
        "unicode/utf8"
)

type IsLengthOpts struct {
        Min uint
        Max *uint
}

// A validator that checks if the string's length falls in a range.
// IsLengthOpts is a struct which defaults to { Min: 0, Max: nil }.
// Note: this function takes into account surrogate pairs.
func IsLength(str string, opts IsLengthOpts) bool <span class="cov8" title="1">{
        len := uint(utf8.RuneCountInString(str))

        withinLimits := true

        if opts.Max != nil </span><span class="cov8" title="1">{
                isMax := *(opts.Max) &gt;= len
                withinLimits = withinLimits &amp;&amp; isMax
        }</span>

        <span class="cov8" title="1">isMin := opts.Min &lt;= len
        withinLimits = withinLimits &amp;&amp; isMin

        return withinLimits</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package validatorgo

import "regexp"

var localeLicensePlateRegex = map[string]*regexp.Regexp{
        "cs-CZ": regexp.MustCompile(`/^(([ABCDEFHKIJKLMNPRSTUVXYZ]|[0-9])-?){5,8}$/g`),
}

// (NOT IMPLEMENTED, DO NOT USE) A validator that checks if the string matches the format of a country's license plate.
// locale is one of 'cs-CZ', 'de-DE', 'de-LI', 'en-IN', 'en-SG', 'en-PK', 'es-AR', 'hu-HU', 'pt-BR', 'pt-PT', 'sq-AL', 'sv-SE', 'any'.
func IsLicensePlate(str string, locale string) bool <span class="cov0" title="0">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package validatorgo

var AllLocales = [...]string{"ar_AE", "ar_BH", "ar_DJ", "ar_DZ", "ar_EG", "ar_EH", "ar_ER", "ar_IL", "ar_IQ", "ar_JO", "ar_KM", "ar_KW", "ar_LB", "ar_LY", "ar_MA", "ar_MR", "ar_OM", "ar_PS", "ar_QA", "ar_SA", "ar_SD", "ar_SO", "ar_SS", "ar_SY", "ar_TD", "ar_TN", "ar_YE", "as_IN", "asa_TZ", "az_Cyrl_AZ", "az_Latn_AZ", "bas_CM", "be_BY", "bem_ZM", "bez_TZ", "bg_BG", "bm_ML", "bn_BD", "bn_IN", "bo_CN", "bo_IN", "br_FR", "brx_IN", "bs_Cyrl_BA", "bs_Latn_BA", "ca_AD", "ca_ES", "ca_FR", "ca_IT", "ce_RU", "cgg_UG", "chr_US", "cs_CZ", "cy_GB", "da_DK", "dav_KE", "de_AT", "de_BE", "de_CH", "de_DE", "de_IT", "de_LI", "de_LU", "dje_NE", "dsb_DE", "dua_CM", "dyo_SN", "dz_BT", "ebu_KE", "ee_GH", "ee_TG", "el_CY", "el_GR", "en_AG", "en_AI", "en_AS", "en_AT", "en_AU", "en_BB", "en_BE", "en_BI", "en_BM", "en_BS", "en_BW", "en_BZ", "en_CA", "en_CC", "en_CH", "en_CK", "en_CM", "en_CX", "en_CY", "en_DE", "en_DG", "en_DK", "en_DM", "en_ER", "en_FI", "en_FJ", "en_FK", "en_FM", "en_GB", "en_GD", "en_GG", "en_GH", "en_GI", "en_GM", "en_GU", "en_GY", "en_HK", "en_IE", "en_IL", "en_IM", "en_IN", "en_IO", "en_JE", "en_JM", "en_KE", "en_KI", "en_KN", "en_KY", "en_LC", "en_LR", "en_LS", "en_MG", "en_MH", "en_MO", "en_MP", "en_MS", "en_MT", "en_MU", "en_MW", "en_MY", "en_NA", "en_NF", "en_NG", "en_NL", "en_NR", "en_NU", "en_NZ", "en_PG", "en_PH", "en_PK", "en_PN", "en_PR", "en_PW", "en_RW", "en_SB", "en_SC", "en_SD", "en_SE", "en_SG", "en_SH", "en_SI", "en_SL", "en_SS", "en_SX", "en_SZ", "en_TC", "en_TK", "en_TO", "en_TT", "en_TV", "en_TZ", "en_UG", "en_UM", "en_US", "en_VC", "en_VG", "en_VI", "en_VU", "en_WS", "en_ZA", "en_ZM", "en_ZW", "eo", "es_AR", "es_BO", "es_BR", "es_BZ", "es_CL", "es_CO", "es_CR", "es_CU", "es_DO", "es_EA", "es_EC", "es_ES", "es_GQ", "es_GT", "es_HN", "es_IC", "es_MX", "es_NI", "es_PA", "es_PE", "es_PR", "es_PY", "es_SV", "es_US", "es_UY", "es_VE", "et_EE", "eu_ES", "ewo_CM", "fa_AF", "fa_IR", "ff_CM", "ff_GN", "ff_MR", "ff_SN", "fi_FI", "fil_PH", "fo_DK", "fo_FO", "fr_BE", "fr_BF", "fr_BI", "fr_BJ", "fr_BL", "fr_CA", "fr_CD", "fr_CF", "fr_CG", "fr_CH", "fr_CI", "fr_CM", "fr_DJ", "fr_DZ", "fr_FR", "fr_GA", "fr_GF", "fr_GN", "fr_GP", "fr_GQ", "fr_HT", "fr_KM", "fr_LU", "fr_MA", "fr_MC", "fr_MF", "fr_MG", "fr_ML", "fr_MQ", "fr_MR", "fr_MU", "fr_NC", "fr_NE", "fr_PF", "fr_PM", "fr_RE", "fr_RW", "fr_SC", "fr_SN", "fr_SY", "fr_TD", "fr_TG", "fr_TN", "fr_VU", "fr_WF", "fr_YT", "fur_IT", "fy_NL", "ga_IE", "gd_GB", "gl_ES", "gsw_CH", "gsw_FR", "gsw_LI", "gu_IN", "guz_KE", "gv_IM", "ha_GH", "ha_NE", "ha_NG", "haw_US", "he_IL", "hi_IN", "hr_BA", "hr_HR", "hsb_DE", "hu_HU", "hy_AM", "ig_NG", "ii_CN", "is_IS", "it_CH", "it_IT", "it_SM", "iu_CA", "ja_JP", "jgo_CM", "jmc_TZ", "ka_GE", "kab_DZ", "kam_KE", "kde_TZ", "kea_CV", "khq_ML", "ki_KE", "kk_KZ", "kkj_CM", "kl_GL", "kln_KE", "km_KH", "kn_IN", "ko_KP", "ko_KR", "kok_IN", "ks_IN", "ksb_TZ", "ksf_CM", "ksh_DE", "kw_GB", "ky_KG", "lag_TZ", "lb_LU", "lg_UG", "lkt_US", "ln_AO", "ln_CD", "ln_CF", "ln_CG", "lo_LA", "lrc_IQ", "lrc_IR", "lt_LT", "lu_CD", "luo_KE", "luy_KE", "lv_LV", "mas_KE", "mas_TZ", "mer_KE", "mfe_MU", "mg_MG", "mgh_MZ", "mgo_CM", "mi_NZ", "mk_MK", "ml_IN", "mn_MN", "mr_IN", "ms_BN", "ms_MY", "ms_SG", "mt_MT", "mua_CM", "my_MM", "mzn_IR", "naq_NA", "nb_NO", "nd_ZW", "nds_DE", "nds_NL", "ne_IN", "ne_NP", "nl_AW", "nl_BE", "nl_BQ", "nl_CW", "nl_NL", "nl_SR", "nl_SX", "nmg_CM", "nn_NO", "nnh_CM", "nus_SS", "nyn_UG", "om_ET", "om_KE", "or_IN", "os_GE", "os_RU", "pa_Arab_PK", "pa_Guru_IN", "pl_PL", "ps_AF", "pt_AO", "pt_BR", "pt_CH", "pt_CV", "pt_GQ", "pt_GW", "pt_LU", "pt_MO", "pt_MZ", "pt_PT", "pt_ST", "pt_TL", "qu_BO", "qu_EC", "qu_PE", "rm_CH", "rn_BI", "ro_MD", "ro_RO", "rof_TZ", "ru_BY", "ru_KG", "ru_KZ", "ru_MD", "ru_RU", "ru_UA", "rw_RW", "rwk_TZ", "sah_RU", "saq_KE", "sbp_TZ", "se_FI", "se_NO", "se_SE", "seh_MZ", "ses_ML", "sg_CF", "shi_Latn_MA", "shi_Tfng_MA", "si_LK", "sk_SK", "sl_SI", "smn_FI", "sn_ZW", "so_DJ", "so_ET", "so_KE", "so_SO", "sq_AL", "sq_MK", "sq_XK", "sr_Cyrl_BA", "sr_Cyrl_ME", "sr_Cyrl_RS", "sr_Cyrl_XK", "sr_Latn_BA", "sr_Latn_ME", "sr_Latn_RS", "sr_Latn_XK", "sv_AX", "sv_FI", "sv_SE", "sw_CD", "sw_KE", "sw_TZ", "sw_UG", "ta_IN", "ta_LK", "ta_MY", "ta_SG", "te_IN", "teo_KE", "teo_UG", "th_TH", "ti_ER", "ti_ET", "tk_TM", "to_TO", "tr_CY", "tr_TR", "tt_RU", "twq_NE", "tzm_MA", "ug_CN", "uk_UA", "ur_IN", "ur_PK", "uz_Arab_AF", "uz_Cyrl_UZ", "uz_Latn_UZ", "vai_Latn_LR", "vai_Vaii_LR", "vi_VN", "vo_001", "vun_TZ", "wae_CH", "wo_SN", "xh_ZA", "xog_UG", "yav_CM", "yi_001", "yo_BJ", "yo_NG", "yue_Hans_CN", "yue_Hant_HK", "zgh_MA", "zh_CN", "zh_HK", "zh_MO", "zh_SG", "zh_TW", "zu_ZA"}

// A validator that checks if the string is a locale.
func IsLocale(str string) bool <span class="cov8" title="1">{
        return IsIn(str, AllLocales[:])
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package validatorgo

import "strings"

// A validator that checks if the string is lowercase.
func IsLowerCase(str string) bool <span class="cov8" title="1">{
        return str == strings.ToLower(str)
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package validatorgo

import "strconv"

// A validator that checks if the string passes the Luhn algorithm check.
func IsLuhnNumber(str string) bool <span class="cov8" title="1">{
        var (
                len      = len(str)
                sum      = 0
                isSecond = false
        )

        for i := len - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                char := str[i]
                d, err := strconv.Atoi(string(char))

                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">if isSecond </span><span class="cov8" title="1">{
                        d = d * 2
                        if d &gt; 9 </span><span class="cov8" title="1">{
                                d = digitSum(d)
                        }</span>
                }

                <span class="cov8" title="1">sum += d
                isSecond = !isSecond</span>
        }

        <span class="cov8" title="1">return sum%10 == 0</span>
}

// digitSum returns the sum of digits in an int.
func digitSum(i int) (sum int) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                sum += i % 10
                i /= 10
                if i == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package validatorgo

import (
        "fmt"
        "regexp"
)

type IsMacAddressOpts struct {
        NoSeparators bool
        Type         *string
}

var (
        EUIType48 = "48"
        EUIType64 = "64"
)

// A validator that checks if the string is a MAC address.
// IsMacAddressOpts is a struct which defaults to { NoSeparators: false, Type: nil }.
// If NoSeparators is true, the validator will allow MAC addresses without separators.
// Also, it allows the use of hyphens, spaces or dots e.g. '01 02 03 04 05 ab', '01-02-03-04-05-ab' or '0102.0304.05ab'.
// The options also allow a eui property to specify if it needs to be validated against EUI-48 or EUI-64.
// The accepted values of eui are: "48", "64". I have exported EUIType48 and EUIType64. Defaults to "48" if invalid types are passed.
func IsMacAddress(str string, opts IsMacAddressOpts) bool <span class="cov8" title="1">{

        noSepReStr := `[\s:.-]?`
        if opts.NoSeparators </span><span class="cov8" title="1">{
                noSepReStr = ""
        }</span>

        <span class="cov8" title="1">typeReStr := "5"
        if opts.Type == &amp;EUIType64 </span><span class="cov8" title="1">{
                typeReStr = "7"
        }</span>

        // fmt.Println(fmt.Sprintf(`^([[:xdigit:]]{2}%s){%s}[[:xdigit:]]{2}$`, noSepReStr, typeReStr))
        <span class="cov8" title="1">re := regexp.MustCompile(fmt.Sprintf(`^([[:xdigit:]]{2}%s){%s}[[:xdigit:]]{2}$`, noSepReStr, typeReStr))

        return re.MatchString(str)</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string is a Magnet URI format.
func IsMagnetURI(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile(`(?:^magnet:\?|[^?&amp;]&amp;)xt(?:\.1)?=urn:(?:(?:aich|bitprint|btih|ed2k|ed2khash|kzhash|md5|sha1|tree:tiger):[a-z0-9]{32}(?:[a-z0-9]{8})?|btmh:1220[a-z0-9]{64})(?:$|&amp;)`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package validatorgo

import (
        "regexp"
)

type IsMailToURIOpts struct {
        IsEmailOpts
}

// A validator that checks if the string is a Mailto URI format.
// IsMailToURIOpts is a struct that directly embeds IsEmailOpts.
// IsMailToURIOpts validates emails inside the URI (check IsEmailOpts for details).
func IsMailtoURI(str string, opts IsMailToURIOpts) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(`^(mailto:)([^\?]+)(\?.*)?$`)

        capGrp := re.FindStringSubmatch(str)

        if capGrp == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">email := capGrp[2]

        return IsEmail(email, IsEmailOpts{
                AllowDisplayName:         opts.AllowDisplayName,
                RequireDisplayName:       opts.RequireDisplayName,
                AllowUTF8LocalPart:       opts.AllowUTF8LocalPart,
                RequireTld:               opts.RequireTld,
                IgnoreMaxLength:          opts.IgnoreMaxLength,
                AllowIpDomain:            opts.AllowIpDomain,
                DomainSpecificValidation: opts.DomainSpecificValidation,
                BlacklistedChars:         opts.BlacklistedChars,
                HostBlacklist:            opts.HostBlacklist,
                HostWhitelist:            opts.HostWhitelist,
        })</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package validatorgo

// A validator that        checks if the string is a MD5 hash.
// Please note that you can also use the isHash(str, 'md5') function.
// Keep in mind that MD5 has some collision weaknesses compared to other algorithms (e.g., SHA).
func IsMD5(str string) bool <span class="cov8" title="1">{
        return IsHash(str, "md5")
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string matches to a valid MIME type format.
func IsMimeType(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile(`^(application|audio|font|image|message|model|multipart|text|video|x-[\w.+-]+)\/[\w.+-]+(\s*;\s*[\w.+-]+=[\w.+-]+)*$`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package validatorgo

import "regexp"

type IsMobilePhoneOpts struct {
        StrictMode bool
}

// mobilePhoneLocaleRegex is the set of locales and their function validating mobile phone regex
var mobilePhoneLocaleRegex = map[string]func(opts IsMobilePhoneOpts) *regexp.Regexp{
        "am-AM": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+374\d{8}$`) // Armenia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{8}$`)</span>
        },
        "ar-AE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+971\d{8,9}$`) // UAE
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{8,9}$`)</span>
        },
        "ar-BH": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+973\d{8}$`) // Bahrain
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "ar-DZ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+213\d{9}$`) // Algeria
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "ar-EG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+20\d{10}$`) // Egypt
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^01\d{9}$`)</span>
        },
        "ar-IQ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+964\d{10}$`) // Iraq
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "ar-JO": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+962\d{8,9}$`) // Jordan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{8,9}$`)</span>
        },
        "ar-KW": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+965\d{8}$`) // Kuwait
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "ar-PS": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+970\d{8,9}$`) // Palestine
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{8,9}$`)</span>
        },
        "ar-SA": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+9665\d{8}$`) // Saudi Arabia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^05\d{8}$`)</span>
        },
        "ar-SD": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+249\d{9}$`) // Sudan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "ar-SY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+9639\d{8}$`) // Syria
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^09\d{8}$`)</span>
        },
        "ar-TN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+216\d{8}$`) // Tunisia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "ar-YE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+9677\d{7}$`) // Yemen
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^07\d{7}$`)</span>
        },
        "az-AZ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+994\d{9,10}$`) // Azerbaijan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9,10}$`)</span>
        },
        "az-LB": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+961\d{7,8}$`) // Lebanon
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{7,8}$`)</span>
        },
        "az-LY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+2189\d{8}$`) // Libya
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^09\d{8}$`)</span>
        },
        // Example for 'be-BY'
        "be-BY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+375\d{9}$`) // Belarus
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "bg-BG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+359\d{9}$`) // Bulgaria
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "bn-BD": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+8801\d{9}$`) // Bangladesh
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^01\d{9}$`)</span>
        },
        "bs-BA": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+387\d{8}$`) // Bosnia and Herzegovina
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "ca-AD": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+376\d{6}$`) // Andorra
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{6}$`)</span>
        },
        "cs-CZ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+420\d{9}$`) // Czech Republic
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "da-DK": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+45\d{8}$`) // Denmark
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "de-AT": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+43\d{10}$`) // Austria
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "de-CH": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+41\d{9}$`) // Switzerland
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "de-DE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+49\d{10,11}$`) // Germany
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10,11}$`)</span>
        },
        "de-LU": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+352\d{8}$`) // Luxembourg
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "dv-MV": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+960\d{7}$`) // Maldives
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "dz-BT": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+975\d{8}$`) // Bhutan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "el-CY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+357\d{8}$`) // Cyprus
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "el-GR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+30\d{10}$`) // Greece
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "en-AG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+1268\d{7}$`) // Antigua and Barbuda
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "en-AI": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+1264\d{7}$`) // Anguilla
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "en-AU": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+61\d{9}$`) // Australia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "en-BM": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+1441\d{7}$`) // Bermuda
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "en-BS": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+1242\d{7}$`) // Bahamas
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "en-BW": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+267\d{7,8}$`) // Botswana
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7,8}$`)</span>
        },
        "en-CA": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+1\d{10}$`) // Canada
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "en-GB": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+44\d{10}$`) // United Kingdom
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "en-GG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+44\d{10}$`) // Guernsey (shares UK's country code)
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "en-GH": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+233\d{9}$`) // Ghana
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "en-GY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+592\d{7}$`) // Guyana
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "en-HK": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+852\d{8}$`) // Hong Kong
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "en-IE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+353\d{9}$`) // Ireland
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "en-IN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+91\d{10}$`) // India
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "en-JM": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+1876\d{7}$`) // Jamaica
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "en-KE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+254\d{9}$`) // Kenya
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "en-KI": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+686\d{5}$`) // Kiribati
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{5}$`)</span>
        },
        "en-KN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+1869\d{7}$`) // Saint Kitts and Nevis
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "en-LS": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+266\d{8}$`) // Lesotho
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "en-MO": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+853\d{8}$`) // Macau
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "en-MT": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+356\d{8}$`) // Malta
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "en-MU": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+230\d{7}$`) // Mauritius
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "en-MW": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+265\d{9}$`) // Malawi
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "en-NG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov8" title="1">{
                if opts.StrictMode </span><span class="cov8" title="1">{
                        return regexp.MustCompile(`^\+234\d{10}$`) // Nigeria
                }</span>
                <span class="cov8" title="1">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "en-NZ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+64\d{9}$`) // New Zealand
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "en-PG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+675\d{7}$`) // Papua New Guinea
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "en-PH": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+63\d{10}$`) // Philippines
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "en-PK": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+92\d{10}$`) // Pakistan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "en-RW": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+250\d{9}$`) // Rwanda
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "en-SG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+65\d{8}$`) // Singapore
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "en-SL": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+232\d{8}$`) // Sierra Leone
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "en-SS": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+211\d{9}$`) // South Sudan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "en-TZ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+255\d{9}$`) // Tanzania
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "en-UG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+256\d{9}$`) // Uganda
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "en-US": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+1\d{10}$`) // United States
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "en-ZA": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+27\d{9}$`) // South Africa
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "en-ZM": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+260\d{9}$`) // Zambia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{9}$`)</span>
        },
        "en-ZW": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+263\d{9}$`) // Zimbabwe
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "es-AR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+54\d{10}$`) // Argentina
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "es-BO": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+591\d{8}$`) // Bolivia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "es-CL": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+56\d{9}$`) // Chile
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "es-CO": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+57\d{10}$`) // Colombia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "es-CR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+506\d{8}$`) // Costa Rica
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "es-CU": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+53\d{8}$`) // Cuba
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "es-DO": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+1809\d{7}$`) // Dominican Republic
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "es-EC": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+593\d{9}$`) // Ecuador
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "es-ES": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+34\d{9}$`) // Spain
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "es-GT": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+502\d{8}$`) // Guatemala
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "es-HN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+504\d{8}$`) // Honduras
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "es-MX": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+52\d{10}$`) // Mexico
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "es-NI": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+505\d{8}$`) // Nicaragua
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "es-PA": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+507\d{8}$`) // Panama
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "es-PE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+51\d{9}$`) // Peru
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "es-PR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+1\d{10}$`) // Puerto Rico
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "es-PY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+595\d{9}$`) // Paraguay
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "es-SV": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+503\d{8}$`) // El Salvador
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "es-UY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+598\d{9}$`) // Uruguay
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "es-VE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+58\d{10}$`) // Venezuela
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "et-EE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+372\d{7,8}$`) // Estonia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7,8}$`)</span>
        },
        "fa-IR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+98\d{10}$`) // Iran
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "fi-FI": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+358\d{9}$`) // Finland
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fil-PH": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+63\d{10}$`) // Philippines
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^0\d{10}$`)</span>
        },
        "fr-BE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+32\d{8}$`) // Belgium
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-BF": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+226\d{8}$`) // Burkina Faso
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-BJ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+229\d{8}$`) // Benin
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-CD": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+243\d{9}$`) // Democratic Republic of the Congo
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-CF": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+236\d{8}$`) // Central African Republic
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-CG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+242\d{9}$`) // Congo
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-CH": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+41\d{9}$`) // Switzerland
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-CI": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+225\d{8}$`) // Ivory Coast
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-CM": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+237\d{8}$`) // Cameroon
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-DJ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+253\d{8}$`) // Djibouti
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-DZ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+213\d{9}$`) // Algeria
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-FR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+33\d{9}$`) // France
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-GA": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+241\d{7}$`) // Gabon
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "fr-GN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+224\d{8}$`) // Guinea
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-GQ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+240\d{9}$`) // Equatorial Guinea
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-HT": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+509\d{8}$`) // Haiti
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-LU": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+352\d{9}$`) // Luxembourg
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-MA": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+212\d{9}$`) // Morocco
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-MG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+261\d{9}$`) // Madagascar
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-ML": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+223\d{8}$`) // Mali
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-MR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+222\d{8}$`) // Mauritania
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-MU": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+230\d{7}$`) // Mauritius
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "fr-NC": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+687\d{6}$`) // New Caledonia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{6}$`)</span>
        },
        "fr-NE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+227\d{8}$`) // Niger
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-PF": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+689\d{6}$`) // French Polynesia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{6}$`)</span>
        },
        "fr-RW": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+250\d{9}$`) // Rwanda
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-SN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+221\d{9}$`) // Senegal
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-SY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+963\d{9}$`) // Syria
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "fr-TD": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+235\d{8}$`) // Chad
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-TG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+228\d{8}$`) // Togo
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-TN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+216\d{8}$`) // Tunisia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "fr-VU": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+678\d{7}$`) // Vanuatu
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "fr-WF": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+681\d{6}$`) // Wallis and Futuna
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{6}$`)</span>
        },
        "ga-IE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+353\d{9}$`) // Ireland
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "he-IL": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+972\d{8,9}$`) // Israel
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8,9}$`)</span>
        },
        "hi-IN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+91\d{10}$`) // India
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "hr-HR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+385\d{8,9}$`) // Croatia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8,9}$`)</span>
        },
        "hu-HU": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+36\d{9}$`) // Hungary
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "hy-AM": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+374\d{8}$`) // Armenia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "id-ID": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+62\d{9,11}$`) // Indonesia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9,11}$`)</span>
        },
        "it-IT": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+39\d{9,10}$`) // Italy
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9,10}$`)</span>
        },
        "ja-JP": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+81\d{9,10}$`) // Japan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9,10}$`)</span>
        },
        "ka-GE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+995\d{9}$`) // Georgia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "kk-KZ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+7\d{10}$`) // Kazakhstan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "km-KH": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+855\d{8,9}$`) // Cambodia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8,9}$`)</span>
        },
        "ko-KR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+82\d{9,10}$`) // South Korea
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9,10}$`)</span>
        },
        "ky-KG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+996\d{9}$`) // Kyrgyzstan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "lt-LT": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+370\d{8}$`) // Lithuania
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "lv-LV": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+371\d{8}$`) // Latvia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "mn-MN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+976\d{8}$`) // Mongolia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "ms-MY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+60\d{9,10}$`) // Malaysia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9,10}$`)</span>
        },
        "ne-NP": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+977\d{9,10}$`) // Nepal
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9,10}$`)</span>
        },
        "nl-BE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+32\d{8}$`) // Belgium (Dutch)
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "nl-NL": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+31\d{9}$`) // Netherlands
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "no-NO": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+47\d{8}$`) // Norway
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "pl-PL": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+48\d{9}$`) // Poland
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "pt-AO": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+244\d{9}$`) // Angola
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "pt-BR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+55\d{10,11}$`) // Brazil
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10,11}$`)</span>
        },
        "pt-CV": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+238\d{7}$`) // Cape Verde
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "pt-GW": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+245\d{7}$`) // Guinea-Bissau
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7}$`)</span>
        },
        "pt-MZ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+258\d{9}$`) // Mozambique
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "pt-PT": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+351\d{9}$`) // Portugal
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "ro-MD": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+373\d{8}$`) // Moldova
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "ro-RO": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+40\d{9}$`) // Romania
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "ru-BY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+375\d{9}$`) // Belarus
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "ru-KG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+996\d{9}$`) // Kyrgyzstan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "ru-KZ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+7\d{10}$`) // Kazakhstan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "ru-RU": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+7\d{10}$`) // Russia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "ru-UA": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+380\d{9}$`) // Ukraine
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "si-LK": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+94\d{9}$`) // Sri Lanka
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "sk-SK": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+421\d{9}$`) // Slovakia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "sl-SI": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+386\d{8}$`) // Slovenia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "sq-AL": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+355\d{9}$`) // Albania
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "sq-MK": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+389\d{8}$`) // North Macedonia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "sr-BA": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+387\d{8}$`) // Bosnia and Herzegovina
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "sr-ME": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+382\d{8}$`) // Montenegro
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "sr-RS": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+381\d{8,9}$`) // Serbia
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8,9}$`)</span>
        },
        "sv-FI": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+358\d{9}$`) // Finland (Swedish-speaking)
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "sv-SE": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+46\d{7,10}$`) // Sweden
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{7,10}$`)</span>
        },
        "ta-IN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+91\d{10}$`) // India (Tamil)
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "ta-LK": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+94\d{9}$`) // Sri Lanka (Tamil)
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "th-TH": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+66\d{8,9}$`) // Thailand
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8,9}$`)</span>
        },
        "tr-CY": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+90\d{10}$`) // Cyprus (Turkish-speaking)
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "tr-TR": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+90\d{10}$`) // Turkey
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "uk-UA": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+380\d{9}$`) // Ukraine
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "ur-PK": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+92\d{10}$`) // Pakistan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{10}$`)</span>
        },
        "uz-UZ": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+998\d{9}$`) // Uzbekistan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9}$`)</span>
        },
        "vi-VN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+84\d{9,10}$`) // Vietnam
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9,10}$`)</span>
        },
        "zh-CN": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+86\d{11}$`) // China
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{11}$`)</span>
        },
        "zh-HK": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+852\d{8}$`) // Hong Kong
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "zh-MO": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+853\d{8}$`) // Macau
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "zh-SG": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+65\d{8}$`) // Singapore (Mandarin-speaking)
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{8}$`)</span>
        },
        "zh-TW": func(opts IsMobilePhoneOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^\+886\d{9,10}$`) // Taiwan
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^\d{9,10}$`)</span>
        },
}

// A validator that checks if the string is a mobile phone number,
// locale is either an array of locales (e.g. ['sk-SK', 'sr-RS']) possible options are ('am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-EH', 'ar-IQ', 'ar-JO', 'ar-KW', 'ar-PS', 'ar-SA', 'ar-SD', 'ar-SY', 'ar-TN', 'ar-YE', 'az-AZ', 'az-LB', 'az-LY', 'be-BY', 'bg-BG', 'bn-BD', 'bs-BA', 'ca-AD', 'cs-CZ', 'da-DK', 'de-AT', 'de-CH', 'de-DE', 'de-LU', 'dv-MV', 'dz-BT', 'el-CY', 'el-GR', 'en-AG', 'en-AI', 'en-AU', 'en-BM', 'en-BS', 'en-BW', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-GY', 'en-HK', 'en-IE', 'en-IN', 'en-JM', 'en-KE', 'en-KI', 'en-KN', 'en-LS', 'en-MO', 'en-MT', 'en-MU', 'en-MW', 'en-NG', 'en-NZ', 'en-PG', 'en-PH', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-SS', 'en-TZ', 'en-UG', 'en-US', 'en-ZA', 'en-ZM', 'en-ZW', 'es-AR', 'es-BO', 'es-CL', 'es-CO', 'es-CR', 'es-CU', 'es-DO', 'es-EC', 'es-ES', 'es-GT','es-HN', 'es-MX', 'es-NI', 'es-PA', 'es-PE', 'es-PY', 'es-SV', 'es-UY', 'es-VE', 'et-EE', 'fa-AF', 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-BF', 'fr-BJ', 'fr-CD', 'fr-CF', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-PF', 'fr-RE', 'fr-WF', 'ga-IE', 'he-IL', 'hu-HU', 'id-ID', 'ir-IR', 'it-IT', 'it-SM', 'ja-JP', 'ka-GE', 'kk-KZ', 'kl-GL', 'ko-KR', 'ky-KG', 'lt-LT', 'mg-MG', 'mn-MN', 'ms-MY', 'my-MM', 'mz-MZ', 'nb-NO', 'ne-NP', 'nl-AW', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL', 'pt-AO', 'pt-BR', 'pt-PT', 'ro-Md', 'ro-RO', 'ru-RU', 'si-LK', 'sk-SK', 'sl-SI', 'so-SO', 'sq-AL', 'sr-RS', 'sv-SE', 'tg-TJ', 'th-TH', 'tk-TM', 'tr-TR', 'uk-UA', 'uz-UZ', 'vi-VN', 'zh-CN', 'zh-HK', 'zh-MO', 'zh-TW'). If nil is provided any of the locales will be matched. If an unidentified value is used, function will return false.
// IsMobilePhoneOpts is a struct that can be supplied with the following keys:
// StrictMode, if this is set to true, the mobile phone number must be supplied with the country code and therefore must start with +. Locale list is validator.isMobilePhoneLocales.
func IsMobilePhone(str string, locales []string, opts IsMobilePhoneOpts) bool <span class="cov8" title="1">{
        strWithoutSpaces := stripDashesAndSpaces(str)

        if len(locales) == 0 </span><span class="cov0" title="0">{
                for _, valFunc := range mobilePhoneLocaleRegex </span><span class="cov0" title="0">{
                        re := valFunc(opts)

                        if !re.MatchString(strWithoutSpaces) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        } else<span class="cov8" title="1"> {

                for _, loc := range locales </span><span class="cov8" title="1">{
                        valFunc, exists := mobilePhoneLocaleRegex[loc]

                        if !exists </span><span class="cov0" title="0">{
                                return false
                        }</span>

                        <span class="cov8" title="1">re := valFunc(opts)

                        if !re.MatchString(strWithoutSpaces) </span><span class="cov8" title="1">{
                                return false
                        }</span>

                }
        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package validatorgo

import "unicode/utf8"

// A validator that checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.
func IsMongoID(str string) bool <span class="cov8" title="1">{
        return IsHexadecimal(str) &amp;&amp; utf8.RuneCountInString(str) == 24
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string contains one or more multibyte chars.
func IsMultibyte(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile(`[^\x00-\x7F]`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package validatorgo

import (
        "regexp"
)

// IsNumericOpts is used to configure IsNumeric
type IsNumericOpts struct {
        NoSymbols bool
        Locale    string
}

// numericFormatsRegex is the set of number validating regex for each cldr code
var numericFormatsRegex = map[int]func(opts IsNumericOpts) *regexp.Regexp{
        0: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,3})(,\d{3})*(\.\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,3})(,\d{3})*(\.\d+)?$`)</span> // With symbols
        }, // matches 1,234,567.89 (comma for thousands, dot for decimals)
        1: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d+)(\.\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d+)(\.\d+)?$`)</span> // With symbols
        }, // matches 1234567.89 (no thousands separator, dot for decimals)
        2: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,3})( \d{1,3})*(,\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,3})( \d{1,3})*(,\d+)?$`)</span> // With symbols
        }, // matches 1 234 567,89 (space for thousands, comma for decimals)
        3: func(opts IsNumericOpts) *regexp.Regexp <span class="cov8" title="1">{
                if opts.NoSymbols </span><span class="cov8" title="1">{
                        return regexp.MustCompile(`^(\d{1,3})(\.\d{3})*(,\d+)?$`) // Without symbols
                }</span>
                <span class="cov8" title="1">return regexp.MustCompile(`^[+-]?(\d{1,3})(\.\d{3})*(,\d+)?$`)</span> // With symbols
        }, // matches 1.234.567,89 (dot for thousands, comma for decimals)
        4: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,3})(,\d{3})*(·\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,3})(,\d{3})*(·\d+)?$`)</span> // With symbols
        }, // matches 1,234,567·89 (comma for thousands, interpunct for decimals)
        5: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,2},)*(\d{1,3})(\.\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,2},)*(\d{1,3})(\.\d+)?$`)</span> // With symbols
        }, // matches 12,34,567.89 (Indian system: commas for thousands, dot for decimals)
        6: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,2} )*(\d{1,3})(\.\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,2} )*(\d{1,3})(\.\d+)?$`)</span> // With symbols
        }, // matches 12 34 567.89 (Indian system: space for thousands, dot for decimals)
        7: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,3})('\d{3})*(\.\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,3})('\d{3})*(\.\d+)?$`)</span> // With symbols
        }, // matches 1'234'567.89 (apostrophe for thousands, dot for decimals)
        8: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,3})(٬\d{3})*(٫\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,3})(٬\d{3})*(٫\d+)?$`)</span> // With symbols
        }, // matches ١٬٢٣٤٬٥٦٧٫٨٩ (Arabic: comma-like for thousands, period-like for decimals)
        9: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,3})( \d{3})*(\.\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,3})( \d{3})*(\.\d+)?$`)</span> // With symbols
        }, // matches 1 234 567.89 (space for thousands, dot for decimals)
        10: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,3})(\.\d{3})*(·\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,3})(\.\d{3})*(·\d+)?$`)</span> // With symbols
        }, // matches 1234567,89 (no thousands separator, comma for decimals)
        11: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d+)('\d{3})*(٫\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d+)('\d{3})*(٫\d+)?$`)</span> // With symbols
        }, // matches 12,34,567.89 (variant of Indian system with space and comma separators)
        12: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,3})( \d{3})*(,\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,3})( \d{3})*(,\d+)?$`)</span> // With symbols
        }, // matches Arabic format without spaces for thousands separators
        13: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d+)(٬\d{3})*(\.\d+)?$`) // Without symbols
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d+)(٬\d{3})*(\.\d+)?$`)</span> // With symbols
        }, // matches numbers without thousand separators, e.g., in East Asia (e.g., 1234.56)
        14: func(opts IsNumericOpts) *regexp.Regexp <span class="cov0" title="0">{
                if opts.NoSymbols </span><span class="cov0" title="0">{
                        return regexp.MustCompile(`^(\d{1,3})(,\d{3})*(\.\d{2})?$`) // Without symbols, 2 decimals
                }</span>
                <span class="cov0" title="0">return regexp.MustCompile(`^[+-]?(\d{1,3})(,\d{3})*(\.\d{2})?$`)</span> // With symbols, 2 decimals
        }, // matches 1 2345.67 (thousands separator every four digits, dot for decimals, variant)
}

// codeNumericFormats is the set of locales pointing to numericFormatsRegex
var codeNumericFormats = map[string]int{
        "ar":          8, // Arabic numeral system (1٬234٬567٫89)
        "ar-AE":       8,
        "ar-BH":       8,
        "ar-DZ":       8,
        "ar-EG":       8,
        "ar-IQ":       8,
        "ar-JO":       8,
        "ar-KW":       8,
        "ar-LB":       8,
        "ar-LY":       8,
        "ar-MA":       8,
        "ar-QA":       8,
        "ar-QM":       8,
        "ar-SA":       8,
        "ar-SD":       8,
        "ar-SY":       8,
        "ar-TN":       8,
        "ar-YE":       8,
        "bg-BG":       3, // Bulgarian (1.234.567,89)
        "cs-CZ":       3, // Czech (1.234.567,89)
        "da-DK":       3, // Danish (1.234.567,89)
        "de-DE":       3, // German (1.234.567,89)
        "en-AU":       0, // Australian English (1,234,567.89)
        "en-GB":       0, // British English (1,234,567.89)
        "en-HK":       0, // Hong Kong English (1,234,567.89)
        "en-IN":       5, // Indian English (12,34,567.89)
        "en-NZ":       0, // New Zealand English (1,234,567.89)
        "en-US":       0, // American English (1,234,567.89)
        "en-ZA":       0, // South African English (1,234,567.89)
        "en-ZM":       0, // Zambian English (1,234,567.89)
        "eo":          1, // Esperanto (1234567.89)
        "es-ES":       3, // Spanish (1.234.567,89)
        "fr-FR":       3, // French (1.234.567,89)
        "fr-CA":       0, // Canadian French (1,234,567.89)
        "hu-HU":       3, // Hungarian (1.234.567,89)
        "it-IT":       3, // Italian (1.234.567,89)
        "nb-NO":       3, // Norwegian Bokmål (1.234.567,89)
        "nl-NL":       3, // Dutch (1.234.567,89)
        "nn-NO":       3, // Norwegian Nynorsk (1.234.567,89)
        "pl-PL":       3, // Polish (1.234.567,89)
        "pt-BR":       3, // Brazilian Portuguese (1.234.567,89)
        "pt-PT":       3, // Portuguese (1.234.567,89)
        "ru-RU":       3, // Russian (1.234.567,89)
        "sl-SI":       3, // Slovenian (1.234.567,89)
        "sr-RS":       3, // Serbian (1.234.567,89)
        "sr-RS@latin": 3, // Serbian Latin (1.234.567,89)
        "sv-SE":       3, // Swedish (1.234.567,89)
        "tr-TR":       3, // Turkish (1.234.567,89)
        "uk-UA":       3, // Ukrainian (1.234.567,89)
}

// var codeNumericFormats = map[string]int{
//         "ar":          3, // Arabic (general)
//         "ar-AE":       3, // Arabic (United Arab Emirates)
//         "ar-BH":       3, // Arabic (Bahrain)
//         "ar-DZ":       3, // Arabic (Algeria)
//         "ar-EG":       3, // Arabic (Egypt)
//         "ar-IQ":       3, // Arabic (Iraq)
//         "ar-JO":       3, // Arabic (Jordan)
//         "ar-KW":       3, // Arabic (Kuwait)
//         "ar-LB":       3, // Arabic (Lebanon)
//         "ar-LY":       3, // Arabic (Libya)
//         "ar-MA":       3, // Arabic (Morocco)
//         "ar-QA":       3, // Arabic (Qatar)
//         "ar-QM":       3, // Arabic (Oman)
//         "ar-SA":       3, // Arabic (Saudi Arabia)
//         "ar-SD":       3, // Arabic (Sudan)
//         "ar-SY":       3, // Arabic (Syria)
//         "ar-TN":       3, // Arabic (Tunisia)
//         "ar-YE":       3, // Arabic (Yemen)
//         "bg-BG":       2, // Bulgarian (Bulgaria)
//         "cs-CZ":       2, // Czech (Czech Republic)
//         "da-DK":       3, // Danish (Denmark)
//         "de-DE":       3, // German (Germany)
//         "en-AU":       0, // English (Australia)
//         "en-GB":       0, // English (United Kingdom)
//         "en-HK":       0, // English (Hong Kong)
//         "en-IN":       5, // English (India)
//         "en-NZ":       0, // English (New Zealand)
//         "en-US":       0, // English (United States)
//         "en-ZA":       2, // English (South Africa)
//         "en-ZM":       0, // English (Zambia)
//         "eo":          0, // Esperanto
//         "es-ES":       3, // Spanish (Spain)
//         "fr-FR":       2, // French (France)
//         "fr-CA":       0, // French (Canada)
//         "hu-HU":       2, // Hungarian (Hungary)
//         "it-IT":       3, // Italian (Italy)
//         "nb-NO":       3, // Norwegian Bokmål (Norway)
//         "nl-NL":       3, // Dutch (Netherlands)
//         "nn-NO":       3, // Norwegian Nynorsk (Norway)
//         "pl-PL":       2, // Polish (Poland)
//         "pt-BR":       2, // Portuguese (Brazil)
//         "pt-PT":       2, // Portuguese (Portugal)
//         "ru-RU":       2, // Russian (Russia)
//         "sl-SI":       3, // Slovenian (Slovenia)
//         "sr-RS":       3, // Serbian (Cyrillic, Serbia)
//         "sr-RS@latin": 3, // Serbian (Latin, Serbia)
//         "sv-SE":       3, // Swedish (Sweden)
//         "tr-TR":       3, // Turkish (Turkey)
//         "uk-UA":       2, // Ukrainian (Ukraine)
// }

// A validator that check if a string is a number.
// options is an struct which defaults to { NoSymbols: false, Locale: ""}.
// If NoSymbols is true, the validator will reject numeric strings that feature a symbol (e.g. +, -, or .).
// Locale determines the numeric format and is one of ('ar', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', 'ar-JO', 'ar-KW', 'ar-LB', 'ar-LY', 'ar-MA', 'ar-QA', 'ar-QM', 'ar-SA', 'ar-SD', 'ar-SY', 'ar-TN', 'ar-YE', 'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'en-AU', 'en-GB', 'en-HK', 'en-IN', 'en-NZ', 'en-US', 'en-ZA', 'en-ZM', 'eo', 'es-ES', 'fr-FR', 'fr-CA', 'hu-HU', 'it-IT', 'nb-NO', 'nl-NL', 'nn-NO', 'pl-PL', 'pt-BR', 'pt-PT', 'ru-RU', 'sl-SI', 'sr-RS', 'sr-RS@latin', 'sv-SE', 'tr-TR', 'uk-UA'). If Locale is present but not in this list, Locale will default to en-US.
//
//        isNumber := govalidator.IsNumeric("+123.45", govalidator.IsNumericOpts{NoSymbols: true, Locale: ""})
//        fmt.Println(isNumber) // false
//        isNumber = govalidator.IsNumeric("-123.45", govalidator.IsNumericOpts{NoSymbols: false, Locale: ""})
//        fmt.Println(isNumber) // true
//        isNumber = govalidator.IsNumeric("+123.45", govalidator.IsNumericOpts{Locale: "en"})
//        fmt.Println(isNumber) // true
func IsNumeric(str string, opts IsNumericOpts) bool <span class="cov8" title="1">{
        var re *regexp.Regexp

        // has symbols and no Locale
        if !opts.NoSymbols &amp;&amp; opts.Locale == "" </span><span class="cov8" title="1">{
                re = regexp.MustCompile(`^[+-]?\d+(\.\d+)?$`)
                return re.MatchString(str)
        }</span>

        // no symbols and no Locale
        <span class="cov8" title="1">if opts.NoSymbols &amp;&amp; opts.Locale == "" </span><span class="cov8" title="1">{
                re = regexp.MustCompile(`^\d+$`)
                return re.MatchString(str)
        }</span>

        <span class="cov8" title="1">if opts.Locale == "" </span><span class="cov0" title="0">{
                opts.Locale = "en-US"
        }</span>

        // Locale is present and plus or minus symbols are optional(NoSymbol does not matter)
        <span class="cov8" title="1">codeNumForm := codeNumericFormats[opts.Locale]
        valFunc := numericFormatsRegex[codeNumForm]
        re = valFunc(opts)

        return re.MatchString(str)</span>
}

// // codeNumericFormats is the set of cldr chart codes
// var codeNumericFormats = map[string]int{
//         "af":      2, // Afrikaans
//         "sq":      2, // Albanian
//         "am":      0, // Amharic
//         "ar":      0, // Arabic
//         "hy":      2, // Armenian
//         "as":      5, // Assamese
//         "az":      3, // Azerbaijani
//         "bn":      5, // Bengali (India)
//         "eu":      3, // Basque
//         "be":      2, // Belarusian
//         "bs":      3, // Bosnian
//         "bg":      2, // Bulgarian
//         "de_CH":   7, // Swiss German
//         "fr_CH":   7, // Swiss French
//         "it_CH":   7, // Swiss Italian
//         "my":      0, // Burmese
//         "yue":     5, // Cantonese
//         "ca":      3, // Catalan
//         "chr":     5, // Cherokee
//         "zh":      0, // Chinese (Simplified)
//         "hr":      3, // Croatian
//         "cs":      2, // Czech
//         "da":      3, // Danish
//         "nl":      3, // Dutch
//         "en":      0, // English
//         "et":      2, // Estonian
//         "pt_PT":   2, // Portuguese (Portugal)
//         "fil":     0, // Filipino
//         "fi":      2, // Finnish
//         "fr":      2, // French
//         "gl":      3, // Galician
//         "ka":      2, // Georgian
//         "de":      3, // German
//         "el":      3, // Greek
//         "gu":      5, // Gujarati
//         "ha":      0, // Hausa
//         "hi":      0, // Hindi
//         "hi_Latn": 5, // Hindi (Latin script)
//         "hu":      2, // Hungarian
//         "is":      3, // Icelandic
//         "ig":      0, // Igbo
//         "id":      3, // Indonesian
//         "ga":      0, // Irish
//         "it":      3, // Italian
//         "ja":      0, // Japanese
//         "jv":      0, // Javanese
//         "kn":      5, // Kannada
//         "kk":      3, // Kazakh
//         "km":      0, // Khmer
//         "ko":      0, // Korean
//         "lo":      0, // Lao
//         "lv":      2, // Latvian
//         "lt":      2, // Lithuanian
//         "mk":      3, // Macedonian
//         "ms":      3, // Malay
//         "ml":      5, // Malayalam
//         "mr":      5, // Marathi
//         "mn":      0, // Mongolian
//         "ne":      5, // Nepali
//         "no":      3, // Norwegian
//         "fa":      3, // Persian
//         "pl":      2, // Polish
//         "pt_BR":   2, // Portuguese (Brazil)
//         "pa":      5, // Punjabi
//         "ro":      2, // Romanian
//         "ru":      2, // Russian
//         "sr":      3, // Serbian
//         "si":      5, // Sinhala
//         "sk":      2, // Slovak
//         "sl":      3, // Slovenian
//         "es":      3, // Spanish
//         "sw":      0, // Swahili
//         "sv":      3, // Swedish
//         "ta":      5, // Tamil
//         "te":      5, // Telugu
//         "th":      0, // Thai
//         "tr":      3, // Turkish
//         "uk":      2, // Ukrainian
//         "ur":      0, // Urdu
//         "uz":      3, // Uzbek
//         "vi":      0, // Vietnamese
//         "cy":      0, // Welsh
//         "yo":      0, // Yoruba
//         "zu":      0, // Zulu
// }
</pre>
		
		<pre class="file" id="file69" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string is a valid octal number.
func IsOctal(str string) bool <span class="cov0" title="0">{
        return regexp.MustCompile(`^[0-7]+$`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package validatorgo

import "regexp"

// countryCodePassportNumberRegex is the set of country codes and their validating regex
var countryCodePassportNumberRegex = map[string]*regexp.Regexp{
        "AM": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Armenia
        "AR": regexp.MustCompile(`^[A-Z]{3}\d{6}$`),      // Argentina
        "AT": regexp.MustCompile(`^[A-Z]\d{7}$`),         // Austria
        "AU": regexp.MustCompile(`^[A-Z]\d{7}$`),         // Australia
        "AZ": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Azerbaijan
        "BE": regexp.MustCompile(`^[A-Z]{2}\d{6}$`),      // Belgium
        "BG": regexp.MustCompile(`^\d{9}$`),              // Bulgaria
        "BY": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Belarus
        "BR": regexp.MustCompile(`^[A-Z]{2}\d{6}$`),      // Brazil
        "CA": regexp.MustCompile(`^[A-Z]{2}\d{6}$`),      // Canada
        "CH": regexp.MustCompile(`^[A-Z]\d{7}$`),         // Switzerland
        "CN": regexp.MustCompile(`^G\d{8}$|^E\d{8}$`),    // China
        "CY": regexp.MustCompile(`^[A-Z]{2}\d{6}$`),      // Cyprus
        "CZ": regexp.MustCompile(`^\d{8}$`),              // Czech Republic
        "DE": regexp.MustCompile(`^[C-FH]\d{8}$`),        // Germany
        "DK": regexp.MustCompile(`^\d{9}$`),              // Denmark
        "DZ": regexp.MustCompile(`^\d{9}$`),              // Algeria
        "EE": regexp.MustCompile(`^[A-Z]\d{7}$`),         // Estonia
        "ES": regexp.MustCompile(`^[A-Z]\d{7}$`),         // Spain
        "FI": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Finland
        "FR": regexp.MustCompile(`^\d{2}[A-Z]{2}\d{5}$`), // France
        "GB": regexp.MustCompile(`^\d{9}$`),              // United Kingdom
        "GR": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Greece
        "HR": regexp.MustCompile(`^\d{9}$`),              // Croatia
        "HU": regexp.MustCompile(`^[A-Z]{2}\d{6}$`),      // Hungary
        "IE": regexp.MustCompile(`^[A-Z]\d{7}$`),         // Ireland
        "IN": regexp.MustCompile(`^[A-Z]\d{7}$`),         // India
        "IR": regexp.MustCompile(`^[A-Z]\d{8}$`),         // Iran
        "ID": regexp.MustCompile(`^[A-Z]\d{7}$`),         // Indonesia
        "IS": regexp.MustCompile(`^[A-Z]{2}\d{6}$`),      // Iceland
        "IT": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Italy
        "JM": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Jamaica
        "JP": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Japan
        "KR": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // South Korea
        "KZ": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Kazakhstan
        "LI": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Liechtenstein
        "LT": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Lithuania
        "LU": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Luxembourg
        "LV": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Latvia
        "LY": regexp.MustCompile(`^\d{8}$`),              // Libya
        "MT": regexp.MustCompile(`^\d{7}$`),              // Malta
        "MX": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Mexico
        "MY": regexp.MustCompile(`^[A-Z]\d{8}$`),         // Malaysia
        "MZ": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Mozambique
        "NL": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Netherlands
        "NZ": regexp.MustCompile(`^[A-Z]\d{7}$`),         // New Zealand
        "PH": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Philippines
        "PK": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Pakistan
        "PL": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Poland
        "PT": regexp.MustCompile(`^[A-Z]{2}\d{6}$`),      // Portugal
        "RO": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Romania
        "RU": regexp.MustCompile(`^\d{9}$`),              // Russia
        "SE": regexp.MustCompile(`^\d{8}$`),              // Sweden
        "SL": regexp.MustCompile(`^\d{8}$`),              // Sierra Leone
        "SK": regexp.MustCompile(`^\d{8}$`),              // Slovakia
        "TH": regexp.MustCompile(`^[A-Z]\d{7}$`),         // Thailand
        "TR": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // Turkey
        "UA": regexp.MustCompile(`^[A-Z]{2}\d{6}$`),      // Ukraine
        "US": regexp.MustCompile(`^\d{9}$`),              // United States
        "ZA": regexp.MustCompile(`^[A-Z]{2}\d{7}$`),      // South Africa
}

// A validator that checks if the string is a valid passport number.
// countryCode is one of ['AM', 'AR', 'AT', 'AU', 'AZ', 'BE', 'BG', 'BY', 'BR', 'CA', 'CH', 'CN', 'CY', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'IE', 'IN', 'IR', 'ID', 'IS', 'IT', 'JM', 'JP', 'KR', 'KZ', 'LI', 'LT', 'LU', 'LV', 'LY', 'MT', 'MX', 'MY', 'MZ', 'NL', 'NZ', 'PH', 'PK', 'PL', 'PT', 'RO', 'RU', 'SE', 'SL', 'SK', 'TH', 'TR', 'UA', 'US', 'ZA']. Locale list is validator.passportNumberLocales.
func IsPassportNumber(str, countryCode string) bool <span class="cov8" title="1">{
        re, exists := countryCodePassportNumberRegex[countryCode]

        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return re.MatchString(str)</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string is a valid port number.
func IsPort(str string) bool <span class="cov0" title="0">{
        return regexp.MustCompile(`^([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string is a Semantic Versioning Specification (SemVer).
func IsSemVer(str string) bool <span class="cov8" title="1">{
        return regexp.MustCompile(`^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$`).MatchString(str)
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">package validatorgo

import "strings"

// A validator that checks if the string is uppercase.
func IsUpperCase(str string) bool <span class="cov8" title="1">{
        return str == strings.ToUpper(str)
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">package validatorgo

func IsVAT(str, countryCode string) bool <span class="cov0" title="0">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">package validatorgo

// A validator that checks if the string consists only of characters that appear in the whitelist chars.
func IsWhitelisted(str, chars string) bool <span class="cov8" title="1">{
        charsM := make(map[string]int)

        for _, char := range chars </span><span class="cov8" title="1">{
                val := string(char)
                _, exist := charsM[val]

                if exist </span><span class="cov0" title="0">{
                        charsM[val] += 1
                }</span> else<span class="cov8" title="1"> {
                        charsM[val] = 1
                }</span>
        }

        <span class="cov8" title="1">for _, st := range str </span><span class="cov8" title="1">{
                val := string(st)

                _, exist := charsM[val]

                if !exist </span><span class="cov8" title="1">{
                        return false
                }</span>

        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package validatorgo

import "regexp"

// A validator that checks if the string matches the pattern.
func Matches(str string, re *regexp.Regexp) bool <span class="cov8" title="1">{
        return re.MatchString(str)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
